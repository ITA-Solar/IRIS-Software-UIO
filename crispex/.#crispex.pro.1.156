;+
; NAME:
;   CRISPEX: CRIsp SPectral EXplorer
;
; PURPOSE:
;   This procedure allows browsing and analysis of multidimensional data cubes. The procedure was
;   initially written for analysis of temporal spectropolarimetric data obtained with the CRISP 
;   instrument at the Swedish Solar Telescope (SST) at La Palma (Spain), however any data formatted 
;   in a particular way (cf. the online reference pages) may be fed to CRISPEX for browsing and/on
;	  analysis purposes
;
; CATEGORY:
;   Data browsing and analysis
;
; CALLING SEQUENCE:
;   CRISPEX, Imcube
;
; INPUTS:
;	  Imcube        - 3D image datacube (dimensions [nx,ny,nt*nlp*ns]) or, if SPCUBE is not provided,
;                   a scan (dimensions [nx,ny,nlp]). If SINGLE_CUBE is specified a 3D datacube may 
;                   be provided even if SPCUBE is not. Allowed data types: BYTE, INTEGER, FLOAT.
;
; OPTIONAL INPUTS:
;	  Spcube        - 3D spectral datacube (dimensions [nlp,nt,nx*ny*ns]). Required input if 
;                   SINGLE_CUBE is not supplied with the number of linepositions and Imcube is a 
;                   time series. Allowed data types: BYTE, INTEGER, FLOAT.
;
; KEYWORDS:
;	  REFCUBE	      - Reference data of same spatial dimensions as main data. REFCUBE may be supplied
;                   with either:
;			                * 2D data array: dimensions [nx,ny].
;			                * 3D data array: dimensions [nx,ny,refnt], where refnt must be equal to nt.
;			                * Scalar string: pointing to a reference image cube of dimensions [nx,nx,
;                       refnt*refnlp] where refnt must be equal to 1 or to nt, but refnlp need not 
;                       be equal to nlp.
;		 	                * 2-element string array: first element pointing to a reference image cube 
;                       (dimensions [nx,ny,nt*refnlp]), the second element pointing to the 
;                       corresponding reference spectral cube (dimensions [refnlp,refnt,nx*ny]). 
;                       Again, refnt must be equal to 1 or nt, while any (positive integer) value of 
;                       refnlp is allowed. 
;                   Allowed data types: BYTE, INTEGER, FLOAT.
;   SJICUBE       - Slit-jaw image data corresponding to the main data. Must be supplied with a
;                   scalar string pointing to a slit-jaw image cube of dimensions
;                   [sjinx,sjiny,sjint], where sjinx, sjiny and sjint need not be equal to nx, ny or
;                   nt, respectively. Allowed data types: BYTE, INTEGER, FLOAT.
;	  MASKCUBE	    - Mask data of same spatial dimensions as main data. Must be supplied with a scalar
;                   string pointing to a mask image cube of dimensions [nx,ny,masknt] where masknt 
;                   must be equal to nt or 1. Allowed data types: BYTE, INTEGER, FLOAT.
;	  SPECTFILE	    - File containing the normalised spectrum as function of the linepositions or 
;                   wavelength. Contains the required variables:
;			                * NORM_SPECT (normalised spectrum)
;                     * NORM_FACTOR (normalisation factor used to produce NORM_SPECT) 
;                     * SPECT_POS (spectral wavelength positions in any desired unit). 
;                       Optional variables: XTITLE and YTITLE (x- and y-title label for plots, 
;                       respectively). If not set, the mean spectrum is determined from the scan(s) 
;                       determined by the MNSPEC keyword (i.e. from all x,y pixels at all 
;                       linepositions at t given by the setting of MNSPEC).
;                   SPECTFILE may be supplied with either:
;			                * Scalar string: spectral file corresponding to main data.
;			                * 2-element string array: first element is the spectral file corresponding to 
;                       the main data, second element corresponds to the reference data.
;			              Set first element to '' if you only want to set the reference spectral file, e.g. 
;                   SPECTFILE=['','reference.spectfile'].
;                   Setting of SPECTFILE will be ignored if FITS cubes are provided to Imcube, Spcube
;                   and/or REFCUBE.
;	  LINE_CENTER	  - Specifies line centre or wavelength information. LINE_CENTER may be supplied with:
;			                * Integer scalar: linecentre is set to position specified by LINE_CENTER.
;			                * 1D 2-element array (format: [WAVELENGTH, DELTA_LAMBDA]): linecentre is 
;                       determined from the data and set to WAVELENGTH. The distance in wavelength 
;                       between the linepositions is specified by DELTA_LAMBDA.
;			                * 1D 3-element array (format: [Integer scalar, WAVELENGTH, DELTA_LAMBDA]): 
;                       combination of the two above.
;			                * 2D 1-element integer array (format: [[Integer scalar], [Integer scalar]]): 
;                       first element sets the linecentre position for the main data, the second 
;                       element that of the reference data.
;			                * 2D 2-element array (format: [[MAIN_WAVELENGTH, MAIN_DELTA_LAMBDA],
;                       [REF_WAVELENGTH, REF_DELTA_LAMBDA]]): the elements from the first subarray 
;                       set the linecentre wavelength and wavelength spacing for the main data, 
;                       while those of the second subarray set those values for the reference data.
;			                * 2D 3-element array (format: [[Integer scalar, MAIN_WAVELENGTH, 
;                       MAIN_DELTA_LAMBDA],[Integer scalar, REF_WAVELENGTH, REF_DELTA_LAMBDA]]): 
;                       combination of the two above.
;                   If not set: linecentre is determined from the data or from SPECTFILE.
;                   Setting of LINE_CENTER will be ignored if FITS cubes are provided to Imcube,
;                   Spcube and/or REFCUBE.
;	  MNSPEC        - Determines the calculation of the average spectrum for in-program display. 
;                   MNSPEC may be supplied with:
;			                * Integer scalar: mean spectrum is determined from the t=MNSPEC scan.
;			                * 2-element integer array: mean spectrum is determined from the t=MNSPEC[0] 
;                       through t=MNSPEC[1] scans.
;                   If not set: mean spectrum is determined from the t=0 scan.
;	  DT            - Specifies the elapsed time in seconds per time step. Defaults to not defined, 
;                   showing frame number instead of time on the vertical axes.
;	  EXTS          -	If set, the time slices/slabs displayed in the program will be exact timeslices, 
;			              obtained through linear interpolation, rather than approximated timeslices, 
;                   obtained through nearest-neighbour interpolation (which is the default setting). 
;                   Note that setting this keyword may slow down the browsing of the spectral range 
;                   (i.e. movement of the spectral slider) considerably, because of the
;                   computationally more expensive linear interpolation.
;	  SINGLE_CUBE	  - Single integer value specifying the number of spectral positions of the 
;                   datacube. Only to be used when IMCUBE is provided with a 3D spectrotemporal 
;                   datacube and SPCUBE is not specified.
;	  SCALE_STOKES  - If set, the detailed and average spectra of Stokes Q, U and/or V will be scaled
;                   to the maximum of Stokes I (i.e. I/I, Q/I, U/I and/or V/I). If not set, each 
;                   Stokes component will be scaled to its respective maximum.
;	  SCALE_CUBES	  - Specifies the value that the data should be multiplied with. SCALE_CUBES may be
;                   supplied with:
;			                * Integer scalar: value used for the main data.
;			                * 2-element integer array: first element is used for the main data, the second
;                       for the reference data.
;                   Defaults to 1.
;	  NO_WARP		    - Prevents the warping of the temporal spectrum when the wavelength spacing is 
;                   non-equidistant. Applies equally to both sets of data if reference data is 
;                   supplied. Defaults to not set.
;	  XTITLE		    - Sets the x-title of the temporal spectrum and the detailed spectrum. XTITLE may
;                   be supplied with:
;			                * Scalar string: x-title labels for the main temporal spectrum and detailed 
;                       spectrum.
;			                * 2-element string array: first element sets the x-title labels for the main 
;                       temporal spectrum and detailed spectrum, while the second element sets the 
;                       labels for the reference data.
;			              Set first element to '' if you only want to set the reference x-title, e.g. 
;                   XTITLE=['','Height [km]'].
;   YTITLE		    - Sets the y-title of the detailed spectrum. YTITLE may be supplied with:
;			                * Scalar string: y-title label for the detailed spectrum.
;			                * 2-element string array: first element sets the y-title label for the main 
;                       detailed spectrum, while the second element sets the label for the 
;                       reference data.
;			              Set first element to '' if you only want to set the reference y-title, e.g. 
;                   YTITLE=['','Velocity [km/s]'].
;	  WINDOW_LARGE	- Override the "1:1 window scaling whenever possible" setting.
;                   Useful for data with small nx and/or ny, where 1:1 image
;                   display is possible, but would yield small image display
;                   windows. If set to 1 (i.e., as flag) the window sizes will
;                   be determined based on the machine screen sizes. If set to a
;                   value larger than 1, the main image y-size will be set to
;                   that value, but only if it exceeds the native image y-size.
;                   Defaults to not set.
;	  VERBOSE		    - Verbosity setting for program setup and running. Mainly for maintenance purposes. 
;                   Verbosity levels can be set by supplying the keyword with the following values 
;                   (add bitwise):
;				              * 0:  No verbosity.
;				              * 1:  Basic setup verbosity.
;				              * 2:  Extended setup verbosity.
;				              * 4:  Basic runtime verbosity.
;				              * 8:  Extended runtime verbosity.
;				              * 16: Playback statistics verbosity.
;			              In practice the values 3 and 7 are not useful and 1 has become obsolete for all 
;                   practical purposes. All values larger than 26 are reduced to 26, all values 
;                   smaller than 0 are set to 0. Note that verbosity levels may also be set or
;                   changed at runtime.
;
; OUTPUTS:
;	  Window outputs:
;     Depending on the call. In all cases at least three windows will appear, one of which being the
;		  control panel, one the main image window and one the detailed spectrum window. If called with:
;			  - one datacube, then an additional window will open, showing the spectrum along a slit;
;			  - two datacubes, then an additional window will open, showing the temporal spectrum;
;			  - three datacubes, then two additional windows will open, one showing the temporal
;			    spectrum and one showing the reference image from the third cube;
;			  - four datacubes, then four additional windows will open, one showing the main temporal spectrum,
;			    one showing the reference temporal spectrum, one showing the reference detailed spectrum and
;			    one showing the reference image.
;		  Additional data display windows may be accessed through the tabs in the control panel in all 
;		  cases, although not all data display windows may be available, depending on the number of data 
;		  cubes with which the program is called.
;	  Saveable outputs:
;		  - loop path points (*.CLSAV file);
;		  - loop path or detection space-time diagram (*.CSAV file). Note that only that part of the
;       space-time diagram between the current lower and upper t-values will be saved, i.e., if you
;       wish to save it for the full range in time, be sure to reset the temporal boundaries.
;	  	- intensity versus time data for specific linepositions (*.CINT file);
;		  - (selected) timeseries as MPEG movie;
;		  - selected frame as JPEG snapshot;
;	  	- (selected) timeseries as JPEG files;
;		  - current session (*.CSES file).
;
; RESTRICTIONS:
;   Requires the following procedures and functions:
;     Procedures: FITS_OPEN, FITS_CLOSE         [if reading FITS cubes]
;     Functions:  IRIS_HISTO_OPT(), STR2UTC(),  [general; included in SolarSoft]
;                 UTC2STR()  
;                 READFITS()                    [if reading FITS cubes]
;
; PROCEDURE:
;   In default setting, four windows are opened, one control panel and three subsidiary windows 
;   containing the main image, the temporal spectrum and the detailed spectrum, respectively. 
;   Additional data browsing and analysis options/windows may be obtained through control panel 
;   options.
;
;	  Some example calling sequences are discussed below. The most common calling sequence is:
;
;		  CRISPEX, 'main.imcube', 'main.spcube'
;
;	  Spectral information may be supplied either through the use of a spectral save file or the use 
;   of the LINE_CENTER keyword, e.g.:
;
;		  CRISPEX, 'main.imcube', 'main.spcube', SPECTFILE='main.spectfile'
;	  or
;		  CRISPEX, 'main.imcube', 'main.spcube', LINE_CENTER=[6562,0.1]
;
;	  Reference data may be viewed by supplying such data to the REFCUBE keyword, either in the 
;   simple reference mode:
;
;		  CRISPEX, 'main.imcube', 'main.spcube', REFCUBE='ref.imcube'
;
;	  or in the dual cube mode:
;
;		  CRISPEX, 'main.imcube', 'main.spcube', REFCUBE=['ref.imcube', 'ref.spcube']
;
;	  In addition, when running in dual cube mode, one may provide arrays to certain keywords in 
;   order to set options for both the main and the reference data, e.g.:
;	
;		  CRISPEX, 'main.imcube', 'main.spcube', REFCUBE=['ref.imcube', 'ref.spcube'], 
;			  SPECTFILE=['main.spectfile','ref.specftile']
;	  or
;		  CRISPEX, 'main.imcube', 'main.spcube', REFCUBE=['ref.imcube', 'ref.spcube'], 
;			  LINE_CENTER=[[6562,0.1],[8542,0.1]]
;	  etc.
;
;	  One may also set some of the options for the reference cube only (while retaining the default 
;   options for the main data) by setting the element corresponding to the main data to an empty 
;   scalar string, e.g.:
;
;		  CRISPEX, 'main.imcube', 'main.spcube', REFCUBE=['ref.imcube', 'ref.spcube'], 
;			  YTITLE=['','Velocity [km/s]']
;
;	  Further information on the calling sequence and specific options can be found in the online 
;   reference pages, which can be reached through the in-program help function or by going directly 
;   to http://folk.uio.no/~gregal/crispex
;
; MODIFICATION HISTORY:
;	  2009 Feb 11 GV: start buildup of program, based on Øystein Langangen's August 2008 
;			              version of CRISP_SPECTRAL_EXPLORER.PRO. Further (structural) inspiration from 
;                   XIMOVIE.PRO by Oivind Wikstol and XSLICE.PRO by Alfred de Wijn
;	  2009 Feb 21 GV: incorporation of LP_HEADER.PRO functionality
;	  2009 Feb 24 GV: release of beta version (v0.9)
;	  2009 Mar 02 GV: implementation of x- and y-slice display (v0.9.1)
;	  2009 Mar 04 GV: implementation of display of spectral slice along a slit, including controls to
;			              set slit angle and length (v0.9.3)
;	  2009 Mar 09 GV: implementation of movement along the slit direction	(v0.9.4)
;	  2009 Mar 10 GV: implementation of option to study spectral scan and show a reference image or
;			              cube (v0.9.5)
;	  2009 Mar 15 GV: implementation of zoom option (v0.9.6)
;	  2009 Mar 23 GV: implementation of time slice along a segmented line and	option to save the
;			              resulting data(v0.9.7)
;	  2009 Apr 14 GV: corrected extraction and saving of time slice, removed x- and y-slice display
;			              due to redundancy from spectral slice along a slit (v0.9.8)
;	  2009 May 15 GV: implementation of extended save and retrieve options, extended image scaling	
;			              options, save and restore session options, adjustable time and spectral range, 
;			              different loop linestyles, selection menu for loop overlays, parameter overview 
;			              window and display of saved timeslices (v0.9.9)
;	  2009 Aug 24 GV: implementation of extra zoomfactors, save as MPEG and JPEG options, save from	
;			              detection file, spectral and temporal range choice in saving timeslabs, exact 
;			              timeslice display in-program, resizable display windows, read-in of full 
;			              reference cubes and an option to calculate mean spectrum over a range in 
;			              timesteps (v1.0)
;	  2009 Nov 05 GV: implementation of loop path feedback, shortcut controls through keyboard,	
;			              single full cube call and also fixed a number of bugs (v1.1)
;	  2010 Mar 10 GV: enabled visualisation of Stokes cube data, display of reference and image cube	
;			              data values, drawing of loop paths for 3D temporal image cube, retreival and
;			              saving timeslices from reference cube, extended scaling options for reference
;			              cube image, implemented spatial measurement tool and help function, moved user
;			              feedback to pop-up windows, disposed of obsolete keywords and fixed a number
;			              of bugs (v1.5)
;	  2011 Jul 11 GV: enabled dual cube mode, in-program Doppler images, extended (Stokes) spectral	
;			              options, extended plot options, blinking while playing, setting of preferences, 
;			              extraction of intensity-time plots, and made aesthetic improvements (bitmap
;			              play buttons, better cursor visibility and startup screen) (v1.6)
;	  2011 Aug 22 GV: extended save as options, implemented save as PNG, saving of color MPEG, an	
;			              option to open a restored loop in TANAT and fixed a number of bugs(v1.6.1)
;	  2012 Mar 23 GV: extended reference and Stokes data input options, implemented mask overlays,	
;			              enabled display of multiple space-time diagrams and fixed a number of bugs (v1.6.2)
;	  2012 Dec 04 GV: extended in-program analysis options through display of reference space-time 	
;			              diagram, extended image and space-time diagram scaling options and fixed a
;			              number of bugs (v1.6.3)
;
; ACKNOWLEDGEMENTS:
;	  This code would not be present in its current state and with the current functionalities without
;	  the relentless practical testing and the valuable input and ideas of Luc Rouppe van der Voort,
;	  Sven Wedemeyer-Böhm, Mats Carlsson, Patrick Antolin, Jorrit Leenaarts, Bart de Pontieu, 
;	  Eamon Scullion and Jaime de la Cruz Rodriguez. 
;
; AUTHOR:
;	  Gregal Vissers (g.j.m.vissers@astro.uio.no)
;	  @ Institute of Theoretical Astrophysics, University of Oslo
;   
;-

;========================= CRISPEX FUNCTIONS
;------------------------- ARRAY ANALYSIS FUNCTION
FUNCTION CRISPEX_ARRAY_GET_GAP, input_array, ntotal
  ; Determines the lower and upper boundaries of gaps in an array. Returns the
  ; indices between which the gap occurs (gap_bound_low, gap_bound_upp)
  ninput_array = N_ELEMENTS(input_array)
  ; Sort input_array, just in case
  input_array = input_array[SORT(input_array)]
  ; Set initial values
  databounds = 0L
  ngaps = 0L
  wdatabounds = 0L
  ; Handle lower boundary first
  ngaps += (input_array[0] NE 0) 
  ; Failsafe against le 2-element arrays
  IF (ninput_array LE 2) THEN BEGIN
    databounds = 0    ; Set the first databound
    IF (ninput_array EQ 2) THEN BEGIN
      IF (ABS(input_array[1]-input_array[0]) NE 1) THEN $
        databounds = [databounds, 0, 1] 
    ENDIF
  ENDIF ELSE BEGIN
    ; Consider input_array, excluding the first point (which has been dealt with
    ; separately
    sel_array = input_array[1:ninput_array-1]
    shift_diff = SHIFT(sel_array,-1) - sel_array
    ; Since shift_diff has ninput-1 elements and want to exclude last one
    ; (due to wrap-around): ninput-1-1-1 = ninput-3
    whereshift = WHERE(shift_diff[0:ninput_array-3] NE 1, count)
    ; Are there any "non-one" shifts; add those gap boundaries
    IF (count NE 0) THEN BEGIN
      FOR i=0,count-1 DO $
        databounds = [databounds, REPLICATE(whereshift[i],2)+[1,2]]
      ngaps += LONG(count)
    ENDIF
  ENDELSE
  ; Handle upper boundary
  databounds = [databounds, (ninput_array-1)]
  ngaps += (input_array[ninput_array-1] NE (ntotal-1)) 
  wdatabounds = input_array[databounds]
  ; Save and return result structure
  result = {ngaps:ngaps, databounds:databounds, wdatabounds:wdatabounds}
  RETURN, result
END


;------------------------- APPLICATION USER DIRECTORY FUNCTION
FUNCTION CRISPEX_CONFIG_DIR
; Handles creation and update of ~/.idl/gvissers/crispex/ contents 
  ; Author details
  author_dirname = 'gvissers'
  author_desc = 'Gregal Vissers (g.j.m.vissers@astro.uio.no), '+$
    'Institute of Theoretical Astrophsyics, '+ $
    'University of Oslo'
  author_readme_version = 1

  ; Application details
  app_dirname = 'crispex'
  app_desc = 'CRISPEX: CRIsp SPectral EXplorer'
  app_readme_txt = [$
    'This is the user configuration directory for CRISPEX, ',$
    'written by Gregal Vissers (g.j.m.vissers@astro.uio.no), ',$
    'Institute of Theoretical Astrophysics, University of Oslo.',$
    'It is used to store user preferences and enable instance ',$
    'tracking. Both the directory and its contents can be safely ',$
    'deleted, however, any stored settings will then be lost.']
  app_readme_version = 1

  RETURN, APP_USER_DIR(author_dirname, author_desc, $
    app_dirname, app_desc, app_readme_txt, app_readme_version, $
    AUTHOR_README_VERSION=author_readme_version)

END

;------------------------- CONVERSION FUNCTIONS
FUNCTION CRISPEX_TRANSFORM_DEC2BIN, decimal_number
; Handles the conversion of decimal to binary number
	IF (decimal_number NE 0) THEN BEGIN
		coarse_p = ALOG10(DOUBLE(decimal_number))/ALOG10(2.D)
		p = FLOOR(coarse_p)
		i=0
		binary_array = INTARR(FLOOR(coarse_p)+1)
		b = REVERSE((2^FINDGEN(FLOOR(coarse_p)+1)))
		WHILE (p GE 0) DO BEGIN
			IF (2^p LE decimal_number) THEN BEGIN
				binary_array[i] = 1
				decimal_number -= 2^p
			ENDIF ELSE binary_array[i] = 0
			p -= 1
			i += 1
		ENDWHILE
		binary_array = REVERSE(binary_array)
		IF (N_ELEMENTS(binary_array) LT 5) THEN $
      binary_array = [binary_array, REPLICATE(0,5-N_ELEMENTS(binary_array))]
	ENDIF ELSE binary_array = [0,0,0,0,0]
	RETURN, binary_array
END

FUNCTION CRISPEX_TRANSFORM_COORDS, x_in, y_in, dx_in, dx_out, dy_in, dy_out, $
  refxval_in, refxval_out, refyval_in, refyval_out, $
  refxpix_in, refxpix_out, refypix_in, refypix_out
  ; Conversion is from system "in" to "out"
  x_out = ((x_in-refxpix_in)*dx_in + (refxval_in-refxval_out)) / dx_out + $
            refxpix_out
  y_out = ((y_in-refypix_in)*dy_in + (refyval_in-refyval_out)) / dy_out + $
            refypix_out
  result = {x:x_out, y:y_out}
  RETURN, result
END

FUNCTION CRISPEX_TRANSFORM_DATA2DEVICE, info, X_IN=x_in, Y_IN=y_in, MAIN=main, $
  REFERENCE=reference, SJI=sji, INVERSE=inverse
  IF KEYWORD_SET(MAIN) THEN BEGIN
    xpos = (*(*info).zooming).xpos
    ypos = (*(*info).zooming).ypos
    winx = (*(*info).winsizes).xywinx
    winy = (*(*info).winsizes).xywiny
    d_nx = (*(*info).dataparams).d_nx
    d_ny = (*(*info).dataparams).d_ny
  ENDIF ELSE IF KEYWORD_SET(REFERENCE) THEN BEGIN
    xpos = (*(*info).zooming).xrefpos
    ypos = (*(*info).zooming).yrefpos
    winx = (*(*info).winsizes).refwinx
    winy = (*(*info).winsizes).refwiny
    d_nx = (*(*info).dataparams).d_refnx
    d_ny = (*(*info).dataparams).d_refny
  ENDIF ELSE IF KEYWORD_SET(SJI) THEN BEGIN
    xpos = (*(*info).zooming).xsjipos
    ypos = (*(*info).zooming).ysjipos
    winx = (*(*info).winsizes).sjiwinx
    winy = (*(*info).winsizes).sjiwiny
    d_nx = (*(*info).dataparams).d_sjinx
    d_ny = (*(*info).dataparams).d_sjiny
  ENDIF
  x_out = -1
  y_out = -1
  IF ~KEYWORD_SET(INVERSE) THEN BEGIN
    ; Data -> Device: add 0.5 pixel offset to center cursor on pixel, instead of
    ; on IDL default lower left corner
    IF (N_ELEMENTS(X_IN) NE 0) THEN x_out = (x_in+0.5 - xpos) * winx / (d_nx+1)
    IF (N_ELEMENTS(Y_IN) NE 0) THEN y_out = (y_in+0.5 - ypos) * winy / (d_ny+1)
  ENDIF ELSE BEGIN
    ; Device -> Data
    IF (N_ELEMENTS(X_IN) NE 0) THEN x_out = x_in * (d_nx+1) / winx + xpos
    IF (N_ELEMENTS(Y_IN) NE 0) THEN y_out = y_in * (d_ny+1) / winy + ypos
  ENDELSE
  result = {x:x_out, y:y_out}
  RETURN, result
END

FUNCTION CRISPEX_TRANSFORM_GET_COORDMAPS, hdr, MAINREF=mainref, $
  MAINSJI=mainsji, REFSJI=refsji
  ; Create main index map
  IF KEYWORD_SET(MAINREF) OR KEYWORD_SET(MAINSJI) THEN BEGIN
    idxarr_main = LONARR(2,hdr.nx,hdr.ny)
    xarr = LINDGEN(hdr.nx)
    yarr = LINDGEN(hdr.ny)
    FOR x=0,hdr.nx-1 DO idxarr_main[1,x,*] = yarr
    FOR y=0,hdr.ny-1 DO idxarr_main[0,*,y] = xarr
    a = idxarr_main
    dx_a = hdr.dx
    dy_a = hdr.dy
    refxval_a = hdr.xval
    refyval_a = hdr.yval
    refxpix_a = hdr.xpix
    refypix_a = hdr.ypix
  ENDIF
  ; Create reference index map
  IF KEYWORD_SET(MAINREF) OR KEYWORD_SET(REFSJI) THEN BEGIN
    idxarr_ref = LONARR(2,hdr.refnx,hdr.refny)
    xarr = LINDGEN(hdr.refnx)
    yarr = LINDGEN(hdr.refny)
    FOR x=0,hdr.refnx-1 DO idxarr_ref[1,x,*] = yarr
    FOR y=0,hdr.refny-1 DO idxarr_ref[0,*,y] = xarr
    IF KEYWORD_SET(MAINREF) THEN BEGIN
      b = idxarr_ref 
      dx_b = hdr.refdx
      dy_b = hdr.refdy
      refxval_b = hdr.xval_ref
      refyval_b = hdr.yval_ref
      refxpix_b = hdr.xpix_ref
      refypix_b = hdr.ypix_ref
    ENDIF ELSE BEGIN
      a = idxarr_ref
      dx_a = hdr.refdx
      dy_a = hdr.refdy
      refxval_a = hdr.xval_ref
      refyval_a = hdr.yval_ref
      refxpix_a = hdr.xpix_ref
      refypix_a = hdr.ypix_ref
    ENDELSE
  ENDIF
  ; Create slit-jaw image index map
  IF KEYWORD_SET(MAINSJI) OR KEYWORD_SET(REFSJI) THEN BEGIN
    idxarr_sji = LONARR(2,hdr.sjinx,hdr.sjiny)
    xarr = LINDGEN(hdr.sjinx)
    yarr = LINDGEN(hdr.sjiny)
    FOR x=0,hdr.sjinx-1 DO idxarr_sji[1,x,*] = yarr
    FOR y=0,hdr.sjiny-1 DO idxarr_sji[0,*,y] = xarr
    b = idxarr_sji
    dx_b = hdr.sjidx
    dy_b = hdr.sjidy
    refxval_b = hdr.xval_sji
    refyval_b = hdr.yval_sji
    refxpix_b = hdr.xpix_sji
    refypix_b = hdr.ypix_sji
  ENDIF
  ; Create conversion maps
  pix_a2b = LONARR(2,(SIZE(a))[2], (SIZE(a))[3])
  pix_b2a = LONARR(2,(SIZE(b))[2], (SIZE(b))[3])
  pix_a2b[0,*,*] = ((a[0,*,*]-refxpix_a)*dx_a + (refxval_a-refxval_b)) / dx_b + $
                    refxpix_b
  pix_a2b[1,*,*] = ((a[1,*,*]-refypix_a)*dy_a + (refyval_a-refyval_b)) / dy_b + $
                    refypix_b
  pix_b2a[0,*,*] = ((b[0,*,*]-refxpix_b)*dx_b + (refxval_b-refxval_a)) / dx_a + $
                    refxpix_a
  pix_b2a[1,*,*] = ((b[1,*,*]-refypix_b)*dy_b + (refyval_b-refyval_a)) / dy_a + $
                    refypix_a
  result = {pix_a2b:pix_a2b, pix_b2a:pix_b2a}
  RETURN, result
END

FUNCTION CRISPEX_TRANSFORM_GET_WCS, x_in, y_in, wcs_a, wcs_b, $
  PIXEL=pixel, COORD=coord, NO_ROUND=no_round
; Wrapper for WCS functions in order to process arrays
  xy_out = [[x_in], [y_in]]
  FOR i=0,N_ELEMENTS(x_in)-1 DO BEGIN
    IF KEYWORD_SET(COORD) THEN $
      xy_out[i,*] = WCS_GET_COORD(wcs_a, [xy_out[i,0], xy_out[i,1]])
    IF KEYWORD_SET(PIXEL) THEN $
      xy_out[i,*] = WCS_GET_PIXEL(wcs_b, [xy_out[i,0], xy_out[i,1]])
  ENDFOR
  IF ~KEYWORD_SET(NO_ROUND) THEN xy_out = ROUND(xy_out)
  x_out = REFORM(xy_out[*,0])
  y_out = REFORM(xy_out[*,1])
  result = {x:x_out, y:y_out}
  RETURN, result
END

;------------------------- BUTTON GROUP FUNCTIONS
FUNCTION CRISPEX_BGROUP_DIAGNOSTICS_SELECT, event
; Handles selection of diagnostics and calls necessary replot procedures
  WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  IF (event.VALUE EQ 0) THEN BEGIN
    (*(*info).intparams).disp_diagnostics = REPLICATE(1,(*(*info).intparams).ndiagnostics)   
    (*(*info).intparams).ndisp_diagnostics = TOTAL((*(*info).intparams).disp_diagnostics)
    FOR i=0,(*(*info).intparams).ndiagnostics-1 DO $
      WIDGET_CONTROL, (*(*info).ctrlscp).specwin_button_ids[i+1], /SET_BUTTON, /SENSITIVE
  ENDIF ELSE BEGIN
    sel_idx = event.VALUE-1
    (*(*info).intparams).disp_diagnostics[sel_idx] = event.SELECT 
    (*(*info).intparams).ndisp_diagnostics = TOTAL((*(*info).intparams).disp_diagnostics)
    IF ((*(*info).intparams).ndisp_diagnostics EQ 1) THEN $
      WIDGET_CONTROL, (*(*info).ctrlscp).specwin_button_ids[$
        WHERE((*(*info).intparams).disp_diagnostics EQ 1)+1], SENSITIVE=0 $
    ELSE $
      FOR i=0,(*(*info).intparams).ndiagnostics-1 DO $
        WIDGET_CONTROL, (*(*info).ctrlscp).specwin_button_ids[i+1], /SENSITIVE
  ENDELSE
  WIDGET_CONTROL, (*(*info).ctrlscp).specwin_button_ids[0], $
    SENSITIVE=((*(*info).intparams).ndisp_diagnostics NE (*(*info).intparams).ndiagnostics), $
    SET_BUTTON=((*(*info).intparams).ndisp_diagnostics EQ (*(*info).intparams).ndiagnostics)
  ; Adjust slider settings based on available lp-range
  low_sel = (WHERE((*(*info).intparams).disp_diagnostics EQ 1, nwhereq1))[0]
  upp_sel = (WHERE((*(*info).intparams).disp_diagnostics EQ 1))[nwhereq1-1]
  lp_low = (*(*info).intparams).diag_start[low_sel]
  lp_upp = (*(*info).intparams).diag_start[upp_sel] + (*(*info).intparams).diag_width[upp_sel]-1
  IF (lp_low NE (*(*info).dispparams).lp_low) THEN $
    CRISPEX_DISPRANGE_LP_LOW, event, LP_SET=lp_low, /NO_DRAW
  IF (lp_upp NE (*(*info).dispparams).lp_upp) THEN $
    CRISPEX_DISPRANGE_LP_UPP, event, LP_SET=lp_upp, /NO_DRAW
  IF ((*(*info).intparams).ndisp_diagnostics NE (*(*info).intparams).ndisp_refdiagnostics) THEN BEGIN
    IF (*(*info).ctrlsswitch).lp_ref_lock THEN $
      CRISPEX_SLIDER_LP_REF_LOCK, event, /UNLOCK, /NO_DRAW
    WIDGET_CONTROL, (*(*info).ctrlscp).lp_ref_but, SENSITIVE=0
  ENDIF ELSE $
    WIDGET_CONTROL, (*(*info).ctrlscp).lp_ref_but, /SENSITIVE
  CRISPEX_DRAW_GET_SPECTRAL_AXES, event, /MAIN
  CRISPEX_UPDATE_T, event
  CRISPEX_SCALING_APPLY_SELECTED, event
  IF (*(*info).winswitch).showsp THEN BEGIN
    CRISPEX_UPDATE_SPSLICE, event
    CRISPEX_DISPLAYS_SP_REPLOT_AXES, event
  ENDIF
  IF (*(*info).winswitch).showphis THEN BEGIN
    CRISPEX_UPDATE_PHISLICE, event, /NO_DRAW
    CRISPEX_DISPLAYS_PHIS_REPLOT_AXES, event
  ENDIF
  CRISPEX_DRAW, event, /NO_REF
END

FUNCTION CRISPEX_BGROUP_REFDIAGNOSTICS_SELECT, event
; Handles selection of reference diagnostics and calls necessary replot procedures
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info	
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  IF (event.VALUE EQ 0) THEN BEGIN
    (*(*info).intparams).disp_refdiagnostics = REPLICATE(1,(*(*info).intparams).nrefdiagnostics)   
    (*(*info).intparams).ndisp_refdiagnostics = TOTAL((*(*info).intparams).disp_refdiagnostics)
    FOR i=0,(*(*info).intparams).nrefdiagnostics-1 DO $
      WIDGET_CONTROL, (*(*info).ctrlscp).refspecwin_button_ids[i+1], /SET_BUTTON, /SENSITIVE
  ENDIF ELSE BEGIN
    sel_idx = event.VALUE-1
    (*(*info).intparams).disp_refdiagnostics[sel_idx] = event.SELECT
    (*(*info).intparams).ndisp_refdiagnostics = TOTAL((*(*info).intparams).disp_refdiagnostics)
    IF ((*(*info).intparams).ndisp_refdiagnostics EQ 1) THEN $
      WIDGET_CONTROL, (*(*info).ctrlscp).refspecwin_button_ids[$
        WHERE((*(*info).intparams).disp_refdiagnostics EQ 1)+1], SENSITIVE=0 $
    ELSE $
      FOR i=0,(*(*info).intparams).nrefdiagnostics-1 DO $
        WIDGET_CONTROL, (*(*info).ctrlscp).refspecwin_button_ids[i+1], /SENSITIVE
  ENDELSE
  WIDGET_CONTROL, (*(*info).ctrlscp).refspecwin_button_ids[0], $
    SENSITIVE=((*(*info).intparams).ndisp_refdiagnostics NE (*(*info).intparams).nrefdiagnostics), $
    SET_BUTTON=((*(*info).intparams).ndisp_refdiagnostics EQ (*(*info).intparams).nrefdiagnostics)
  ; Adjust slider settings based on available lp-range
  low_sel = (WHERE((*(*info).intparams).disp_refdiagnostics EQ 1, nwhereq1))[0]
  upp_sel = (WHERE((*(*info).intparams).disp_refdiagnostics EQ 1))[nwhereq1-1]
  lp_low = (*(*info).intparams).refdiag_start[low_sel]
  lp_upp = (*(*info).intparams).refdiag_start[upp_sel] + (*(*info).intparams).refdiag_width[upp_sel]-1
  IF (lp_low NE (*(*info).dispparams).lp_ref_low) THEN $
    CRISPEX_DISPRANGE_LP_REF_RANGE, event, LP_LOW=lp_low, /NO_DRAW
  IF (lp_upp NE (*(*info).dispparams).lp_ref_upp) THEN $
    CRISPEX_DISPRANGE_LP_REF_RANGE, event, LP_UPP=lp_upp, /NO_DRAW
  IF ((*(*info).intparams).ndisp_diagnostics NE (*(*info).intparams).ndisp_refdiagnostics) THEN BEGIN
    IF (*(*info).ctrlsswitch).lp_ref_lock THEN $
      CRISPEX_SLIDER_LP_REF_LOCK, event, /UNLOCK, /NO_DRAW
    WIDGET_CONTROL, (*(*info).ctrlscp).lp_ref_but, SENSITIVE=0
  ENDIF ELSE $
    WIDGET_CONTROL, (*(*info).ctrlscp).lp_ref_but, /SENSITIVE
  CRISPEX_DRAW_GET_SPECTRAL_AXES, event, /REFERENCE
  CRISPEX_UPDATE_T, event
  CRISPEX_SCALING_APPLY_SELECTED, event
  IF (*(*info).winswitch).showrefsp THEN BEGIN
    CRISPEX_UPDATE_REFSPSLICE, event
    CRISPEX_DISPLAYS_REFSP_REPLOT_AXES, event
  ENDIF
  CRISPEX_DRAW, event, /NO_MAIN
END

FUNCTION CRISPEX_BGROUP_MASTER_TIME, event
; Handles the change mask overlay window
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  ; Get old time 
  CASE (*(*info).dispparams).master_time OF
    0:  BEGIN
          t_old = (*(*(*info).dispparams).tarr_main)[(*(*info).dispparams).t_main]
          nt_old = (*(*info).dataparams).mainnt
        END
    1:  BEGIN
          t_old = (*(*(*info).dispparams).tarr_ref)[(*(*info).dispparams).t_ref]
          nt_old = (*(*info).dataparams).refnt
        END
    2:  BEGIN
          t_old = (*(*(*info).dispparams).tarr_sji)[(*(*info).dispparams).t_sji]
          nt_old = (*(*info).dataparams).sjint
        END
  ENDCASE
  ; Get new timing master
  (*(*info).dispparams).master_time = event.VALUE
  ; Reset timing offset to defaults
  (*(*info).dispparams).toffset_main = (*(*info).dataparams).default_toffset_main
  (*(*info).dispparams).toffset_ref = (*(*info).dataparams).default_toffset_ref
  CRISPEX_COORDS_TRANSFORM_T, event, T_OLD=t_old, NT_OLD=nt_old
  CRISPEX_UPDATE_T, event
  IF (*(*info).winswitch).showsp THEN CRISPEX_DISPLAYS_SP_REPLOT_AXES, event
  IF (*(*info).winswitch).showrefsp THEN CRISPEX_DISPLAYS_REFSP_REPLOT_AXES, event
	CRISPEX_DRAW, event
  WIDGET_CONTROL, (*(*info).ctrlscp).t_slider, SET_SLIDER_MIN=(*(*info).dispparams).t_low, $
    SET_SLIDER_MAX=((*(*info).dispparams).t_upp<(*(*info).dataparams).nt)
END

FUNCTION CRISPEX_BGROUP_STOKES_SELECT_SP, event, NO_DRAW=no_draw
  WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).stokesparams).prev_select_sp = (*(*info).stokesparams).select_sp
		(*(*info).stokesparams).select_sp[WHERE((*(*info).stokesparams).labels EQ $
                                      (*(*info).stokesparams).button_labels[event.VALUE])] = $
                                      event.SELECT
  sens = (TOTAL((*(*info).stokesparams).select_sp) NE 1)
	FOR i=0,TOTAL((*(*info).stokesparams).select_sp)-1 DO BEGIN
    FOR k=0,N_ELEMENTS((*(*info).stokesparams).button_labels)-1 DO BEGIN
		  IF (((*(*info).stokesparams).labels)[(WHERE((*(*info).stokesparams).select_sp EQ 1))[i]] EQ $
           (*(*info).stokesparams).button_labels[k]) THEN $
        WIDGET_CONTROL, (*(*info).ctrlscp).stokes_spbutton_ids[k], SENSITIVE = sens, /SET_BUTTON 
    ENDFOR
	ENDFOR
  CRISPEX_UPDATE_SSP, event
	CRISPEX_DISPLAYS_LS_RESIZE, event, /STOKES_SELECT
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [STRJOIN(((*(*info).stokesparams).labels)[$
      WHERE((*(*info).stokesparams).select_sp EQ 1)],', ')],labels=['Stokes detspect selected']
END

FUNCTION CRISPEX_BGROUP_STOKES_SELECT_XY, event, NO_DRAW=no_draw;, SET_STOKES=set_stokes
  WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
;  IF (N_ELEMENTS(SET_STOKES) NE 1) THEN idx = event.VALUE ELSE idx = set_stokes
  (*(*info).dataparams).s = $
    WHERE((*(*info).stokesparams).labels EQ (*(*info).stokesparams).button_labels[event.VALUE])
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [((*(*info).stokesparams).labels)[(*(*info).dataparams).s]],$
                         labels=['Stokes image selected']
  IF ~KEYWORD_SET(NO_DRAW) THEN BEGIN
;  	WIDGET_CONTROL, (*(*info).ctrlsparam).stokes_val, $
;      SET_VALUE = STRTRIM(((*(*info).stokesparams).labels)[(*(*info).dataparams).s],2)
    CRISPEX_SCALING_APPLY_SELECTED, event
  	CRISPEX_DISPLAYS_STOKES_SELECT_XY_RECOVER_YRANGE, event
  	CRISPEX_UPDATE_T, event
  	CRISPEX_UPDATE_SLICES, event, /NO_DRAW, $
      NO_PHIS=((*(*info).winswitch).showphis EQ 0) 
  	IF ((*(*info).winids).sptlb GT 0) THEN CRISPEX_DISPLAYS_SP_REPLOT_AXES, event
	  CRISPEX_DRAW, event
  ENDIF
END

FUNCTION CRISPEX_BGROUP_ZOOMFAC_SET, event, NO_DRAW=no_draw, $
          NO_UPDATE_SLIDERS=no_update_sliders, SET_FACTOR_IDX=set_factor_idx, $
          UNSET_FACTOR_IDX=unset_factor_idx
; Sets the zoomfactor and changes options and paramters accordingly
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  IF (N_ELEMENTS(SET_FACTOR_IDX) EQ 1) THEN BEGIN
    idx = set_factor_idx   & select = 1B
    IF (N_ELEMENTS(UNSET_FACTOR_IDX) EQ 1) THEN $
      (*(*info).zooming).factorswitch[unset_factor_idx]= 0B
  ENDIF ELSE BEGIN
    idx = event.VALUE & select = BYTE(event.SELECT)
  ENDELSE
  (*(*info).zooming).factorswitch[idx] = select
  (*(*info).zooming).factor = ((*(*info).zooming).factors)[idx]
  IF ((*(*info).zooming).factor EQ 1) THEN BEGIN
    (*(*info).zooming).xpos = 0	&	(*(*info).zooming).ypos = 0
    IF (*(*info).winswitch).showref THEN BEGIN
      (*(*info).zooming).xrefpos = 0 & (*(*info).zooming).yrefpos = 0
    ENDIF
    IF (*(*info).winswitch).showsji THEN BEGIN
      (*(*info).zooming).xsjipos = 0 & (*(*info).zooming).ysjipos = 0
    ENDIF
  ENDIF
  sensitive = [(((*(*info).dataparams).nx NE 1) AND ((*(*info).zooming).factor NE 1)),$
    ((*(*info).zooming).factor NE 1)]
  ; Focus will always be on the main image window when zooming (either through
  ; buttons or shortcuts), so only need to grab main coordinates
	IF (*(*info).curs).lockset THEN BEGIN
		cursor_x = (*(*info).curs).xlock
		cursor_y = (*(*info).curs).ylock
	ENDIF ELSE BEGIN
		cursor_x = (*(*info).dataparams).x
		cursor_y = (*(*info).dataparams).y
	END
  IF ~KEYWORD_SET(NO_UPDATE_SLIDERS) THEN $
  	CRISPEX_ZOOM_UPDATE_SLIDERS, event, cursor_x=cursor_x, cursor_y=cursor_y, SENSITIVE=sensitive
  ; Input all code from above routine here

  FOR i=0,N_ELEMENTS((*(*info).zooming).factors)-1 DO $
    WIDGET_CONTROL, ((*(*info).ctrlscp).zoom_button_ids)[i], $
                    SET_BUTTON = ((*(*info).zooming).factorswitch)[i]
	CRISPEX_ZOOM, event, NO_DRAW=no_draw
END

FUNCTION CRISPEX_BGROUP_MASK_OVERLAY, event
; Handles the change mask overlay window
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	maskim = (*(*info).overlayswitch).maskim
	maskim[event.value] = event.select
	(*(*info).overlayswitch).maskim = maskim
	CRISPEX_DRAW, event
END

FUNCTION CRISPEX_BGROUP_RASTER_OVERLAY, event
; Handles the change raster overlay window
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  CASE event.VALUE OF
    0:  (*(*info).overlayswitch).refraster = event.SELECT
    1:  (*(*info).overlayswitch).sjiraster = event.SELECT
    2:  (*(*info).overlayswitch).rastertiming = event.SELECT
  ENDCASE
	CRISPEX_DRAW, event
END

FUNCTION CRISPEX_BGROUP_INT_SEL_ALLNONE, event
; Handles the change in plotting of selected diagnostics
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  select_all = ABS(event.VALUE-1) ;  event.VALUE = 0: select all, 1: select none
  IF select_all THEN $
  	*(*(*info).intparams).seldisp_diagnostics = $
      REPLICATE(1,N_ELEMENTS(*(*(*info).intparams).seldisp_diagnostics)) $
  ELSE $
  	*(*(*info).intparams).seldisp_diagnostics = $
      REPLICATE(0,N_ELEMENTS(*(*(*info).intparams).seldisp_diagnostics))
	FOR i=0,N_ELEMENTS(*(*(*info).intparams).seldisp_diagnostics)-1 DO BEGIN
    btname = 'int_sel_bt_'+STRTRIM(i,2)   ; (De)select button name
    dgname = 'int_sel_dg_'+STRTRIM(i,2)   ; Diagnostics combobox name
    lpname = 'int_sel_lp_'+STRTRIM(i,2)   ; Wavelength combobox name
    lsname = 'int_sel_ls_'+STRTRIM(i,2)   ; Line-style combobox name
    clname = 'int_sel_cl_'+STRTRIM(i,2)   ; Color combobox name
		WIDGET_CONTROL, WIDGET_INFO(event.TOP, FIND_BY_UNAME=btname), SET_BUTTON=select_all
		WIDGET_CONTROL, WIDGET_INFO(event.TOP, FIND_BY_UNAME=dgname), SENSITIVE=select_all
		WIDGET_CONTROL, WIDGET_INFO(event.TOP, FIND_BY_UNAME=lpname), SENSITIVE=select_all
		WIDGET_CONTROL, WIDGET_INFO(event.TOP, FIND_BY_UNAME=lsname), SENSITIVE=select_all
		WIDGET_CONTROL, WIDGET_INFO(event.TOP, FIND_BY_UNAME=clname), SENSITIVE=select_all
	ENDFOR		
	WIDGET_CONTROL, (*(*info).ctrlsint).int_sel_save, SENSITIVE=select_all
	CRISPEX_DRAW_INT, event
END

;------------------------- READ BMP BUTTONS FUNCTION
FUNCTION CRISPEX_READ_BMP_BUTTONS, filename, srcdir
; Handles the reading of (button) BMP files
	button_dummy = READ_BMP(srcdir+filename)  
	button_dummy = TRANSPOSE(button_dummy, [1,2,0])
	RETURN, button_dummy
END


;------------------------- IO FUNCTIONS
FUNCTION CRISPEX_FITSPOINTER, filename, header, EXTEN_NO=exten_no, SILENT=silent
;	Finds starting position of data block in extension number exten_no in fits files 
; Based on earlier FITSPOINTER.PRO, modification history:
;   v1.0 20-Sep-2012 Viggo Hansteen - first version
;   v1.1 27-Sep-2013 Mats Carlsson - added to CRISPEX directory
; Incorporated functionality into CRISPEX on 10-Oct-2013
  IF N_PARAMS() LT 1 THEN BEGIN
    MESSAGE,'fitspointer,filename ,header,exten_no=exten_no,silent=silent',/CONT
    RETURN,-1
  ENDIF
    
  doheader=ARG_PRESENT(header)
  IF N_ELEMENTS(exten_no) EQ 0 THEN exten_no=0L  
  silent=KEYWORD_SET(silent)

  OPENR, unit, filename, ERROR=error,/GET_LUN
  IF error NE 0 then begin
    MESSAGE,/CON,' ERROR - Unable to locate file ' + filename
    RETURN, -1
  ENDIF

;  Handle Unix or Fpack compressed files which will be opened via a pipe using
;  the SPAWN command. 
;  ViggoH 19092012: This piece of code can be uncommented at a later date if we want to
;  include this capability...

  ;; if unixZ then begin
  ;;               free_lun, unit
  ;;               spawn, 'gzip -cd '+filename, unit=unit                 
  ;;               gzip = 1b
  ;; endif else if fcompress then begin 
  ;;               free_lun, unit
  ;;               spawn,'funpack -S ' + filename, unit=unit,/sh
  ;;               if eof(unit) then begin 
  ;;                 message,'Error spawning FPACK decompression',/CON
  ;;                 free_lun,unit
  ;;                 return,-1
  ;;                endif    
  ;;       endif   
  ;; endelse

  hbuf=36
  datapointer=0L

  FOR ext = 0L, exten_no DO BEGIN
               
;  Read the next header, and get the number of bytes taken up by the data.

    block = STRING(REPLICATE(32b,80,36))
    w = [-1]
    header = STRARR(36)
    headerblock = 0L
    i = 0L      

    WHILE w[0] EQ -1 DO BEGIN
          
      IF EOF(unit) THEN BEGIN 
            MESSAGE,/CON, $
               'EOF encountered attempting to read extension ' + STRTRIM(ext,2)
            FREE_LUN,unit
            RETURN,-1
      ENDIF

      READU, unit, block
      headerblock = headerblock + 1
      w = WHERE(STRLEN(block) NE 80, Nbad)
      IF (Nbad GT 0) THEN BEGIN
           MESSAGE,'Warning-Invalid characters in header',/INF,NoPrint=Silent
           block[w] = STRING(REPLICATE(32b, 80))
      ENDIF
      w = WHERE(STRCMP(block,'END     ',8), Nend)
      IF (headerblock EQ 1) || ((ext EQ exten_no) && (doheader)) THEN BEGIN
        IF Nend GT 0 THEN  BEGIN
          IF headerblock EQ 1 THEN header = block[0:w[0]]   $
          ELSE header = [header[0:i-1],block[0:w[0]]]
       ENDIF ELSE BEGIN
         header[i] = block
         i = i+36
         IF i MOD hbuf EQ 0 THEN header = [header,strarr(hbuf)]
       ENDELSE
      ENDIF
      datapointer=datapointer+2880L
    ENDWHILE

    IF (ext EQ 0 ) THEN $
      IF STRMID( header[0], 0, 8)  NE 'SIMPLE  ' THEN BEGIN
        MESSAGE,/CON, $
           'ERROR - Header does not contain required SIMPLE keyword'
      IF ~unitsupplied THEN FREE_LUN, unit
      RETURN, -1
    ENDIF
             
; Get parameters that determine size of data region.
                
    bitpix =  SXPAR(header,'BITPIX')
    byte_elem = ABS(bitpix)/8               ;Bytes per element
    naxis  = SXPAR(header,'NAXIS')
    gcount = SXPAR(header,'GCOUNT') > 1
    pcount = SXPAR(header,'PCOUNT')
                
    IF naxis GT 0 THEN BEGIN 
      dims = SXPAR( header,'NAXIS*')           ;Read dimensions
      ndata = PRODUCT(dims,/integer)
    ENDIF ELSE ndata = 0
                
    nbytes = byte_elem * gcount * (pcount + ndata)

;  Move to the next extension header in the file.   Use MRD_SKIP to skip with
;  fastest available method (POINT_LUN or readu) for different file
;  types (regular, compressed, Unix pipe, socket) 

    IF ext LT exten_no THEN BEGIN
      nrec = LONG64((nbytes + 2879) / 2880)
      IF nrec GT 0 THEN mrd_skip, unit, nrec*2880L
      datapointer=datapointer+nrec*2880L    
   ENDIF
  ENDFOR

  CASE BITPIX OF 
           8:   IDL_type = 1          ; Byte
          16:   IDL_type = 2          ; Integer*2
          32:   IDL_type = 3          ; Integer*4
          64:   IDL_type = 14         ; Integer*8
         -32:   IDL_type = 4          ; Real*4
         -64:   IDL_type = 5          ; Real*8
        ELSE:   BEGIN
                MESSAGE,/CON, 'ERROR - Illegal value of BITPIX (= ' +  $
                STRTRIM(bitpix,2) + ') in FITS header'
                IF ~unitsupplied THEN FREE_LUN,unit
                RETURN, -1
                END
  ENDCASE     
 
  IF nbytes EQ 0 THEN BEGIN
    IF ~SILENT THEN MESSAGE, $
         "FITS header has NAXIS or NAXISi = 0,  no data array read",/CON
    FREE_LUN, unit
    RETURN,-1
  ENDIF

  IF exten_no GT 0 THEN BEGIN
    xtension = STRTRIM( SXPAR( header, 'XTENSION' , Count = N_ext),2)
    IF N_ext EQ 0 THEN MESSAGE, /INF, NoPRINT = Silent, $
          'WARNING - Header missing XTENSION keyword'
  ENDIF 

  IF ~SILENT THEN BEGIN   ;Print size of array being read
    IF exten_no GT 0 THEN MESSAGE, $
             'Reading FITS extension of type ' + xtension, /INF  
    IF N_elements(dims) EQ 1 THEN $
        st = 'Now reading ' + STRTRIM(dims,2) + ' element vector' ELSE $                 
        st = 'Now reading ' + STRJOIN(STRTRIM(dims,2),' by ') + ' array'
        IF (exten_no GT 0) && (pcount GT 0) THEN st = st + ' + heap area'
        MESSAGE,/INF,st   
  ENDIF
  FREE_LUN, unit
  RETURN,datapointer  
END

;------------------------- LOOP GET FUNCTION
FUNCTION CRISPEX_GET_PATH, xp_in, yp_in, np_in, nx_in, ny_in
  xp_out = xp_in  & yp_out = yp_in
  ; If this function is called and number of elements is 1, that means the
  ; coordinates are out of range
  IF (N_ELEMENTS(xp_out) NE 1) THEN BEGIN
    ; Interpolate the points with ~1 pixel separation
  	SPLINE_P, xp_out, yp_out, xr_out, yr_out, INTERVAL=1
    xyp_out_of_range = $
      ((xp_out[np_in-1] LT 0) OR $
       (xp_out[np_in-1] GE nx_in) OR $
       (yp_out[np_in-1] LT 0) OR $
       (yp_out[np_in-1] GE ny_in))
  ENDIF ELSE BEGIN
    xr_out = xp_out
    yr_out = yp_out
    xyp_out_of_range = 1
  ENDELSE
  result = {xp:xp_out, yp:yp_out, xr:xr_out, yr:yr_out, $
            xyp_out_of_range:xyp_out_of_range}
  RETURN, result
END

;------------------------- MAIN/REF BLINK FUNCTION
FUNCTION CRISPEX_GET_IMREF_BLINK_BOUNDS, pix_main2ref, pix_ref2main, $
  xlow_main, xupp_main, ylow_main, yupp_main, $
  xlow_ref, xupp_ref, ylow_ref, yupp_ref
  ; Determine the main/reference blink window parameters
  ; Get main boundaries in terms of reference coordinate system
  xylow_main2ref = REFORM(pix_main2ref[*,xlow_main,ylow_main])
  xyupp_main2ref = REFORM(pix_main2ref[*,xupp_main,yupp_main])
  ; Get reference boundaries in terms of main coordinate system
  xylow_ref2main = REFORM(pix_ref2main[*,xlow_ref,ylow_ref])
  xyupp_ref2main = REFORM(pix_ref2main[*,xupp_ref,yupp_ref])
  ; Create index array for main on ref
  xref_selarray = INDGEN(xyupp_main2ref[0]-xylow_main2ref[0]+1)+$
                    xylow_main2ref[0]
  yref_selarray = INDGEN(xyupp_main2ref[1]-xylow_main2ref[1]+1)+$
                    xylow_main2ref[1]
  ; Create index array for ref on main
  x_selarray = INDGEN(xyupp_ref2main[0]-xylow_ref2main[0]+1)+$
                xylow_ref2main[0]
  y_selarray = INDGEN(xyupp_ref2main[1]-xylow_ref2main[1]+1)+$
                xylow_ref2main[1]
  ; Select elements within range
  xref_selarray = xref_selarray[$
                    WHERE((xref_selarray GE xlow_ref) AND $
                          (xref_selarray LE xupp_ref))]
  yref_selarray = yref_selarray[$
                    WHERE((yref_selarray GE ylow_ref) AND $
                          (yref_selarray LE yupp_ref))]
  x_selarray = x_selarray[$
                WHERE((x_selarray GE xlow_main) AND $
                      (x_selarray LE xupp_main))]
  y_selarray = y_selarray[$ 
                WHERE((y_selarray GE ylow_main) AND $
                      (y_selarray LE yupp_main))]
  ; Get boundaries
  x_main = [x_selarray[0],$
            x_selarray[N_ELEMENTS(x_selarray)-1]]
  y_main = [y_selarray[0],$
            y_selarray[N_ELEMENTS(y_selarray)-1]]
  x_ref = [xref_selarray[0],$
            xref_selarray[N_ELEMENTS(xref_selarray)-1]]
  y_ref = [yref_selarray[0],$
            yref_selarray[N_ELEMENTS(yref_selarray)-1]]
  ; Write and return results
  result = {x_main:x_main, y_main:y_main, x_ref:x_ref, y_ref:y_ref, $
    nx_sel:N_ELEMENTS(xref_selarray), ny_sel:N_ELEMENTS(yref_selarray)}
  RETURN, result
END

;------------------------- SCALING FUNCTIONS
FUNCTION CRISPEX_SCALING_CONTRAST, minimum_init, maximum_init, $
  minimum_perc, maximum_perc
  minimum_init = DOUBLE(minimum_init)
  maximum_init = DOUBLE(maximum_init)
  range = maximum_init-minimum_init
  minmax = [minimum_init+range*FLOAT(minimum_perc)/100.,$
            minimum_init+range*FLOAT(maximum_perc)/100.]
  RETURN, minmax
END

FUNCTION CRISPEX_SCALING_SLICES, dispim, gamma_val, histo_opt_val, $
  default_min, default_max, FORCE_HISTO=force_histo
  IF (gamma_val NE 1) THEN BEGIN
    whereneg = WHERE(dispim LT 0, nwhereneg)
    IF (nwhereneg GT 0) THEN BEGIN
      dispim = (TEMPORARY(ABS(dispim)))^gamma_val
      dispim[whereneg] *= -1.
    ENDIF ELSE $
      dispim = (TEMPORARY((dispim)))^gamma_val
  ENDIF
  IF ((histo_opt_val NE 0) OR KEYWORD_SET(FORCE_HISTO)) THEN BEGIN
    IF (MIN(dispim, MAX=dispmax, /NAN) NE dispmax) THEN BEGIN
      dispim = IRIS_HISTO_OPT(dispim, histo_opt_val, MISSING=-32768, /SILENT)
    ENDIF
  ENDIF
  minimum = MIN(dispim,MAX=maximum, /NAN)
  IF ((N_ELEMENTS(default_min) EQ 1) AND (N_ELEMENTS(default_max) EQ 1)) THEN $
    minmax = CRISPEX_SCALING_CONTRAST(minimum,maximum,$
      default_min, default_max) $
  ELSE $
    minmax = [minimum,maximum]
  RETURN, minmax
END

FUNCTION CRISPEX_SCALING_DESCALE, data, bscale, bzero
  missing = WHERE(data EQ -32768,count)
  floatdata = FLOAT(data)*bscale+bzero
  IF (count GT 0) THEN floatdata[missing] = !VALUES.F_NAN
  RETURN, floatdata
END

;------------------------- SLIDER FUNCTION
FUNCTION CRISPEX_SLIDER_LP_DIAG, event, lp_diag_all, REFERENCE=reference, BLINK=blink
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  IF KEYWORD_SET(REFERENCE) THEN BEGIN
    disp_diag = WHERE((*(*info).intparams).refdisp_diagnostics EQ 1)
    lp = (*(*info).dataparams).lp_ref
    diag_start = (*(*info).intparams).refdiag_start
    diag_width = (*(*info).intparams).refdiag_width
  ENDIF ELSE BEGIN
    disp_diag = WHERE((*(*info).intparams).disp_diagnostics EQ 1)
    IF KEYWORD_SET(BLINK) THEN $
      lp = (*(*info).pbparams).lp_blink $
    ELSE $
      lp = (*(*info).dataparams).lp
    diag_start = (*(*info).intparams).diag_start
    diag_width = (*(*info).intparams).diag_width
  ENDELSE
  disp_diff = lp_diag_all - disp_diag
  constraint_low = WHERE(disp_diff GT 0, COMPLEMENT=constraint_upp) 
  disp_low_next = (disp_diag[constraint_low])[$
    (WHERE(disp_diff[constraint_low] EQ MIN(disp_diff[constraint_low])))[0]]
  disp_upp_next = (disp_diag[constraint_upp])[$
    (WHERE(ABS(disp_diff[constraint_upp]) EQ MIN(ABS(disp_diff[constraint_upp]))))[0]]
  dist_low = lp - (diag_start[disp_low_next]+diag_width[disp_low_next]-1)
  dist_upp = ABS(lp - diag_start[disp_upp_next])
  RETURN, [dist_low,dist_upp,disp_low_next,disp_upp_next]
END

;------------------------- PLOTAXES FUNCTION
FUNCTION CRISPEX_PLOTAXES_XTICKVALS_SELECT, xtickvals_in, TICKSEP=ticksep, DOPPLER=doppler
  ; Mark every TICKSEP-th major tickmark, if total # < TICKSEP: mark the middle one
  IF (N_ELEMENTS(TICKSEP) NE 1) THEN ticksep = 4.
  nxtickvals = N_ELEMENTS(xtickvals_in)
  nticks_select = FLOOR(nxtickvals/ticksep+1) > 1
  IF KEYWORD_SET(DOPPLER) THEN BEGIN
    whereeq0 = WHERE(xtickvals_in EQ 0., count)
    IF (count GT 0) THEN $
      wheremiddle = whereeq0[0] $
    ELSE $
      wheremiddle = FLOOR(nxtickvals/2.)
;    wheremiddle = (WHERE(xtickvals_in EQ 0.))[0] $
  ENDIF ELSE $
    wheremiddle = FLOOR(nxtickvals/2.)
  ; Check whether able to fit multiple major tickmarks
  IF ((wheremiddle GT ticksep/2.) OR $
    (KEYWORD_SET(DOPPLER) AND (nticks_select GT 1))) THEN BEGIN
    diffarray = INDGEN(nxtickvals)*ticksep
    ; Select tickmarks centred on middle, but excluding middle (unless Doppler)
    diffarray -= diffarray[wheremiddle];-ticksep/2.
    IF ~KEYWORD_SET(DOPPLER) THEN diffarray -= ticksep/2.
    selarray = (INDGEN(nxtickvals))[wheremiddle] + diffarray
    whereselarray = WHERE((selarray GE 0) AND (selarray LT nxtickvals), count)
    IF (count GT 0) THEN $
      whereselect = selarray[whereselarray] $
    ELSE $
      whereselect = wheremiddle
  ENDIF ELSE $
    whereselect = wheremiddle
  xtickvals_tmp = REPLICATE(' ',nxtickvals)
  ; Determine output format from input format
  xtickvals_in = STRTRIM(xtickvals_in,2)
  ; Assuming all xtick_get values are formatted equally
  decimal_switch = (N_ELEMENTS(STRSPLIT(xtickvals_in[0],'.',/EXTRACT)) EQ 2)
  split_array = STRARR(nxtickvals,2)
  FOR i=0,nxtickvals-1 DO split_array[i,*] = STRSPLIT(xtickvals_in[i],'.',/EXTRACT)
  ; Get number of digits left of period
  IF KEYWORD_SET(DOPPLER) THEN $;BEGIN
    min_splitarray = MIN(split_array[*,0],MAX=max_splitarray)
  ; Get number of decimals
  IF decimal_switch THEN BEGIN
    done = 0
    check_array = split_array[*,1]
    maxlen = MAX(STRLEN(check_array))
    wherenotmax = WHERE(STRLEN(check_array) NE maxlen, count)
    IF (count NE 0) THEN BEGIN
      add_array = maxlen-STRLEN(check_array)
      FOR i=0,nxtickvals-1 DO BEGIN
        IF (add_array[i] NE 0) THEN $
          check_array[i] = check_array[i]+STRJOIN(REPLICATE('0',add_array[i]))
      ENDFOR
    ENDIF
    WHILE (done EQ 0) DO BEGIN
      strpos_array = STRPOS(check_array,'0',/REVERSE_SEARCH)  
      IF ((N_ELEMENTS(strpos_array[UNIQ(strpos_array)]) EQ 1) AND $
        (MAX(STRLEN(check_array)) GT 0)) THEN $
        check_array = STRMID(check_array,0,strpos_array[0]) $
      ELSE $
        done = 1
    ENDWHILE
    ndecimals = STRLEN(check_array[0])
  ENDIF ELSE ndecimals = 0
  IF (ndecimals GT 0) THEN $
    xtick_format ='(F'+STRTRIM(STRLEN(split_array[whereselect,0])+ndecimals+(ndecimals GT 0),2)+'.'+$
      STRTRIM(ndecimals,2)+')' $
  ELSE $
    xtick_format ='(I'+STRTRIM(STRLEN(split_array[whereselect,0]),2)+')'
  FOR i=0,N_ELEMENTS(whereselect)-1 DO $
    xtickvals_tmp[whereselect[i]] = STRING(xtickvals_in[whereselect[i]],FORMAT=xtick_format[i])
  xtickvals_out = [xtickvals_tmp,REPLICATE(' ',60-nxtickvals)]
  RETURN, xtickvals_out
END

FUNCTION CRISPEX_PLOTAXES_XDOPTICKLOC, xdoptickvals_orig, sel_criterion, vdop_xrange, $
  plot_xrange
  ; Determine Doppler tick mark locations
  xdopticksel = xdoptickvals_orig[sel_criterion]
  vdoprange = vdop_xrange[1]-vdop_xrange[0]
  xdoptickloc = (xdopticksel - vdop_xrange[0])/vdoprange * $
    (plot_xrange[1]-plot_xrange[0]) + plot_xrange[0]
  RETURN, xdoptickloc
END

;------------------------- WIDGET FUNCTION
FUNCTION CRISPEX_WIDGET_DIVIDER, base
  divider_base = WIDGET_BASE(base, /FRAME, /YSIZE)
  divider_labl = WIDGET_LABEL(divider_base, VALUE=' ')
  RETURN, divider_base
END

;------------------------- SPLIT MESSAGE FUNCTION
FUNCTION CRISPEX_SPLIT_MSG, message1, max_text_width
  message_split = STRSPLIT(message1, ' ', /EXTRACT)
  message_split += ' '  ; Add whitespace after each substring
  k = 0L
  i = 0L 
  total_length_left = STRLEN(message1)+1
  WHILE (total_length_left GT 0) DO BEGIN
    length_left = max_text_width
    substr_reconstr = ''
    WHILE ((length_left GT 0) AND (total_length_left GT 0)) DO BEGIN
      substr_reconstr = substr_reconstr+message_split[i]
      length_left -= STRLEN(message_split[i])
      total_length_left -= STRLEN(message_split[i])
      i += 1L
    ENDWHILE
    IF (k EQ 0) THEN $
      final_msg = substr_reconstr $
    ELSE $
      final_msg = [final_msg,substr_reconstr]
    k += 1L
  ENDWHILE
  RETURN, final_msg
END

;========================= ABOUT WINDOW PROCEDURES
PRO CRISPEX_ABOUT_WINDOW, event 							
; Creates an about-window displaying code name, version and revision number
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	title = 'CRISPEX'+(*(*info).sesparams).instance_label+': ABOUT'
	CRISPEX_WINDOW, (*(*info).winsizes).aboutwinx, (*(*info).winsizes).aboutwiny, (*(*info).winids).root, title, abouttlb, aboutwid, (*(*info).winsizes).aboutxoffset, (*(*info).winsizes).aboutyoffset, $
		DRAWID = aboutdrawid, DRAWBASE = aboutdrawbase
	CRISPEX_UPDATE_STARTUP_FEEDBACK, (*(*info).feedbparams).startup_im, (*(*info).feedbparams).xout, (*(*info).feedbparams).yout, $
		['Running CRISPEX version '+(*(*info).versioninfo).version_number+' ('+(*(*info).versioninfo).revision_number+')','',$
		'Developed by: Gregal Vissers', $
		'               Institute of Theoretical Astrophysics,',$
		'               University of Oslo',$
		'               2009-2014','','Close']
	WIDGET_CONTROL, aboutdrawid, EVENT_PRO = 'CRISPEX_ABOUT_CURSOR', /SENSITIVE, /DRAW_MOTION_EVENTS, /TRACKING_EVENTS, /DRAW_BUTTON_EVENTS
	WIDGET_CONTROL, abouttlb, SET_UVALUE = info
	XMANAGER, 'CRISPEX', abouttlb,/NO_BLOCK
	(*(*info).winids).abouttlb = abouttlb
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).winids).abouttlb], labels=['abouttlb']
END

PRO CRISPEX_ABOUT_CURSOR, event
; Handles cursor actions on the about window
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF TAG_NAMES(event, /STRUCTURE_NAME) EQ 'WIDGET_DRAW' THEN BEGIN
		IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [event.TYPE,event.PRESS], labels=['WIDGET_DRAW: event.TYPE','WIDGET_DRAW: event.PRESS']
		CASE event.TYPE OF
		0:	CASE event.PRESS OF
			1:	BEGIN	; left mouse button press
					WIDGET_CONTROL, (*(*info).winids).abouttlb, /DESTROY
					(*(*info).winids).abouttlb = 0
				END
			ELSE: BREAK
			ENDCASE
		ELSE: RETURN
		ENDCASE
	ENDIF
END

;================================================================================= CLEAR ESTIMATE PROCEDURES
PRO CRISPEX_CLEAR_CURRENT_ESTIMATE, event								
; Clears current saving time estimate
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (*(*info).feedbparams).estimate_run THEN BEGIN
		(*(*info).feedbparams).estimate_lx = 0
		(*(*info).feedbparams).estimate_time = 0.
		(*(*info).feedbparams).estimate_run = 0
		WIDGET_CONTROL, (*(*info).ctrlscp).clear_current_estimate, SENSITIVE = 0
	ENDIF
END

PRO CRISPEX_CLEAR_CURRENT_CPFT, event								
; Clears current saving time estimate
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	pftfiles = FILE_SEARCH((*(*info).paths).dir_settings+'crispex.'+(*(*info).paths).hostname+'cpft', COUNT = pftfilecount)
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, ['crispex.'+(*(*info).paths).hostname+'cpft',pftfilecount], labels=['File to be deleted','Filecount']
	IF pftfilecount THEN BEGIN
    FILE_DELETE, (*(*info).paths).dir_settings+'crispex.'+(*(*info).paths).hostname+'cpft', /QUIET
		(*(*info).feedbparams).estimate_lx = 0
		(*(*info).feedbparams).estimate_time = 0.
		(*(*info).feedbparams).estimate_run = 0
		WIDGET_CONTROL, (*(*info).ctrlscp).clear_current_estimate, SENSITIVE = 0
	ENDIF ELSE BEGIN
		CRISPEX_WINDOW_OK, event,'ERROR!','Could not delete crispex.'+$
      ((*(*info).paths).hostname)[0]+'cpft '+$
      'from '+(*(*info).paths).dir_settings+'. File does not exist.',$
			OK_EVENT='CRISPEX_CLOSE_EVENT_WINDOW', BASE=tlb
		(*(*info).winids).errtlb = tlb
	ENDELSE
END

PRO CRISPEX_CLEAR_CURRENT_INST, event								
; Clears current saving time estimate
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	instfiles = FILE_SEARCH((*(*info).paths).dir_settings+'crispex.'+(*(*info).paths).hostname+'inst', COUNT = instfilecount)
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, ['crispex.'+(*(*info).paths).hostname+'inst',instfilecount], labels=['File to be deleted','Filecount']
	IF instfilecount THEN BEGIN
		FILE_DELETE, (*(*info).paths).dir_settings+'crispex.'+(*(*info).paths).hostname+'inst', /QUIET
		(*(*info).feedbparams).estimate_lx = 0
		(*(*info).feedbparams).estimate_time = 0.
		(*(*info).feedbparams).estimate_run = 0
		WIDGET_CONTROL, (*(*info).ctrlscp).clear_current_inst, SENSITIVE = 0
	ENDIF ELSE BEGIN
		CRISPEX_WINDOW_OK, event,'ERROR!','Could not delete crispex.'+((*(*info).paths).hostname)[0]+$
      'inst from '+(*(*info).paths).dir_settings+'. File does not exist.',$
			OK_EVENT='CRISPEX_CLOSE_EVENT_WINDOW', BASE=tlb
		(*(*info).winids).errtlb = tlb
	ENDELSE
END
;================================================================================= PROGRAM EXIT PROCEDURES
PRO CRISPEX_CLOSE, event								
; Called upon closing program, checks for existence of performance test file; if not present it is written
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF ((*(*info).paths).dir_settings_write EQ 1) THEN BEGIN
		pftfiles = FILE_SEARCH((*(*info).paths).dir_settings+'crispex.'+$
      (*(*info).paths).hostname+'cpft', COUNT = pftfilecount)
		IF (pftfilecount EQ 0) AND ((*(*info).feedbparams).estimate_run EQ 1) THEN BEGIN
			estimate_lx = (*(*info).feedbparams).estimate_lx
			estimate_time = (*(*info).feedbparams).estimate_time
			estimate_run = (*(*info).feedbparams).estimate_run
			SAVE, estimate_lx, estimate_time, estimate_run, FILENAME = (*(*info).paths).dir_settings+'crispex.'+(*(*info).paths).hostname+'cpft'
			PRINT,'Written: '+(*(*info).paths).dir_settings+'crispex.'+(*(*info).paths).hostname+'cpft'
		ENDIF
	ENDIF ELSE BEGIN
		PRINT, 'ERROR: Could not write performance file crispex.'+(*(*info).paths).hostname+'cpft '
		PRINT, '       to '+(*(*info).paths).dir_settings+'. Permission denied.'
	ENDELSE
  CRISPEX_CLOSE_FREE_LUN, (*(*info).data).lunim, (*(*info).data).lunsp, $
    (*(*info).data).lunrefim, (*(*info).data).lunrefsp, (*(*info).data).lunmask, $
    (*(*info).data).lunsji, /IMDISP, SPDISP=(*(*info).dataswitch).spfile, $
    REFIMDISP=((*(*info).dataswitch).reffile AND ((*(*info).data).lunrefim GT 0)),$
    REFSPDISP=((*(*info).dataswitch).refspfile AND ((*(*info).data).lunrefsp GT 0)),$
    MASKDISP=((*(*info).dataswitch).maskfile AND ((*(*info).data).lunmask GT 0)),$
	  SJIDISP=((*(*info).dataswitch).sjifile AND ((*(*info).data).lunsji GT 0))
	WIDGET_CONTROL, (*(*info).winids).root, /DESTROY
	PTR_FREE, info
END

PRO CRISPEX_CLOSE_CLEANUP, base								
; Clean-up upon closing program
	WIDGET_CONTROL, base, GET_UVALUE = info
  CRISPEX_CLOSE_FREE_LUN, (*(*info).data).lunim, (*(*info).data).lunsp, $
    (*(*info).data).lunrefim, (*(*info).data).lunrefsp, (*(*info).data).lunmask, $
    (*(*info).data).lunsji, /IMDISP, SPDISP=(*(*info).dataswitch).spfile, $
    REFIMDISP=((*(*info).dataswitch).reffile AND ((*(*info).data).lunrefim GT 0)),$
    REFSPDISP=((*(*info).dataswitch).refspfile AND ((*(*info).data).lunrefsp GT 0)),$
    MASKDISP=((*(*info).dataswitch).maskfile AND ((*(*info).data).lunmask GT 0)),$
	  SJIDISP=((*(*info).dataswitch).sjifile AND ((*(*info).data).lunsji GT 0))
	CRISPEX_CLOSE_CLEAN_INSTANCE_FILE, (*(*info).paths).dir_settings_write, $
  (*(*info).paths).dir_settings, (*(*info).paths).hostname, ((*(*info).sesparams).curr_instance_id)[0]
	PTR_FREE, info
END

PRO CRISPEX_CLOSE_FREE_LUN, lunim, lunsp, lunrefim, lunrefsp, lunmask, lunsji, $
  IMDISP=imdisp, SPDISP=spdisp, REFIMDISP=refimdisp, REFSPDISP=refspdisp, $
  MASKDISP=maskdisp, SJIDISP=sjidisp
  IF KEYWORD_SET(IMDISP) THEN FREE_LUN, lunim
  IF KEYWORD_SET(SPDISP) THEN FREE_LUN, lunsp
  IF KEYWORD_SET(REFIMDISP) THEN FREE_LUN, lunrefim
  IF KEYWORD_SET(REFSPDISP) THEN FREE_LUN, lunrefsp
  IF KEYWORD_SET(MASKDISP) THEN FREE_LUN, lunmask
  IF KEYWORD_SET(SJIDISP) THEN FREE_LUN, lunsji
END

PRO CRISPEX_CLOSE_CLEAN_INSTANCE_FILE, dir_inst_write, dir_inst, hostname, curr_instance_id
; Called upon closing program, checks for existence of performance test file; if not present it is written
	IF (dir_inst_write EQ 1) THEN BEGIN
		instfile = FILE_SEARCH(dir_inst+'crispex.'+hostname+'inst', COUNT = instfilecount)
		IF instfilecount THEN BEGIN
			nlines = (FILE_LINES(instfile))[0]
			datarr = STRARR(1,nlines)
			OPENR,unit1,instfile,/GET_LUN
			READF,unit1,datarr
			FREE_LUN,unit1
			routine_name = STRARR(nlines)
			instance_id = LONARR(nlines)
			FOR i=1,nlines-1 DO BEGIN
				splitline = STRSPLIT(datarr[i],'	',/EXTRACT)
				routine_name[i] = splitline[0]
				instance_id[i] = splitline[3]
			ENDFOR
			where_crispex = WHERE(routine_name EQ 'CRISPEX', count)
      IF (count GT 0) THEN BEGIN    ; Only clean if CRISPEX instance in file
  			sel_instance_id = instance_id[where_crispex]
  			clean_line = WHERE(sel_instance_id EQ curr_instance_id)+1
  			first_part = datarr[0:(clean_line-1)]
  			IF (clean_line NE (nlines-1)) THEN BEGIN
  				last_part = datarr[(clean_line+1):(nlines-1)] 
  				rewritten_arr = [first_part,last_part]
  			ENDIF ELSE rewritten_arr = first_part
  			OPENW, unit, instfile[0], WIDTH = 360, /GET_LUN
  			FOR i=0,nlines-2 DO PRINTF, unit,rewritten_arr[i]
      ENDIF
			FREE_LUN, unit
		ENDIF
	ENDIF
END

PRO CRISPEX_CLOSE_EVENT_WINDOW, event
; Called upon closing window when no extra processes need to be run
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (event.TOP EQ (*(*info).winids).savewintlb) THEN BEGIN
		(*(*info).winids).savewintlb = 0
		IF ((*(*info).winids).saveoptwintlb GT 0) THEN BEGIN
			WIDGET_CONTROL, (*(*info).winids).saveoptwintlb,/DESTROY
			(*(*info).winids).saveoptwintlb = 0
		ENDIF
	ENDIF
	IF (event.TOP EQ (*(*info).winids).saveoptwintlb) THEN (*(*info).winids).saveoptwintlb = 0
	IF (event.TOP EQ (*(*info).winids).abouttlb) THEN (*(*info).winids).abouttlb = 0
	IF (event.TOP EQ (*(*info).winids).errtlb) THEN (*(*info).winids).errtlb = 0
	IF (event.TOP EQ (*(*info).winids).warntlb) THEN (*(*info).winids).warntlb = 0
  IF (event.TOP EQ (*(*info).winids).shorttlb) THEN (*(*info).winids).shorttlb = 0
  IF (event.TOP EQ (*(*info).winids).headertlb) THEN (*(*info).winids).headertlb = 0
	WIDGET_CONTROL, event.TOP, /DESTROY
END

;==================== CURSOR PROCEDURES
PRO CRISPEX_CURSOR, event								
; Cursor handling procedure, tracks and handles events from the cursor on the 
; image windows
; Variable definitions: window draw variables are preceded by an 's', e.g., sx
; and sxr; these correspond to data variables x and xr respectively.
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event, /IGNORE_LAST
	IF TAG_NAMES(event, /STRUCTURE_NAME) EQ 'WIDGET_TRACKING' THEN BEGIN
		IF event.ENTER THEN BEGIN
			WIDGET_CONTROL, event.HANDLER, get_value = wid
			WSET, wid
			ci = UINTARR(16) & cim = ci & cim[7] = 1
			DEVICE, CURSOR_IMAGE = ci, CURSOR_MASK = cim, CURSOR_XY = [8,8]
		ENDIF ELSE BEGIN
      ; Upon exiting the draw window...
			IF (((*(*info).loopparams).np GE 1) AND $
           (*(*info).overlayswitch).looppath_feedback AND $
           ((*(*info).curs).lockset GT 0)) THEN $
           CRISPEX_LOOP_REMOVE_POINT, event, /CURSOR_ACTION
			IF (!D.WINDOW NE -1) THEN DEVICE, /CURSOR_CROSSHAIR 
		ENDELSE
  	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
      CRISPEX_VERBOSE_GET, event, $
        [event.ENTER], labels=['WIDGET_TRACKING: event.Enter']
	ENDIF ELSE IF TAG_NAMES(event, /STRUCTURE_NAME) EQ 'WIDGET_DRAW' THEN BEGIN
    ; Else while in draw window, handle actions (mouse move or (un)lock by mouse
    ; button actions) 
    ; Determine window the mouse is in
    (*(*info).winids).current_wid = event.ID
		CASE event.TYPE OF
		0:	CASE event.PRESS OF
			1:	BEGIN	; left mouse button press -> locks cursor to location
					(*(*info).curs).lockset = 1
					WIDGET_CONTROL, (*(*info).ctrlscp).unlock_button, SET_BUTTON=0
					WIDGET_CONTROL, (*(*info).ctrlscp).lock_button, /SET_BUTTON
          ; Convert device to actual data coordinates
          CRISPEX_CURSOR_GET_XY, event, event.X, event.Y
          ; Set lock variables for main
					(*(*info).curs).sxlock = (*(*info).curs).sx
					(*(*info).curs).sylock = (*(*info).curs).sy
					(*(*info).curs).xlock = (*(*info).dataparams).x
					(*(*info).curs).ylock = (*(*info).dataparams).y
          ; If reference present, set lock variables for reference
          IF ((*(*info).winids).reftlb NE 0) THEN BEGIN
            (*(*info).curs).xreflock = (*(*info).dataparams).xref
            (*(*info).curs).yreflock = (*(*info).dataparams).yref
            (*(*info).curs).sxreflock = (*(*info).curs).sxref
            (*(*info).curs).syreflock = (*(*info).curs).syref
          ENDIF
          IF ((*(*info).winids).sjitlb NE 0) THEN BEGIN
            (*(*info).curs).xsjilock = (*(*info).dataparams).xsji
            (*(*info).curs).ysjilock = (*(*info).dataparams).ysji
            (*(*info).curs).sxsjilock = (*(*info).curs).sxsji
            (*(*info).curs).sysjilock = (*(*info).curs).sysji
          ENDIF
          ; If drawing path, set parameters accordingly
					IF (*(*info).overlayswitch).loopslit THEN BEGIN
            ; Increase number of fixed path positions by 1
            (*(*info).loopparams).np += 1
            (*(*info).loopparams).np_ref += ((*(*info).winswitch).showref EQ 1)
            (*(*info).loopparams).np_sji += ((*(*info).winswitch).showsji EQ 1)
						IF (((*(*info).loopparams).np GE 2) OR $
                ((*(*info).loopparams).np_ref GE 2) OR $
                ((*(*info).loopparams).np_sji GE 2)) THEN BEGIN
              WIDGET_CONTROL, (*(*info).ctrlscp).loop_slit_but, $
                SET_VALUE = 'Erase path'
              ; If adjusting of main path has not been disabled and it is indeed
              ; a main path position that has been added, add variables
						  IF ((*(*info).loopparams).np GE 2) THEN BEGIN
  							*(*(*info).loopparams).xp = $
                  [*(*(*info).loopparams).xp,(*(*info).curs).xlock]
  							*(*(*info).loopparams).yp = $
                  [*(*(*info).loopparams).yp,(*(*info).curs).ylock]
              ENDIF
              ; If adjusting of reference path has not been disabled and it is
              ; indeed a reference path position that has been added, add
              ; variables 
              IF ((*(*info).winswitch).showref AND $
						      ((*(*info).loopparams).np_ref GE 2)) THEN BEGIN
  							*(*(*info).loopparams).xp_ref = $
                  [*(*(*info).loopparams).xp_ref,(*(*info).curs).xreflock]
  							*(*(*info).loopparams).yp_ref = $
                  [*(*(*info).loopparams).yp_ref,(*(*info).curs).yreflock]
              ENDIF
              IF ((*(*info).winswitch).showsji AND $
						      ((*(*info).loopparams).np_sji GE 2)) THEN BEGIN
  							*(*(*info).loopparams).xp_sji = $
                  [*(*(*info).loopparams).xp_sji,(*(*info).curs).xsjilock]
  							*(*(*info).loopparams).yp_sji = $
                  [*(*(*info).loopparams).yp_sji,(*(*info).curs).ysjilock]
              ENDIF
							CRISPEX_LOOP_GET, event, /ADD
							CRISPEX_UPDATE_LP, event, /NO_LOOP_GET
              WIDGET_CONTROL, (*(*info).ctrlscp).loop_slice_but, $
                SENSITIVE=((*(*info).winids).looptlb EQ 0)
              WIDGET_CONTROL, (*(*info).ctrlscp).rem_loop_pt_but, $
                SENSITIVE=(((*(*info).loopparams).np GE 3) OR $
                           ((*(*info).loopparams).np_ref GE 3))
						ENDIF ELSE BEGIN
              ; If cursor position not out of range, set first path coordinate
  						(*(*(*info).loopparams).xp)[0] = (*(*info).curs).xlock
  						(*(*(*info).loopparams).yp)[0] = (*(*info).curs).ylock
  						(*(*(*info).overlayparams).sxp)[0] = (*(*info).curs).sxlock
  						(*(*(*info).overlayparams).syp)[0] = (*(*info).curs).sylock
              IF (*(*info).winswitch).showref THEN BEGIN
  							(*(*(*info).loopparams).xp_ref)[0] = (*(*info).curs).xreflock
  							(*(*(*info).loopparams).yp_ref)[0] = (*(*info).curs).yreflock
  							(*(*(*info).overlayparams).sxp_ref)[0] = (*(*info).curs).sxreflock
  							(*(*(*info).overlayparams).syp_ref)[0] = (*(*info).curs).syreflock
              ENDIF
              IF (*(*info).winswitch).showsji THEN BEGIN
  							(*(*(*info).loopparams).xp_sji)[0] = (*(*info).curs).xsjilock
  							(*(*(*info).loopparams).yp_sji)[0] = (*(*info).curs).ysjilock
  							(*(*(*info).overlayparams).sxp_sji)[0] = (*(*info).curs).sxsjilock
  							(*(*(*info).overlayparams).syp_sji)[0] = (*(*info).curs).sysjilock
              ENDIF
						ENDELSE
					ENDIF
          ; If taking spatial measurement, set parameters accordingly
					IF (*(*info).meas).spatial_measurement THEN BEGIN
						(*(*info).meas).np = 1
						(*(*(*info).meas).xp) = (*(*info).curs).xlock
						(*(*(*info).meas).yp) = (*(*info).curs).ylock
						(*(*(*info).meas).sxp) = (*(*info).curs).sxlock
						(*(*(*info).meas).syp) = (*(*info).curs).sylock 
            IF (*(*info).winswitch).showref THEN BEGIN
  						(*(*(*info).meas).xp_ref) = (*(*info).curs).xreflock
  						(*(*(*info).meas).yp_ref) = (*(*info).curs).yreflock
  						(*(*(*info).meas).sxp_ref) = (*(*info).curs).sxreflock
  						(*(*(*info).meas).syp_ref) = (*(*info).curs).syreflock 
            ENDIF
            IF (*(*info).winswitch).showsji THEN BEGIN
  						(*(*(*info).meas).xp_sji) = (*(*info).curs).xsjilock
  						(*(*(*info).meas).yp_sji) = (*(*info).curs).ysjilock
  						(*(*(*info).meas).sxp_sji) = (*(*info).curs).sxsjilock
  						(*(*(*info).meas).syp_sji) = (*(*info).curs).sysjilock 
            ENDIF
					ENDIF
					CRISPEX_COORDSLIDERS_SET, 1, 1, event
				END
			2:	BEGIN	; middle mouse button press -> set second point of measurement
					IF ((*(*info).meas).spatial_measurement AND $
             ((*(*info).meas).np LT 2)) THEN BEGIN
            CRISPEX_CURSOR_GET_XY, event, event.X, event.Y
						(*(*info).meas).np = 2
						*(*(*info).meas).xp = $
              [(*(*(*info).meas).xp)[0],(*(*info).dataparams).x]	
						*(*(*info).meas).yp = $
              [(*(*(*info).meas).yp)[0],(*(*info).dataparams).y]	
						*(*(*info).meas).sxp = $
              [(*(*(*info).meas).sxp)[0],(*(*info).curs).sx]	
						*(*(*info).meas).syp = $
              [(*(*(*info).meas).syp)[0],(*(*info).curs).sy]
            IF (*(*info).winswitch).showref THEN BEGIN
  						*(*(*info).meas).xp_ref = $
                [(*(*(*info).meas).xp_ref)[0],(*(*info).dataparams).xref]	
  						*(*(*info).meas).yp_ref = $
                [(*(*(*info).meas).yp_ref)[0],(*(*info).dataparams).yref]	
  						*(*(*info).meas).sxp_ref = $
                [(*(*(*info).meas).sxp_ref)[0],(*(*info).curs).sxref]	
  						*(*(*info).meas).syp_ref = $
                [(*(*(*info).meas).syp_ref)[0],(*(*info).curs).syref]
            ENDIF
            IF (*(*info).winswitch).showsji THEN BEGIN
  						*(*(*info).meas).xp_sji = $
                [(*(*(*info).meas).xp_sji)[0],(*(*info).dataparams).xsji]	
  						*(*(*info).meas).yp_sji = $
                [(*(*(*info).meas).yp_sji)[0],(*(*info).dataparams).ysji]	
  						*(*(*info).meas).sxp_sji = $
                [(*(*(*info).meas).sxp_sji)[0],(*(*info).curs).sxsji]	
  						*(*(*info).meas).syp_sji = $
                [(*(*(*info).meas).syp_sji)[0],(*(*info).curs).sysji]
            ENDIF
						CRISPEX_COORDSLIDERS_SET, 1, 1, event
						CRISPEX_MEASURE_CALC, event
					ENDIF
				END
			4:	BEGIN	; right mouse button press -> release locked cursor
          IF ((*(*info).overlayswitch).loopslit EQ 0) THEN BEGIN
  					(*(*info).curs).lockset = 0
            CRISPEX_MEASURE_ENABLE, event, /DISABLE
          ENDIF
				END
			ELSE: BREAK
			ENDCASE
		2:	BEGIN	; mouse movement
        ; If cursor isn't locked, adjust coordinate sliders
				IF ((*(*info).curs).lockset EQ 0) THEN BEGIN
          CRISPEX_CURSOR_GET_XY, event, event.X, event.Y
					CRISPEX_COORDSLIDERS_SET, 1, 1, event 
        ; Else if drawing path, adjust path feedback if path has been started in
        ; either main window (np>=1) or reference window (np_ref>=1)
				ENDIF ELSE IF ((*(*info).overlayswitch).loopslit AND $
                       (*(*info).overlayswitch).looppath_feedback AND $
                       (((*(*info).loopparams).np GE 1) OR $
                        ((*(*info).loopparams).np_ref GE 1) OR $
                        ((*(*info).loopparams).np_sji GE 1))) THEN BEGIN
          CRISPEX_CURSOR_GET_XY, event, event.X, event.Y
          ; Get new paths with current cursor coordinate
          IF ((*(*info).loopparams).np GE 1) THEN BEGIN
	        	*(*(*info).loopparams).xpdisp = $
              [(*(*(*info).loopparams).xp)[0:(*(*info).loopparams).np-1],$
                                          (*(*info).dataparams).x]
	        	*(*(*info).loopparams).ypdisp = $
              [(*(*(*info).loopparams).yp)[0:(*(*info).loopparams).np-1],$
                                          (*(*info).dataparams).y]
          ENDIF
          ; If np_ref>=1, add current coordinate to xyp_ref and compute path
          IF ((*(*info).winswitch).showref AND $
            (*(*info).loopparams).np_ref GE 1) THEN BEGIN
	        	*(*(*info).loopparams).xpdisp_ref = $
              [(*(*(*info).loopparams).xp_ref)[0:(*(*info).loopparams).np_ref-1],$
                                          (*(*info).dataparams).xref]
	        	*(*(*info).loopparams).ypdisp_ref = $
              [(*(*(*info).loopparams).yp_ref)[0:(*(*info).loopparams).np_ref-1],$
                                          (*(*info).dataparams).yref]
          ENDIF
          IF ((*(*info).winswitch).showsji AND $
            (*(*info).loopparams).np_sji GE 1) THEN BEGIN
	        	*(*(*info).loopparams).xpdisp_sji = $
              [(*(*(*info).loopparams).xp_sji)[0:(*(*info).loopparams).np_sji-1],$
                                          (*(*info).dataparams).xsji]
	        	*(*(*info).loopparams).ypdisp_sji = $
              [(*(*(*info).loopparams).yp_sji)[0:(*(*info).loopparams).np_sji-1],$
                                          (*(*info).dataparams).ysji]
          ENDIF
          CRISPEX_LOOP_GET_PATH, event
					CRISPEX_COORDSLIDERS_SET, 1, 1, event
        ; Else if drawing measurement, adjust measurement feedback
				ENDIF ELSE IF ((*(*info).meas).spatial_measurement AND $
                      ((*(*info).meas).np EQ 1)) THEN BEGIN
          CRISPEX_CURSOR_GET_XY, event, event.X, event.Y
					*(*(*info).meas).xp = [(*(*(*info).meas).xp)[0],$
            (*(*info).dataparams).x]	
					*(*(*info).meas).yp = [(*(*(*info).meas).yp)[0],$
            (*(*info).dataparams).y]	
					*(*(*info).meas).sxp = [(*(*(*info).meas).sxp)[0],(*(*info).curs).sx]	
					*(*(*info).meas).syp = [(*(*(*info).meas).syp)[0],(*(*info).curs).sy]
          IF (*(*info).winswitch).showref THEN BEGIN
						*(*(*info).meas).xp_ref = $
              [(*(*(*info).meas).xp_ref)[0],(*(*info).dataparams).xref]	
						*(*(*info).meas).yp_ref = $
              [(*(*(*info).meas).yp_ref)[0],(*(*info).dataparams).yref]	
						*(*(*info).meas).sxp_ref = $
              [(*(*(*info).meas).sxp_ref)[0],(*(*info).curs).sxref]	
						*(*(*info).meas).syp_ref = $
              [(*(*(*info).meas).syp_ref)[0],(*(*info).curs).syref]
          ENDIF
          IF (*(*info).winswitch).showsji THEN BEGIN
						*(*(*info).meas).xp_sji = $
              [(*(*(*info).meas).xp_sji)[0],(*(*info).dataparams).xsji]	
						*(*(*info).meas).yp_sji = $
              [(*(*(*info).meas).yp_sji)[0],(*(*info).dataparams).ysji]	
						*(*(*info).meas).sxp_sji = $
              [(*(*(*info).meas).sxp_sji)[0],(*(*info).curs).sxsji]	
						*(*(*info).meas).syp_sji = $
              [(*(*(*info).meas).syp_sji)[0],(*(*info).curs).sysji]
          ENDIF
;          print,*(*(*info).meas).sxp,(*(*info).curs).sx, (*(*info).dataparams).x
;          print,*(*(*info).meas).syp,(*(*info).curs).sy, (*(*info).dataparams).y
					CRISPEX_MEASURE_CALC, event
					CRISPEX_COORDSLIDERS_SET, 1, 1, event
				ENDIF ELSE RETURN
			END
		ELSE: RETURN
		ENDCASE
    ; Update user feedback
		IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
      CRISPEX_VERBOSE_GET, event, [event.TYPE,event.PRESS,$
        (*(*info).dataparams).x,(*(*info).dataparams).y,(*(*info).curs).sx,$
        (*(*info).curs).sy], $
        labels=['WIDGET_DRAW: event.TYPE','WIDGET_DRAW: event.PRESS','x','y',$
        'sx','sy']
    ; Update display data and Redraw windows as necessary 
    IF (*(*info).winswitch).showls THEN CRISPEX_UPDATE_SSP, event
    IF (*(*info).winswitch).showsp THEN CRISPEX_UPDATE_SPSLICE, event
    IF (*(*info).winswitch).showrefls THEN CRISPEX_UPDATE_REFSSP, event
    IF (*(*info).winswitch).showrefsp THEN CRISPEX_UPDATE_REFSPSLICE, event
		IF (*(*info).winswitch).showphis THEN BEGIN
			CRISPEX_PHISLIT_DIRECTION, event
      CRISPEX_UPDATE_PHISLIT_COORDS, event
			CRISPEX_UPDATE_PHISLICE, event
		ENDIF ELSE CRISPEX_DRAW, event
	ENDIF
END

PRO CRISPEX_CURSOR_GET_XY, event, x_tmp, y_tmp
; Converts the window x and y coordinates to data x and y coordinates
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  ; Get temporary data coordinates from temporary device coordinates
  xy_tmp = CRISPEX_TRANSFORM_DATA2DEVICE(info, X=x_tmp, Y=y_tmp, $
    MAIN=(((*(*info).winids).current_wid EQ (*(*info).winids).xydrawid) OR $
          ((*(*info).winids).current_wid EQ (*(*info).winids).imrefdrawid) OR $
          ((*(*info).winids).current_wid EQ (*(*info).winids).dopdrawid)), $
    REFERENCE=((*(*info).winids).current_wid EQ (*(*info).winids).refdrawid), $
    /INVERSE)
  ; Check whether current window ID is reference or main
  ; Take LONG() of temporary results to get the actual indices
  IF ((*(*info).winids).current_wid EQ (*(*info).winids).xydrawid) THEN BEGIN
  	(*(*info).dataparams).x = LONG(xy_tmp.x)
  	(*(*info).dataparams).y = LONG(xy_tmp.y)
  ENDIF ELSE BEGIN
  	(*(*info).dataparams).xref = LONG(xy_tmp.x)
  	(*(*info).dataparams).yref = LONG(xy_tmp.y) 
  ENDELSE
  ; Convert x,y to values for other windows
  CRISPEX_COORDS_TRANSFORM_XY, event, $
    MAIN2SJI=(((*(*info).dataswitch).sjifile NE 0) AND $
              ((*(*info).winids).current_wid EQ (*(*info).winids).xydrawid)), $
    MAIN2REF=(((*(*info).dataswitch).reffile NE 0) AND $
              ((*(*info).winids).current_wid EQ (*(*info).winids).xydrawid)), $
    REF2MAIN=((*(*info).winids).current_wid EQ (*(*info).winids).refdrawid), $
    REF2SJI=(((*(*info).dataswitch).sjifile NE 0) AND $
              ((*(*info).winids).current_wid EQ (*(*info).winids).refdrawid))
  ; Get device coordinates for display
  sxy = CRISPEX_TRANSFORM_DATA2DEVICE(info, $
    X=(*(*info).dataparams).x, Y=(*(*info).dataparams).y, /MAIN)
  (*(*info).curs).sx = sxy.x
  (*(*info).curs).sy = sxy.y
  IF (*(*info).dataswitch).reffile THEN BEGIN
    sxyref = CRISPEX_TRANSFORM_DATA2DEVICE(info, $
      X=(*(*info).dataparams).xref, Y=(*(*info).dataparams).yref, /REFERENCE)
    (*(*info).curs).sxref = sxyref.x
    (*(*info).curs).syref = sxyref.y
  ENDIF
  IF (*(*info).dataswitch).sjifile THEN BEGIN
    sxysji = CRISPEX_TRANSFORM_DATA2DEVICE(info, $
      X=(*(*info).dataparams).xsji, Y=(*(*info).dataparams).ysji, /SJI)
    (*(*info).curs).sxsji = sxysji.x
    (*(*info).curs).sysji = sxysji.y 
  ENDIF
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, $
      [(*(*info).dataparams).x,(*(*info).dataparams).y], labels=['x','y']
END

PRO CRISPEX_CURSOR_LOCK, event								
; Called upon locking/unlocking cursor with 'lock cursor' or 'unlock cursor' 
; button, handles cursor (un)locking
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).curs).lockset = event.SELECT
	IF (*(*info).curs).lockset THEN BEGIN
		(*(*info).curs).xlock = (*(*info).dataparams).x	
    (*(*info).curs).ylock = (*(*info).dataparams).y
		(*(*info).curs).sxlock = (*(*info).curs).sx	   
    (*(*info).curs).sylock = (*(*info).curs).sy
    IF ((*(*info).winids).reftlb NE 0) THEN BEGIN
      (*(*info).curs).xreflock = (*(*info).dataparams).xref
      (*(*info).curs).yreflock = (*(*info).dataparams).yref
      (*(*info).curs).sxreflock = (*(*info).curs).sxref
      (*(*info).curs).syreflock = (*(*info).curs).syref
    ENDIF
		IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
			CRISPEX_VERBOSE_GET, event, [(*(*info).curs).xlock,(*(*info).curs).ylock,$
        (*(*info).curs).sxlock,(*(*info).curs).sylock], $
        labels=['xlock','ylock','sxlock','sylock']
	ENDIF 
  CRISPEX_COORDSLIDERS_SET, 1, 1, event
END

PRO CRISPEX_COORDSLIDERS_SET, xsensitive, ysensitive, event
; Adjusts sliders according to change in cursor position or locked/unlocked state
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, (*(*info).ctrlscp).x_slider, $
    SET_VALUE=(*(*info).dataparams).x, SENSITIVE=(xsensitive AND $
    ((*(*info).dispparams).x_first NE (*(*info).dispparams).x_last) AND $
    ((*(*info).dispswitch).xy_out_of_range EQ 0))
	WIDGET_CONTROL, (*(*info).ctrlscp).y_slider, $
    SET_VALUE=(*(*info).dataparams).y, SENSITIVE=(ysensitive AND $
    ((*(*info).dispparams).y_first NE (*(*info).dispparams).y_last) AND $
    ((*(*info).dispswitch).xy_out_of_range EQ 0))
  IF (*(*info).dataswitch).reffile THEN BEGIN 
  	WIDGET_CONTROL, (*(*info).ctrlscp).xref_slider, $
      SET_VALUE=(*(*info).dataparams).xref, SENSITIVE=(xsensitive AND $
      ((*(*info).dispparams).xref_first NE (*(*info).dispparams).xref_last) AND $
      ((*(*info).dispswitch).main2ref_no_map EQ 0) AND $
      ((*(*info).dispswitch).xyref_out_of_range EQ 0))
  	WIDGET_CONTROL, (*(*info).ctrlscp).yref_slider, $
      SET_VALUE=(*(*info).dataparams).yref, SENSITIVE=(ysensitive AND $
      ((*(*info).dispparams).yref_first NE (*(*info).dispparams).yref_last) AND $
      ((*(*info).dispswitch).main2ref_no_map EQ 0) AND $
      ((*(*info).dispswitch).xyref_out_of_range EQ 0))
  ENDIF
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, $
      [(*(*info).dataparams).x,(*(*info).dataparams).y,xsensitive,ysensitive], $
      labels=['x','y','xsensitive','ysensitive']
END

;========================= COORDINATE TRANSFORMATIONS
PRO CRISPEX_COORDS_TRANSFORM_XY, event, MAIN2SJI=main2sji, MAIN2REF=main2ref, $
  REF2MAIN=ref2main, REF2SJI=ref2sji
; Handles transformation of x/y-coordinates in case of unequal spatial 
; dimensions
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  ; Convert main to reference coordinates
  IF KEYWORD_SET(MAIN2REF) THEN BEGIN
    ; If not mapping, simply set reference to main coordinates
    IF (*(*info).dispswitch).main2ref_no_map THEN BEGIN
      (*(*info).dataparams).xref = (*(*info).dataparams).x
      (*(*info).dataparams).yref = (*(*info).dataparams).y
    ENDIF ELSE BEGIN
      ; If mapping, subscript mapping array with main coordinates
      xyref = (*(*info).dataparams).pix_main2ref[*, $
          (*(*info).dataparams).x, (*(*info).dataparams).y]
      (*(*info).dataparams).xref = xyref[0]
      (*(*info).dataparams).yref = xyref[1]
    ENDELSE
  ENDIF 
  ; Convert reference to main coordinates
  IF KEYWORD_SET(REF2MAIN) THEN BEGIN
    ; If not mapping, simply set reference to reference coordinates
    IF (*(*info).dispswitch).main2ref_no_map THEN BEGIN
      (*(*info).dataparams).x = (*(*info).dataparams).xref
      (*(*info).dataparams).y = (*(*info).dataparams).yref
    ENDIF ELSE BEGIN
      ; If mapping, subscript mapping array with reference coordinates
      xy = (*(*info).dataparams).pix_ref2main[*, $
          (*(*info).dataparams).xref, (*(*info).dataparams).yref]
      (*(*info).dataparams).x = xy[0]
      (*(*info).dataparams).y = xy[1]
    ENDELSE
  ENDIF
  ; Check whether main coordinates are out of range
  (*(*info).dispswitch).xy_out_of_range = $
    (((*(*info).dataparams).x LT 0) OR ((*(*info).dataparams).y LT 0) OR $
     ((*(*info).dataparams).x GE (*(*info).dataparams).nx) OR $
     ((*(*info).dataparams).y GE (*(*info).dataparams).ny))
  ; Check whether reference coordinates are out of range
  IF (*(*info).dataswitch).reffile THEN BEGIN
    (*(*info).dispswitch).xyref_out_of_range = $
      (((*(*info).dataparams).xref LT 0) OR ((*(*info).dataparams).yref LT 0) OR $
       ((*(*info).dataparams).xref GE (*(*info).dataparams).refnx) OR $
       ((*(*info).dataparams).yref GE (*(*info).dataparams).refny))
  ENDIF
  IF (KEYWORD_SET(MAIN2SJI) OR KEYWORD_SET(REF2SJI)) THEN BEGIN
    IF (KEYWORD_SET(MAIN2SJI) AND $
      ((*(*info).dispswitch).xy_out_of_range EQ 0)) THEN $
      xysji = (*(*info).dataparams).pix_main2sji[*,$
        (*(*info).dataparams).x, (*(*info).dataparams).y]
    IF (KEYWORD_SET(REF2SJI) AND $
      ((*(*info).dispswitch).xyref_out_of_range EQ 0)) THEN $
      xysji = (*(*info).dataparams).pix_ref2sji[*,$
        (*(*info).dataparams).xref, (*(*info).dataparams).yref]
    (*(*info).dataparams).xsji = xysji[0]
    (*(*info).dataparams).ysji = xysji[1]
  ENDIF 
  ; Check whether SJI coordinates are out of range
  IF (*(*info).dataswitch).sjifile THEN $
    (*(*info).dispswitch).xysji_out_of_range = $
      (((*(*info).dataparams).xsji LT 0) OR ((*(*info).dataparams).ysji LT 0) OR $
       ((*(*info).dataparams).xsji GE (*(*info).dataparams).sjinx) OR $
       ((*(*info).dataparams).ysji GE (*(*info).dataparams).sjiny))
END

PRO CRISPEX_COORDS_TRANSFORM_T, event, T_OLD=t_old, NT_OLD=nt_old
; Handles transformation of t-coordinates in case of unequal temporal dimensions
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
    ; Select temporal array for main and reference depending on dimensions and offset
    ; Either: - array with raster times for every time step
    ;         - array with raster times for a single scan (but only if NOT dealing with a
    ;           sit-and-stare; determined from nx=1)
    nrasterdims_main = SIZE((*(*info).dataparams).tarr_raster_main,/N_DIMENSIONS) 
    nrasterdims_ref = SIZE((*(*info).dataparams).tarr_raster_ref,/N_DIMENSIONS) 
    IF ( (nrasterdims_main EQ 2) OR ((nrasterdims_main EQ 1) AND $
      ((*(*info).dataparams).mainnt EQ 1) AND ((*(*info).dataparams).nx NE 1))) THEN $
      tarr_main = REFORM((*(*info).dataparams).tarr_raster_main[$
        (*(*info).dispparams).toffset_main,*]) $
    ELSE $
      tarr_main = (*(*info).dataparams).tarr_raster_main
    IF ( (nrasterdims_ref EQ 2) OR ((nrasterdims_ref EQ 1) AND $
      ((*(*info).dataparams).refnt EQ 1) AND ((*(*info).dataparams).nx NE 1))) THEN $
      tarr_ref = REFORM((*(*info).dataparams).tarr_raster_ref[$
        (*(*info).dispparams).toffset_ref,*]) $
    ELSE $
      tarr_ref = (*(*info).dataparams).tarr_raster_ref
    ; Set master array and temporal dimension depending on chosen master
    CASE (*(*info).dispparams).master_time OF
      0:  BEGIN ; Select main data as timing master
            tarr_master = tarr_main
            (*(*info).dataparams).nt = (*(*info).dataparams).mainnt
            offset_value = (*(*info).dispparams).toffset_main
            nrasterdims_master = nrasterdims_main
          END
      1:  BEGIN ; Select reference data as timing master
            tarr_master = tarr_ref
            (*(*info).dataparams).nt = (*(*info).dataparams).refnt
            offset_value = (*(*info).dispparams).toffset_ref
            nrasterdims_master = nrasterdims_ref
          END
      2:  BEGIN ; Select slit-jaw image data as timing master
            tarr_master = (*(*info).dataparams).tarr_sji
            (*(*info).dataparams).nt = (*(*info).dataparams).sjint
            offset_value = 0
            nrasterdims_master = 1
          END
    ENDCASE
    ; Adjust time offset slider according to choices
    ; Become sensitive if timing master is a raster, so either:
    ; - single scan (nx>1 AND nt=1, tarr_raster dims = 1)
    ; - raster with time evolution (nx>1 AND nt>1, tarr_raster dims = 2)
    WIDGET_CONTROL, (*(*info).ctrlscp).time_offset_slider, $
      SENSITIVE=(((nrasterdims_master EQ 1) AND ((*(*info).dataparams).nt EQ 1) AND $
        ((*(*info).dataparams).nx GT 1)) OR (nrasterdims_master EQ 2)), $
      SET_VALUE=offset_value
    IF ((((*(*info).dataparams).nt EQ 1) AND (nt_old GT 1)) OR $
        (((*(*info).dataparams).nt GT 1) AND (nt_old EQ 1))) THEN $
      CRISPEX_PB_BUTTONS_SET, event, /PAUSE_SET, /LOOP_SET, $
        SENSITIVE_SET=(((*(*info).dataparams).nt GT 1) AND (nt_old EQ 1))
    ; Initialise variables
    IF ((*(*info).dataparams).mainnt GT 1) THEN tsel_main = LONARR((*(*info).dataparams).nt)
    IF ((*(*info).dataparams).refnt GT 1) THEN tsel_ref = LONARR((*(*info).dataparams).nt)
    IF ((*(*info).dataparams).sjint GT 1) THEN tsel_sji = LONARR((*(*info).dataparams).nt)
    ; Determine frame closest in time to master array
    FOR tt=0,(*(*info).dataparams).nt-1 DO BEGIN
      IF ((*(*info).dataparams).mainnt GT 1) THEN BEGIN
        tdiff_main = ABS(tarr_main - tarr_master[tt])
        tsel_main[tt] = (WHERE(tdiff_main EQ MIN(tdiff_main, /NAN)))[0]
      ENDIF
      IF ((*(*info).dataparams).refnt GT 1) THEN BEGIN 
        tdiff_ref = ABS(tarr_ref - tarr_master[tt])
        tsel_ref[tt] = (WHERE(tdiff_ref EQ MIN(tdiff_ref, /NAN)))[0]
      ENDIF
      IF ((*(*info).dataparams).sjint GT 1) THEN BEGIN 
        tdiff_sji = ABS((*(*info).dataparams).tarr_sji - tarr_master[tt])
        tsel_sji[tt] = (WHERE(tdiff_sji EQ MIN(tdiff_sji, /NAN)))[0]
      ENDIF
    ENDFOR
    ; Populate variables with results
    IF ((*(*info).dataparams).mainnt GT 1) THEN BEGIN
      *(*(*info).dispparams).tsel_main = tsel_main
      *(*(*info).dispparams).tarr_main = tarr_main[tsel_main]
      IF (SIZE((*(*info).dataparams).utc_raster_main, /N_DIMENSIONS) EQ 2) THEN $
        *(*(*info).dispparams).utc_main = (*(*info).dataparams).utc_raster_main[$
          (*(*info).dispparams).toffset_main, tsel_main] $
      ELSE $
        *(*(*info).dispparams).utc_main = $
          (*(*info).dataparams).utc_raster_main[tsel_main]
    ENDIF
    IF ((*(*info).dataparams).refnt GT 1) THEN BEGIN 
      *(*(*info).dispparams).tsel_ref = tsel_ref
      *(*(*info).dispparams).tarr_ref = tarr_ref[tsel_ref]
      IF (SIZE((*(*info).dataparams).utc_raster_ref, /N_DIMENSIONS) EQ 2) THEN $
        *(*(*info).dispparams).utc_ref = (*(*info).dataparams).utc_raster_ref[$
          (*(*info).dispparams).toffset_ref,tsel_ref] $
      ELSE $
        *(*(*info).dispparams).utc_ref = $
          (*(*info).dataparams).utc_raster_ref[tsel_ref]
    ENDIF
    IF ((*(*info).dataparams).sjint GT 1) THEN BEGIN 
      *(*(*info).dispparams).tsel_sji = tsel_sji
      *(*(*info).dispparams).tarr_sji = (*(*info).dataparams).tarr_sji[tsel_sji]
      *(*(*info).dispparams).utc_sji = $
        (*(*info).dataparams).utc_sji[tsel_sji]
    ENDIF
    ; Reset temporal boundaries and get T_SET
    (*(*info).dispparams).t_last = (*(*info).dataparams).nt-1
    IF (((*(*info).dataparams).nt NE 1) AND (N_ELEMENTS(T_OLD) EQ 1)) THEN BEGIN
      tdiff = ABS(tarr_master - t_old)
      t_set = (WHERE(tdiff EQ MIN(tdiff, /NAN)))[0]
    ENDIF ELSE t_set = 0
    CRISPEX_DISPRANGE_T_RESET, event, /NO_DRAW, T_SET=t_set
END

;==================== DISPLAYS PROCEDURES
PRO CRISPEX_DISPLAYS_ALL_TO_FRONT, event
; Brings all opened session windows to front
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info	
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event, /IGNORE_LAST
	; Data windows
	IF ((*(*info).winids).sjitlb NE 0) THEN WSHOW, (*(*info).winids).sjiwid
	IF ((*(*info).winids).sptlb NE 0) THEN WSHOW, (*(*info).winids).spwid
	IF ((*(*info).winids).lstlb NE 0) THEN WSHOW, (*(*info).winids).lswid
	IF ((*(*info).winids).phistlb NE 0) THEN WSHOW, (*(*info).winids).phiswid
	IF ((*(*info).winids).reftlb NE 0) THEN WSHOW, (*(*info).winids).refwid
	IF ((*(*info).winids).doptlb NE 0) THEN WSHOW, (*(*info).winids).dopwid
	IF ((*(*info).winids).imreftlb NE 0) THEN WSHOW, (*(*info).winids).imrefwid
	IF (TOTAL(*(*(*info).winids).restlooptlb) NE 0) THEN $
    FOR i=0,N_ELEMENTS(*(*(*info).winids).restlooptlb)-1 DO WSHOW, (*(*(*info).winids).restloopwid)[i]
	IF ((*(*info).winids).retrdettlb NE 0) THEN WSHOW, (*(*info).winids).retrdetwid
	IF ((*(*info).winids).looptlb NE 0) THEN WSHOW, (*(*info).winids).loopwid
	IF ((*(*info).winids).refsptlb NE 0) THEN WSHOW, (*(*info).winids).refspwid
	IF ((*(*info).winids).reflstlb NE 0) THEN WSHOW, (*(*info).winids).reflswid
	IF ((*(*info).winids).inttlb NE 0) THEN WSHOW, (*(*info).winids).intwid
	; Action windows
	IF ((*(*info).winids).savetlb NE 0) THEN WIDGET_CONTROL, (*(*info).winids).savetlb, /SHOW
	IF ((*(*info).winids).detsavetlb NE 0) THEN WIDGET_CONTROL, (*(*info).winids).detsavetlb, /SHOW
	IF ((*(*info).winids).restoretlb NE 0) THEN WIDGET_CONTROL, (*(*info).winids).restoretlb, /SHOW
	IF ((*(*info).winids).savewintlb NE 0) THEN WIDGET_CONTROL, (*(*info).winids).savewintlb, /SHOW
	IF ((*(*info).winids).saveoptwintlb NE 0) THEN WIDGET_CONTROL, (*(*info).winids).saveoptwintlb, /SHOW
	IF ((*(*info).winids).intmenutlb NE 0) THEN WIDGET_CONTROL, (*(*info).winids).intmenutlb, /SHOW
	IF ((*(*info).winids).preftlb NE 0) THEN WIDGET_CONTROL, (*(*info).winids).preftlb, /SHOW
	; Warning and feedback windows
	IF ((*(*info).winids).paramtlb NE 0) THEN WIDGET_CONTROL, (*(*info).winids).paramtlb, /SHOW
	IF ((*(*info).winids).estimatetlb NE 0) THEN WIDGET_CONTROL, (*(*info).winids).estimatetlb, /SHOW
	IF ((*(*info).winids).feedbacktlb NE 0) THEN WIDGET_CONTROL, (*(*info).winids).feedbacktlb, /SHOW
	IF ((*(*info).winids).restsesfeedbtlb NE 0) THEN WIDGET_CONTROL, (*(*info).winids).restsesfeedbtlb, /SHOW
	IF ((*(*info).winids).abouttlb NE 0) THEN WIDGET_CONTROL, (*(*info).winids).abouttlb, /SHOW
	IF ((*(*info).winids).errtlb NE 0) THEN WIDGET_CONTROL, (*(*info).winids).errtlb, /SHOW
  ; Control panel
  WIDGET_CONTROL, (*(*info).winids).root, /SHOW
END

PRO CRISPEX_DISPWIDS, event
; Brings all opened session windows to front
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info	
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).winswitch).dispwids = ABS((*(*info).winswitch).dispwids-1)
	WIDGET_CONTROL,(*(*info).ctrlscp).dispwid, SET_BUTTON = (*(*info).winswitch).dispwids
	tlbarr = [(*(*info).winids).root,(*(*info).winids).sptlb,$
    (*(*info).winids).lstlb,(*(*info).winids).reftlb,$
    (*(*info).winids).refsptlb,(*(*info).winids).reflstlb,$
    (*(*info).winids).imreftlb,(*(*info).winids).doptlb, $
    (*(*info).winids).sjitlb, $
		(*(*info).winids).phistlb,*(*(*info).winids).restlooptlb,$
    (*(*info).winids).retrdettlb,(*(*info).winids).looptlb,$
    (*(*info).winids).reflooptlb,(*(*info).winids).inttlb]
	widarr = [(*(*info).winids).imwid,(*(*info).winids).spwid,$
    (*(*info).winids).lswid,(*(*info).winids).refwid,$
    (*(*info).winids).refspwid,(*(*info).winids).reflswid,$
    (*(*info).winids).imrefwid,(*(*info).winids).dopwid, $
    (*(*info).winids).sjiwid, $
		(*(*info).winids).phiswid,*(*(*info).winids).restloopwid,$
    (*(*info).winids).retrdetwid,(*(*info).winids).loopwid,$
    (*(*info).winids).refloopwid,(*(*info).winids).intwid]
	title_arr = [(*(*info).winids).imwintitle,(*(*info).winids).spwintitle,$
    (*(*info).winids).lswintitle,(*(*info).winids).refwintitle,$
    (*(*info).winids).refspwintitle,(*(*info).winids).reflswintitle,$
		(*(*info).winids).imrefwintitle,(*(*info).winids).dopwintitle, $
    (*(*info).winids).sjiwintitle, $
    (*(*info).winids).phiswintitle,*(*(*info).winids).restloopwintitle,$
    (*(*info).winids).retrdetwintitle,(*(*info).winids).loopwintitle,$
		(*(*info).winids).refloopwintitle,(*(*info).winids).intwintitle]
	wherenot0 = WHERE(tlbarr NE 0, count)
	IF ((*(*info).winswitch).dispwids AND (count GT 0)) THEN BEGIN
		FOR i=0,count-1 DO $
      WIDGET_CONTROL,tlbarr[wherenot0[i]], $
        BASE_SET_TITLE = STRTRIM(widarr[wherenot0[i]],2)+' - '+title_arr[wherenot0[i]]
	ENDIF ELSE BEGIN
		FOR i=0,count-1 DO $
      WIDGET_CONTROL,tlbarr[wherenot0[i]], BASE_SET_TITLE = title_arr[wherenot0[i]]
	ENDELSE
END

PRO CRISPEX_DISPLAYS_DETSPECT_IM_SELECT, event
; Handles the selection of detspect options for the main image
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).ctrlsswitch).imrefdetspect = 0
	CRISPEX_DISPLAYS_DETSPECT_SET_BUTTONS, event
END

PRO CRISPEX_DISPLAYS_DETSPECT_REF_SELECT, event
; Handles the selection of detspect options for the reference image
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).ctrlsswitch).imrefdetspect = 1
	CRISPEX_DISPLAYS_DETSPECT_SET_BUTTONS, event
END

PRO CRISPEX_DISPLAYS_DETSPECT_SET_BUTTONS, event
; Handles the setting of scaling buttons
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (*(*info).ctrlsswitch).imrefdetspect THEN BEGIN		; If selected options for reference
		WIDGET_CONTROL, (*(*info).ctrlscp).ls_toggle_but, SET_BUTTON = (*(*info).winswitch).showrefls, SET_VALUE = 'Display '+STRLOWCASE(((*(*info).plottitles).lswintitle)[(*(*info).plotswitch).refheightset])
		WIDGET_CONTROL, (*(*info).ctrlscp).subtract_but, SET_BUTTON = (*(*info).plotswitch).ref_subtract
		WIDGET_CONTROL, (*(*info).ctrlscp).scale_detspect_but, SET_BUTTON = (*(*info).dispswitch).ref_detspect_scale, $
			SET_VALUE = 'Scale '+STRLOWCASE(((*(*info).plottitles).lswintitle)[(*(*info).plotswitch).refheightset])+' to maximum of average'
		WIDGET_CONTROL, (*(*info).ctrlscp).lower_y_text, SET_VALUE = STRTRIM((*(*info).plotaxes).ls_low_y_ref,2)
		WIDGET_CONTROL, (*(*info).ctrlscp).upper_y_text, SET_VALUE = STRTRIM((*(*info).plotaxes).ls_upp_y_ref,2)
		WIDGET_CONTROL, (*(*info).ctrlscp).detspect_label, SET_VALUE = ((*(*info).plottitles).lswintitle)[(*(*info).plotswitch).refheightset]+':'
	ENDIF ELSE BEGIN				; If selected options for main
		WIDGET_CONTROL, (*(*info).ctrlscp).ls_toggle_but, SET_BUTTON = (*(*info).winswitch).showls, SET_VALUE = 'Display '+STRLOWCASE(((*(*info).plottitles).lswintitle)[(*(*info).plotswitch).heightset])
		WIDGET_CONTROL, (*(*info).ctrlscp).subtract_but, SET_BUTTON = (*(*info).plotswitch).subtract
		WIDGET_CONTROL, (*(*info).ctrlscp).scale_detspect_but, SET_BUTTON = (*(*info).dispswitch).detspect_scale, $
			SET_VALUE = 'Scale '+STRLOWCASE(((*(*info).plottitles).lswintitle)[(*(*info).plotswitch).heightset])+' to maximum of average'
		WIDGET_CONTROL, (*(*info).ctrlscp).lower_y_text, SET_VALUE = STRTRIM((*(*(*info).plotaxes).ls_low_y)[(*(*info).dataparams).s],2)
		WIDGET_CONTROL, (*(*info).ctrlscp).upper_y_text, SET_VALUE = STRTRIM((*(*(*info).plotaxes).ls_upp_y)[(*(*info).dataparams).s],2)
		WIDGET_CONTROL, (*(*info).ctrlscp).detspect_label, SET_VALUE = ((*(*info).plottitles).lswintitle)[(*(*info).plotswitch).heightset]+':'
	ENDELSE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).ctrlsswitch).imrefdetspect], labels=['imrefdetspect']
END

PRO CRISPEX_DISPLAYS_DOPPLER_TOGGLE, event, NO_DRAW=no_draw
; Reference image window creation procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event, /IGNORE_LAST
	(*(*info).winswitch).showdop = event.SELECT
	IF (*(*info).winswitch).showdop THEN BEGIN
		title = 'CRISPEX'+(*(*info).sesparams).instance_label+': Doppler image'
		CRISPEX_WINDOW, (*(*info).winsizes).xywinx, (*(*info).winsizes).xywiny, $
      (*(*info).winids).root, title, doptlb, dopwid, $
      (*(*info).winsizes).dopxoffset,(*(*info).winsizes).dopyoffset, $
			DRAWID = dopdrawid, DRAWBASE = dopdrawbase
		(*(*info).winids).doptlb = doptlb		&	(*(*info).winids).dopwid = dopwid	&	(*(*info).winids).dopdrawid = dopdrawid
		(*(*info).winids).dopdrawbase = dopdrawbase	&	(*(*info).winids).dopwintitle = title
		IF ~KEYWORD_SET(NO_DRAW) THEN BEGIN
			CRISPEX_UPDATE_T, event
			CRISPEX_DRAW_DOPPLER, event
		ENDIF
		WIDGET_CONTROL, dopdrawid, EVENT_PRO = 'CRISPEX_CURSOR', /SENSITIVE, /DRAW_MOTION_EVENTS, /TRACKING_EVENTS,/DRAW_BUTTON_EVENTS
		WIDGET_CONTROL, doptlb, SET_UVALUE = info
		XMANAGER, 'CRISPEX', doptlb, /NO_BLOCK
	ENDIF ELSE BEGIN
		(*(*info).dispswitch).drawdop = 0
		IF ~KEYWORD_SET(NO_DRAW) THEN BEGIN
			CRISPEX_DRAW_SPECTRAL, event
			CRISPEX_DRAW_TIMESLICES, event
		ENDIF
		WIDGET_CONTROL, (*(*info).winids).doptlb, /DESTROY
		(*(*info).winids).doptlb = 0
	ENDELSE
	IF (*(*info).overlayswitch).mask THEN CRISPEX_MASK_BUTTONS_SET, event
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).winids).doptlb,(*(*info).winids).dopwid,(*(*info).winids).dopdrawid], labels=['doptlb','dopwid','dopdrawid']
END

PRO CRISPEX_DISPLAYS_HEADER, event
; Pops up window with header information
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  files = ['Main: ','Reference: ','Slit-jaw image: ']
  hdrlen = [STRLEN((*(*(*(*info).dataparams).hdrs[0])[0])[0]), $
            STRLEN((*(*(*(*info).dataparams).hdrs[1])[0])[0]), $
            STRLEN((*(*(*(*info).dataparams).hdrs[2])[0])[0])]
  wherefileset = WHERE((hdrlen GT 0) EQ 1, count)
  IF (count GT 0) THEN BEGIN
    FOR i=0,count-1 DO BEGIN
      exte_idx = INDGEN((*(*info).dataparams).next[wherefileset[i]])
      tmp_vals = REPLICATE(files[wherefileset[i]],(*(*info).dataparams).next[wherefileset[i]])+$
        REPLICATE('Extension ',(*(*info).dataparams).next[wherefileset[i]])+$
        STRTRIM(exte_idx,2)
      tmp_uvals = [[REPLICATE(wherefileset[i],(*(*info).dataparams).next[wherefileset[i]])],[exte_idx]]
      IF (i EQ 0) THEN BEGIN
        vals = tmp_vals 
        uvals = tmp_uvals
      ENDIF ELSE BEGIN
        vals = [vals,tmp_vals]
        uvals = [uvals,tmp_uvals]
      ENDELSE
    ENDFOR
  	base = WIDGET_BASE(TITLE = 'CRISPEX'+(*(*info).sesparams).instance_label+$
      ': File headers', GROUP_LEADER = (*(*info).winids).root, TLB_FRAME_ATTR = 1, $
      /TLB_KILL_REQUEST_EVENTS)
  	disp = WIDGET_BASE(base, /COLUMN)
    (*(*info).ctrlshdr).header_select = WIDGET_COMBOBOX(disp, VALUE=vals, UVALUE=uvals, $
      EVENT_PRO='CRISPEX_DISPLAYS_HEADER_SELECT')
    text_base = WIDGET_BASE(disp, /COLUMN)
    (*(*info).ctrlshdr).header_txt = WIDGET_TEXT(text_base, $
      VALUE=(*(*(*(*info).dataparams).hdrs[0])[0]), XSIZE=CEIL(MAX(hdrlen)*1.1), $
      YSIZE=CEIL(MAX(hdrlen)/2.), /SCROLL, /WRAP)
    close_base = WIDGET_BASE(disp, /ALIGN_CENTER)
    close_button = WIDGET_BUTTON(close_base, VALUE='Close', EVENT_PRO='CRISPEX_CLOSE_EVENT_WINDOW')
  	WIDGET_CONTROL, base, /REALIZE, TLB_SET_XOFFSET = (*(*info).winsizes).lsxoffset, $
      TLB_SET_YOFFSET = (*(*info).winsizes).lswiny+1.5*(*(*info).winsizes).ydelta
  	WIDGET_CONTROL, base, SET_UVALUE = info
  	XMANAGER, 'CRISPEX', base, /NO_BLOCK
    (*(*info).winids).headertlb = base
  ENDIF ELSE BEGIN
  	CRISPEX_WINDOW_OK, event,'ERROR!','No file headers to display.', $
  		OK_EVENT='CRISPEX_CLOSE_EVENT_WINDOW', BASE=tlb
  	(*(*info).winids).errtlb = tlb
  ENDELSE 
END

PRO CRISPEX_DISPLAYS_HEADER_SELECT, event
; Handles changing of header display
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  WIDGET_CONTROL, (*(*info).ctrlshdr).header_select, GET_UVALUE=uvals
  WIDGET_CONTROL, (*(*info).ctrlshdr).header_txt, $
    SET_VALUE=(*(*(*(*info).dataparams).hdrs[uvals[event.INDEX,0]])[uvals[event.INDEX,1]])
END

PRO CRISPEX_DISPLAYS_INT_MENU, event, XOFFSET=xoffset, YOFFSET=yoffset
; Sets up the lightcurve plot options menu
  WIDGET_CONTROL, event.TOP, GET_UVALUE=info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  nsel_diagnostics = N_ELEMENTS(*(*(*info).intparams).sel_diagnostics)
  IF (nsel_diagnostics EQ 1) THEN BEGIN
    (*(*(*info).intparams).sel_diagnostics)[0] = (*(*info).intparams).lp_diag_all
    (*(*(*info).intparams).sellp_diagnostics)[0] = (*(*info).dataparams).lp
  ENDIF
	eventval = INDGEN(nsel_diagnostics)
	base = WIDGET_BASE(TITLE = 'CRISPEX'+(*(*info).sesparams).instance_label+$
    ': Lightcurve plot options', GROUP_LEADER = (*(*info).winids).root, $
    TLB_FRAME_ATTR = 1, /TLB_KILL_REQUEST_EVENTS)
	disp = WIDGET_BASE(base, /COLUMN)
  top_opts = WIDGET_BASE(disp, /ROW)
	sel_allnone = WIDGET_BASE(top_opts, /ROW, /ALIGN_LEFT)
	sel_allnone_lab = WIDGET_LABEL(sel_allnone, VALUE = 'Plot selected diagnostics:', $
    /ALIGN_LEFT)
	sel_allnone_buts = CW_BGROUP(sel_allnone, ['All','None'], BUTTON_UVALUE=INDGEN(2), $
    IDS=sel_allnone_ids, /EXCLUSIVE, /ROW, EVENT_FUNC='CRISPEX_BGROUP_INT_SEL_ALLNONE', $
    /NO_RELEASE)
  ; Set buttons
  set_allnone_buts = [(TOTAL(*(*(*info).intparams).seldisp_diagnostics) EQ $
    N_ELEMENTS(*(*(*info).intparams).sel_diagnostics)), $
    (TOTAL(*(*(*info).intparams).seldisp_diagnostics) EQ 0)]
  FOR i=0,N_ELEMENTS(sel_allnone_ids)-1 DO $
    WIDGET_CONTROL, sel_allnone_ids[i], SET_BUTTON=set_allnone_buts[i]
  (*(*info).ctrlsint).sel_allnone_ids = sel_allnone_ids
  ; Y-range input boxes
	yrange_base = WIDGET_BASE(top_opts, /ROW, /ALIGN_RIGHT)
	lower_y_label = WIDGET_LABEL(yrange_base, VALUE = '     Y-range:')
	(*(*info).ctrlsint).lower_y_int_text = WIDGET_TEXT(yrange_base, $
    VALUE=STRTRIM((*(*(*info).plotaxes).int_low_y)[(*(*info).dataparams).s],2), $
    /EDITABLE, XSIZE=5, EVENT_PRO='CRISPEX_DISPRANGE_INT_LOW')
	upper_y_label = WIDGET_LABEL(yrange_base, VALUE = '-')
	(*(*info).ctrlsint).upper_y_int_text = WIDGET_TEXT(yrange_base, $
    VALUE=STRTRIM((*(*(*info).plotaxes).int_upp_y)[(*(*info).dataparams).s],2), $
    /EDITABLE, XSIZE=5, EVENT_PRO='CRISPEX_DISPRANGE_INT_UPP')
  topdivider = CRISPEX_WIDGET_DIVIDER(disp)
  selopts_base = WIDGET_BASE(disp,/COLUMN, Y_SCROLL_SIZE=(nsel_diagnostics GT 11)*400, $
    X_SCROLL_SIZE=(nsel_diagnostics GT 11)*550) 
  ; Line style combobox labels
  ls_labels = STRTRIM(INDGEN(6),2)+' ('+(*(*info).intparams).linlab_diagnostics+')'
  FOR i=0,nsel_diagnostics-1 DO BEGIN
    ; Button names
    btname = 'int_sel_bt_'+STRTRIM(i,2)   ; (De)select button name
    dgname = 'int_sel_dg_'+STRTRIM(i,2)   ; Diagnostics combobox name
    lpname = 'int_sel_lp_'+STRTRIM(i,2)   ; Wavelength combobox name
    lsname = 'int_sel_ls_'+STRTRIM(i,2)   ; Line-style combobox name
    clname = 'int_sel_cl_'+STRTRIM(i,2)   ; Color combobox name
    ; Wavelength combobox labels
    lp_labels = LINDGEN((*(*(*info).intparams).diag_widths)[$
      (*(*(*info).intparams).sel_diagnostics)[i]])+$
      (*(*(*info).intparams).diag_starts)[$
      (*(*(*info).intparams).sel_diagnostics)[i]]
    IF (*(*info).plotswitch).v_dop_set THEN $
      lp_labels = STRTRIM(lp_labels,2)+' ('+STRTRIM((*(*info).dataparams).lps[$
        lp_labels[0]:lp_labels[N_ELEMENTS(lp_labels)-1]],2)+')' $
    ELSE $
      lp_labels = STRTRIM(lp_labels,2)
    ; Actual buttons and comboboxes
    sel_subopts = WIDGET_BASE(selopts_base, /ROW)
    sel_buts = WIDGET_BASE(sel_subopts, /NONEXCLUSIVE)
    sel_but = WIDGET_BUTTON(sel_buts, VALUE='', UVALUE=eventval[i], $
      EVENT_PRO='CRISPEX_DISPLAYS_INT_MENU_EVENT', UNAME=btname)
    (*(*info).ctrlsint).dg_box = WIDGET_COMBOBOX(sel_subopts, VALUE=(*(*info).intparams).diagnostics, $
      UVALUE=eventval[i], /DYNAMIC_RESIZE, EVENT_PRO='CRISPEX_DISPLAYS_INT_SEL_DIAG', $
      UNAME=dgname) 
    (*(*info).ctrlsint).lp_box = WIDGET_COMBOBOX(sel_subopts, VALUE=lp_labels,$
      UVALUE=eventval[i], /DYNAMIC_RESIZE, EVENT_PRO='CRISPEX_DISPLAYS_INT_SEL_LP', $
      UNAME=lpname) 
    (*(*info).ctrlsint).ls_box = WIDGET_COMBOBOX(sel_subopts, VALUE=ls_labels, $
      UVALUE=eventval[i], /DYNAMIC_RESIZE, EVENT_PRO='CRISPEX_DISPLAYS_INT_SEL_LINE', $
      UNAME=lsname)
    (*(*info).ctrlsint).cl_box = WIDGET_COMBOBOX(sel_subopts, $
      VALUE=(*(*info).intparams).collab_diagnostics, $
      UVALUE=eventval[i], /DYNAMIC_RESIZE, EVENT_PRO='CRISPEX_DISPLAYS_INT_SEL_COLS', $
      UNAME=clname)
    ; Set buttons: select display buttons
    WIDGET_CONTROL, sel_but, SET_BUTTON=(*(*(*info).intparams).seldisp_diagnostics)[i]
    WIDGET_CONTROL, (*(*info).ctrlsint).dg_box, $
      SET_COMBOBOX_SELECT=(*(*(*info).intparams).sel_diagnostics)[i],$
      SENSITIVE=( ((*(*info).intparams).ndiagnostics GT 1) AND $
        (*(*(*info).intparams).seldisp_diagnostics)[i] )
    WIDGET_CONTROL, (*(*info).ctrlsint).lp_box, $
      SET_COMBOBOX_SELECT=(*(*(*info).intparams).sellp_diagnostics)[i]-$
      (*(*(*info).intparams).diag_starts)[(*(*(*info).intparams).sel_diagnostics)[i]],$
      SENSITIVE=( ((*(*info).dataparams).nlp GT 1) AND $
        (*(*(*info).intparams).seldisp_diagnostics)[i] )
    WIDGET_CONTROL, (*(*info).ctrlsint).ls_box, $
      SET_COMBOBOX_SELECT=(*(*(*info).intparams).sellines_diagnostics)[i],$
      SENSITIVE=(*(*(*info).intparams).seldisp_diagnostics)[i]
    WIDGET_CONTROL, (*(*info).ctrlsint).cl_box, $
      SET_COMBOBOX_SELECT=(*(*(*info).intparams).selcol_diagnostics)[i],$
      SENSITIVE=(*(*(*info).intparams).seldisp_diagnostics)[i]
  ENDFOR
  add_base = WIDGET_BASE(selopts_base, /ROW, /ALIGN_RIGHT, GRID_LAYOUT=2)
  (*(*info).ctrlsint).remove_button = WIDGET_BUTTON(add_base, VALUE='Remove last lightcurve',$
    EVENT_PRO='CRISPEX_DISPLAYS_INT_REMOVE', $
    SENSITIVE=(N_ELEMENTS(*(*(*info).intparams).sel_diagnostics) GT 1))
  add_button = WIDGET_BUTTON(add_base, VALUE='Add lightcurve',$
    EVENT_PRO='CRISPEX_DISPLAYS_INT_ADD')
  bottomdivider = CRISPEX_WIDGET_DIVIDER(disp)
	button_base = WIDGET_BASE(disp, COLUMN=2, /GRID_LAYOUT, /ALIGN_CENTER)
	(*(*info).ctrlsint).int_sel_save = WIDGET_BUTTON(button_base, VALUE='   Save   ', $
    EVENT_PRO='CRISPEX_INT_SAVE')
	closebut = WIDGET_BUTTON(button_base, VALUE='   Close   ', $
    EVENT_PRO='CRISPEX_DISPLAYS_INT_MENU_CLOSE')
  ; Start managing
  IF (N_ELEMENTS(XOFFSET) NE 1) THEN xoffset = (*(*info).winsizes).aboutxoffset
  IF (N_ELEMENTS(YOFFSET) NE 1) THEN yoffset = (*(*info).winsizes).aboutyoffset
	WIDGET_CONTROL, base, /REALIZE, TLB_SET_XOFFSET=xoffset, TLB_SET_YOFFSET=yoffset
	WIDGET_CONTROL, base, SET_UVALUE = info
	XMANAGER, 'CRISPEX', base, /NO_BLOCK
	(*(*info).winids).intmenutlb = base
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).winids).intmenutlb], labels=['intmenutlb']
END

PRO CRISPEX_DISPLAYS_INT_MENU_EVENT, event
; Handles the selection of diagnostics to be shown in the lightcurve plot
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, event.ID, GET_UVALUE = eventval
	(*(*(*info).intparams).seldisp_diagnostics)[eventval] = $
    ( (*(*(*info).intparams).seldisp_diagnostics)[eventval] EQ 0) 
  dgname = 'int_sel_dg_'+STRTRIM(eventval,2)   ; Diagnostics combobox name
  lpname = 'int_sel_lp_'+STRTRIM(eventval,2)   ; Wavelength combobox name
  lsname = 'int_sel_ls_'+STRTRIM(eventval,2)   ; Line-style combobox name
  clname = 'int_sel_cl_'+STRTRIM(eventval,2)   ; Color combobox name
	WIDGET_CONTROL, WIDGET_INFO(event.TOP, FIND_BY_UNAME=dgname), $
    SENSITIVE=(*(*(*info).intparams).seldisp_diagnostics)[eventval]
	WIDGET_CONTROL, WIDGET_INFO(event.TOP, FIND_BY_UNAME=lpname), $
    SENSITIVE=(*(*(*info).intparams).seldisp_diagnostics)[eventval]
	WIDGET_CONTROL, WIDGET_INFO(event.TOP, FIND_BY_UNAME=lsname), $
    SENSITIVE=(*(*(*info).intparams).seldisp_diagnostics)[eventval]
	WIDGET_CONTROL, WIDGET_INFO(event.TOP, FIND_BY_UNAME=clname), $
    SENSITIVE=(*(*(*info).intparams).seldisp_diagnostics)[eventval]
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [eventval,(*(*(*info).intparams).sel_diagnostics)[eventval]], $
      labels=['Diagnostic ID','Diagnostic selected']
	CRISPEX_DISPLAYS_INT_BUTTON_CONDITION, event
	CRISPEX_DRAW, event
END

PRO CRISPEX_DISPLAYS_INT_BUTTON_CONDITION, event
; Handles the update of buttons after selection
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	condition = WHERE(*(*(*info).intparams).seldisp_diagnostics EQ 1, count)
	WIDGET_CONTROL, (*(*info).ctrlsint).int_sel_save, SENSITIVE = (count GT 0)
  WIDGET_CONTROL, (*(*info).ctrlsint).sel_allnone_ids[1], $
    SET_BUTTON=(count EQ 0)
  WIDGET_CONTROL, (*(*info).ctrlsint).sel_allnone_ids[0], $
    SET_BUTTON=(count EQ N_ELEMENTS(*(*(*info).intparams).seldisp_diagnostics))
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(count EQ N_ELEMENTS(*(*(*info).intparams).seldisp_diagnostics)), $
      (count EQ 0), (count GT 0)], labels=['All selected','None selected','Save enabled']
END

PRO CRISPEX_DISPLAYS_INT_ADD, event
; Handles adding a lightcurve
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info, /NO_COPY
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  nsel_diagnostics = N_ELEMENTS(*(*(*info).intparams).sel_diagnostics)
  *(*(*info).intparams).sel_diagnostics = $
    [*(*(*info).intparams).sel_diagnostics,(*(*info).intparams).lp_diag_all]
  *(*(*info).intparams).seldisp_diagnostics = $
    [*(*(*info).intparams).seldisp_diagnostics,1B]
  *(*(*info).intparams).sellp_diagnostics = $
    [*(*(*info).intparams).sellp_diagnostics,(*(*info).dataparams).lp]
  *(*(*info).intparams).sellines_diagnostics = $
    [*(*(*info).intparams).sellines_diagnostics,$
    (((*(*(*info).intparams).sellines_diagnostics)[nsel_diagnostics-1]+1) MOD $
      N_ELEMENTS((*(*info).intparams).linlab_diagnostics))]
  *(*(*info).intparams).selcol_diagnostics = $
    [*(*(*info).intparams).selcol_diagnostics,$
    (((*(*(*info).intparams).selcol_diagnostics)[nsel_diagnostics-1]+1) MOD $
      N_ELEMENTS((*(*info).intparams).collab_diagnostics))]
  geometry = WIDGET_INFO((*(*info).winids).intmenutlb, /GEOMETRY)
  WIDGET_CONTROL, (*(*info).winids).root, SET_UVALUE=info
  WIDGET_CONTROL, event.TOP, /DESTROY
  event.TOP = (*(*info).winids).root
  CRISPEX_DISPLAYS_INT_MENU, event, XOFFSET=geometry.XOFFSET, $
    YOFFSET=geometry.YOFFSET-22   ; Empirically determined correction 
  CRISPEX_DRAW_INT, event
END

PRO CRISPEX_DISPLAYS_INT_REMOVE, event
; Handles adding a lightcurve
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info, /NO_COPY
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  nsel_diagnostics = N_ELEMENTS(*(*(*info).intparams).sel_diagnostics)
  *(*(*info).intparams).sel_diagnostics = (*(*(*info).intparams).sel_diagnostics)[0:nsel_diagnostics-2]
  *(*(*info).intparams).seldisp_diagnostics = $
    (*(*(*info).intparams).seldisp_diagnostics)[0:nsel_diagnostics-2]
  *(*(*info).intparams).sellp_diagnostics = $
    (*(*(*info).intparams).sellp_diagnostics)[0:nsel_diagnostics-2]
  *(*(*info).intparams).sellines_diagnostics = $
    (*(*(*info).intparams).sellines_diagnostics)[0:nsel_diagnostics-2]
  *(*(*info).intparams).selcol_diagnostics = $
    (*(*(*info).intparams).selcol_diagnostics)[0:nsel_diagnostics-2]
  geometry = WIDGET_INFO((*(*info).winids).intmenutlb, /GEOMETRY)
  WIDGET_CONTROL, (*(*info).winids).root, SET_UVALUE=info
  WIDGET_CONTROL, event.TOP, /DESTROY
  event.TOP = (*(*info).winids).root
  CRISPEX_DISPLAYS_INT_MENU, event, XOFFSET=geometry.XOFFSET, $
    YOFFSET=geometry.YOFFSET-22   ; Empirically determined correction 
  CRISPEX_DRAW_INT, event
END

PRO CRISPEX_DISPLAYS_INT_MENU_CLOSE, event
; Handles the closing of the intensity versus time plot options menu and clean-up of display afterwards
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).winids).intmenutlb,(*(*info).winids).inttlb], labels=['intmenutlb was','inttlb was']
	WIDGET_CONTROL, (*(*info).winids).intmenutlb, /DESTROY
	WIDGET_CONTROL, (*(*info).winids).inttlb, /DESTROY
	(*(*info).winids).intmenutlb = 0
	(*(*info).winids).inttlb = 0
	WIDGET_CONTROL, (*(*info).ctrlscp).int_toggle_but, SET_BUTTON = 0
	(*(*info).winswitch).showint = 0
END

PRO CRISPEX_DISPLAYS_INT_SEL_COLS, event
; Handles selection of linestyle of intensity versus time plot
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, event.ID, GET_UVALUE = eventval
	IF ( (*(*(*info).intparams).seldisp_diagnostics)[eventval] EQ 1) THEN $
    (*(*(*info).intparams).selcol_diagnostics)[eventval] = event.INDEX
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, $
      [eventval,(*(*(*info).intparams).selcol_diagnostics)[eventval]], $
      labels=['Diagnostic ID','Color index selected']
	CRISPEX_DRAW_INT, event
END

PRO CRISPEX_DISPLAYS_INT_SEL_LINE, event
; Handles selection of linestyle of intensity versus time plot
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, event.ID, GET_UVALUE = eventval
	IF ( (*(*(*info).intparams).seldisp_diagnostics)[eventval] EQ 1) THEN $
    (*(*(*info).intparams).sellines_diagnostics)[eventval] = event.INDEX
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, $
      [eventval,(*(*(*info).intparams).sellines_diagnostics)[eventval]], $
      labels=['Diagnostic ID','Linestyle selected']
	CRISPEX_DRAW_INT, event
END

PRO CRISPEX_DISPLAYS_INT_SEL_DIAG, event
; Handles selection of linestyle of intensity versus time plot
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, event.ID, GET_UVALUE = eventval
	IF ( (*(*(*info).intparams).seldisp_diagnostics)[eventval] EQ 1) THEN $
    (*(*(*info).intparams).sel_diagnostics)[eventval] = event.INDEX
  ; Adjust possible wavelengths
  lp_labels = LINDGEN((*(*(*info).intparams).diag_widths)[$
    (*(*(*info).intparams).sel_diagnostics)[eventval]])+$
    (*(*(*info).intparams).diag_starts)[$
    (*(*(*info).intparams).sel_diagnostics)[eventval]]
  IF (*(*info).plotswitch).v_dop_set THEN $
    lp_labels = STRTRIM(lp_labels,2)+' ('+STRTRIM((*(*info).dataparams).lps[$
      lp_labels[0]:lp_labels[N_ELEMENTS(lp_labels)-1]],2)+')' $
  ELSE $
    lp_labels = STRTRIM(lp_labels,2)
  ; Change wavelength combobox accordingly
	WIDGET_CONTROL, WIDGET_INFO(event.TOP, FIND_BY_UNAME='int_sel_lp_'+STRTRIM(eventval,2)), $
    SET_VALUE=lp_labels, SET_COMBOBOX_SELECT=0
  ; Change actual wavelength variable to reflect adjustment
  (*(*(*info).intparams).sellp_diagnostics)[eventval] = $
    (*(*(*info).intparams).diag_starts)[(*(*(*info).intparams).sel_diagnostics)[eventval]]
	CRISPEX_DRAW_INT, event
END

PRO CRISPEX_DISPLAYS_INT_SEL_LP, event
; Handles selection of linestyle of intensity versus time plot
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, event.ID, GET_UVALUE = eventval
	IF ( (*(*(*info).intparams).seldisp_diagnostics)[eventval] EQ 1) THEN $
    (*(*(*info).intparams).sellp_diagnostics)[eventval] = event.INDEX+$
      (*(*(*info).intparams).diag_starts)[(*(*(*info).intparams).sel_diagnostics)[eventval]]
	CRISPEX_DRAW_INT, event
END

PRO CRISPEX_DISPLAYS_INT_RESIZE, event						
; Intensity versus time window resize handler, gets new window dimensions and calls (re)display routines
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	CRISPEX_DISPLAYS_PLOT_RESIZE, event, event.X, event.Y, (*(*info).winsizes).intxres, $
    (*(*info).winsizes).intyres, (*(*info).plotpos).intxmargin_init, (*(*info).plotpos).intxwall_init, $
		intxres, intyres, intwidth, intheight, intx0, intx1, inty0, inty1, ERROR=error
	IF error THEN CRISPEX_DISPLAYS_RESIZE_ERROR, event ELSE BEGIN
		(*(*info).winsizes).intxres = intxres		& 	(*(*info).winsizes).intyres = intyres
		(*(*info).plotpos).intx0 = intx0		&	(*(*info).plotpos).intx1 = intx1
		(*(*info).plotpos).inty0 = inty0		&	(*(*info).plotpos).inty1 = inty1
		(*(*info).plotaxes).intxticklen = (*(*info).plotaxes).ticklen / intheight
		(*(*info).plotaxes).intyticklen = (*(*info).plotaxes).ticklen / intwidth
	ENDELSE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [error,(*(*info).winsizes).intxres,(*(*info).winsizes).intyres,(*(*info).plotpos).intx0,(*(*info).plotpos).intx1,$
		(*(*info).plotpos).inty0,(*(*info).plotpos).inty1], labels=['error','intxres','intyres','intx0','intx1','inty0','inty1']
	WIDGET_CONTROL, (*(*info).winids).intdrawid, DRAW_XSIZE = (*(*info).winsizes).intxres, DRAW_YSIZE = (*(*info).winsizes).intyres
	WIDGET_CONTROL, event.TOP, SET_UVALUE = info
	CRISPEX_DRAW_INT, event
END

PRO CRISPEX_DISPLAYS_INT_TOGGLE, event, NO_DRAW=no_draw
; Intensity versus time window creation procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).winswitch).showint = event.SELECT
	IF (*(*info).winswitch).showint THEN BEGIN
		CRISPEX_DISPLAYS_INT_MENU, event
		title = 'CRISPEX'+(*(*info).sesparams).instance_label+': Lightcurve plot'
		CRISPEX_WINDOW, (*(*info).winsizes).intxres, (*(*info).winsizes).intyres, $
      (*(*info).winids).root, title, inttlb, intwid, $
      (*(*info).winsizes).lsxoffset, 0, DRAWID = intdrawid, $
			RESIZING = 1, RES_HANDLER = 'CRISPEX_DISPLAYS_INT_RESIZE'
		(*(*info).winids).inttlb = inttlb	&	(*(*info).winids).intwid = intwid	&	(*(*info).winids).intdrawid = intdrawid
		(*(*info).winids).intwintitle = title
		WIDGET_CONTROL, (*(*info).winids).inttlb, SET_UVALUE = info
		IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).winids).inttlb,(*(*info).winids).intwid,(*(*info).winids).intdrawid], labels=['inttlb','intwid','intdrawid']
		IF ~KEYWORD_SET(NO_DRAW) THEN CRISPEX_DRAW_INT, event
	ENDIF ELSE CRISPEX_DISPLAYS_INT_MENU_CLOSE, event
END

PRO CRISPEX_DISPLAYS_LOOPSLAB_GET, event
; Loopslab window creation procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	IF ((*(*info).dataparams).refnt GT 1) THEN BEGIN
		CRISPEX_DISPLAYS_LOOPSLAB, event,/NO_DRAW
		CRISPEX_DISPLAYS_REFLOOPSLAB, event
	ENDIF ELSE CRISPEX_DISPLAYS_LOOPSLAB, event
END

PRO CRISPEX_DISPLAYS_LOOPSLAB_REPLOT_AXES, event					
; Updates loopslab display window plot axes range according to set parameters
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	WSET, (*(*info).winids).loopwid
	PLOT, FINDGEN((*(*info).loopsdata).loopsize), $
    *(*(*info).dispparams).tarr_main, /NODATA, $
    YR=[(*(*info).dispparams).t_low_main,(*(*info).dispparams).t_upp_main], $
    /YS, POS = [(*(*info).plotpos).loopx0,(*(*info).plotpos).loopy0,$
    (*(*info).plotpos).loopx1,(*(*info).plotpos).loopy1], $
    YTICKLEN=(*(*info).plotaxes).loopyticklen,$
    XTICKLEN=(*(*info).plotaxes).loopxticklen, /XS, $
    YTITLE=(*(*info).plottitles).spytitle, $
    XTITLE='Pixel along loop', BACKGROUND=(*(*info).plotparams).bgplotcol, $
    COLOR=(*(*info).plotparams).plotcol
  IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).winids).loopwid], $
      labels=['Window ID for replot']
END

PRO CRISPEX_DISPLAYS_LOOPSLAB_RESIZE, event
; Loopslab window resize handler, gets new window dimensions and calls (re)display routines
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	CRISPEX_DISPLAYS_PLOT_RESIZE, event, event.X, event.Y, (*(*info).winsizes).loopxres, (*(*info).winsizes).loopyres, (*(*info).plotpos).loopxmargin_init, (*(*info).plotpos).loopxwall_init, $
		loopxres, loopyres, loopwidth, loopheight, loopx0, loopx1, loopy0, loopy1, ERROR=error, /SLICE
	IF error THEN CRISPEX_DISPLAYS_RESIZE_ERROR, event ELSE BEGIN
		(*(*info).winsizes).loopxres = loopxres			& 	(*(*info).winsizes).loopyres = loopyres
		(*(*info).plotpos).loopx0 = loopx0			&	(*(*info).plotpos).loopx1 = loopx1
		(*(*info).plotpos).loopy0 = loopy0			&	(*(*info).plotpos).loopy1 = loopy1
		(*(*info).plotpos).loopxplspw = loopx1 - loopx0		&	(*(*info).plotpos).loopyplspw = loopy1 - loopy0
		(*(*info).plotaxes).loopxticklen = -1 * (*(*info).plotaxes).ticklen / loopheight
		(*(*info).plotaxes).loopyticklen = -1 * (*(*info).plotaxes).ticklen / loopwidth
		(*(*info).dispparams).loopnlxreb = (*(*info).plotpos).loopxplspw * (*(*info).winsizes).loopxres 
		(*(*info).dispparams).loopntreb = (*(*info).plotpos).loopyplspw * (*(*info).winsizes).loopyres 
	ENDELSE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [error,(*(*info).winsizes).loopxres,(*(*info).winsizes).loopyres,(*(*info).plotpos).loopx0,(*(*info).plotpos).loopx1,$
		(*(*info).plotpos).loopy0,(*(*info).plotpos).loopy1], labels=['error','loopxres','loopyres','loopx0','loopx1','loopy0','loopy1']
	WIDGET_CONTROL, (*(*info).winids).loopdrawid, DRAW_XSIZE = (*(*info).winsizes).loopxres, DRAW_YSIZE = (*(*info).winsizes).loopyres
	WIDGET_CONTROL, event.TOP, SET_UVALUE = info
	CRISPEX_DISPLAYS_LOOPSLAB_REPLOT_AXES, event
	CRISPEX_DRAW_LOOPSLAB, event
END

PRO CRISPEX_DISPLAYS_LOOPSLAB, event, NO_DRAW=no_draw
; Loopslab window creation procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).winswitch).showloop = 1
	WIDGET_CONTROL,/HOURGLASS
	CRISPEX_LOOP_GET_PATH, event
	CRISPEX_LOOP_GET_SLAB, event
	title = 'CRISPEX'+(*(*info).sesparams).instance_label+': T-slice along loop'
	CRISPEX_WINDOW, (*(*info).winsizes).loopxres, (*(*info).winsizes).loopyres, $
    (*(*info).winids).root, title, tlb, wid, $
    (*(*info).winsizes).loopxoffset, (*(*info).winsizes).loopyoffset, $
    DRAWID=loopdrawid, RESIZING=1, RES_HANDLER='CRISPEX_DISPLAYS_LOOPSLAB_RESIZE'
	PLOT, FINDGEN((*(*info).loopsdata).loopsize), $
    *(*(*info).dispparams).tarr_main, /NODATA, $
    YR=[(*(*info).dispparams).t_low_main,(*(*info).dispparams).t_upp_main], $
    /YS, POS=[(*(*info).plotpos).loopx0,(*(*info).plotpos).loopy0,$
    (*(*info).plotpos).loopx1,(*(*info).plotpos).loopy1],$
		YTICKLEN=(*(*info).plotaxes).loopyticklen, $
    XTICKLEN=(*(*info).plotaxes).loopxticklen, /XS, $
    YTITLE=(*(*info).plottitles).spytitle, XTITLE='Pixel along loop',$
		BACKGROUND = (*(*info).plotparams).bgplotcol, $
    COLOR=(*(*info).plotparams).plotcol
	(*(*info).winids).looptlb = tlb		&	(*(*info).winids).loopwid = wid		
  (*(*info).winids).loopdrawid = loopdrawid
	(*(*info).winids).loopwintitle = title 
	WIDGET_CONTROL, (*(*info).winids).looptlb, SET_UVALUE = info
	IF ~KEYWORD_SET(NO_DRAW) THEN BEGIN
		CRISPEX_UPDATE_LP, event
		CRISPEX_ZOOM_LOOP, event
		CRISPEX_DRAW, event
	ENDIF
	WIDGET_CONTROL, (*(*info).ctrlscp).save_loop_pts, SENSITIVE = 1
	WIDGET_CONTROL, (*(*info).ctrlscp).timeslicemenu, SENSITIVE = 1
	WIDGET_CONTROL, (*(*info).ctrlscp).loop_slice_but, SENSITIVE = 0
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).winids).looptlb,$
      (*(*info).winids).loopwid,(*(*info).winids).loopdrawid], $
      labels=['looptlb','loopwid','loopdrawid']
END

PRO CRISPEX_DISPLAYS_REFLOOPSLAB_REPLOT_AXES, event					
; Updates reference loopslab display window plot axes range according to set 
; parameters
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	WSET, (*(*info).winids).refloopwid
	PLOT, FINDGEN((*(*info).loopsdata).refloopsize), $
    *(*(*info).dispparams).tarr_ref, /NODATA, /YS, $
    POS=[(*(*info).plotpos).refloopx0,(*(*info).plotpos).refloopy0, $
    (*(*info).plotpos).refloopx1,(*(*info).plotpos).refloopy1], $
		YTICKLEN=(*(*info).plotaxes).refloopyticklen, $
    XTICKLEN=(*(*info).plotaxes).refloopxticklen, /XS, $
    YTITLE=(*(*info).plottitles).spytitle, XTITLE='Pixel along loop', $
		BACKGROUND=(*(*info).plotparams).bgplotcol, $
    COLOR=(*(*info).plotparams).plotcol
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).winids).refloopwid], $
      labels=['Window ID for replot']
END

PRO CRISPEX_DISPLAYS_REFLOOPSLAB_RESIZE, event
; Reference loopslab window resize handler, gets new window dimensions and calls (re)display routines
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	CRISPEX_DISPLAYS_PLOT_RESIZE, event, event.X, event.Y, (*(*info).winsizes).refloopxres, (*(*info).winsizes).refloopyres, (*(*info).plotpos).refloopxmargin_init, (*(*info).plotpos).refloopxwall_init, $
		refloopxres, refloopyres, refloopwidth, refloopheight, refloopx0, refloopx1, refloopy0, $
  refloopy1, ERROR=error, /SLICE
	IF error THEN CRISPEX_DISPLAYS_RESIZE_ERROR, event ELSE BEGIN
		(*(*info).winsizes).refloopxres = refloopxres			& 	(*(*info).winsizes).refloopyres = refloopyres
		(*(*info).plotpos).refloopx0 = refloopx0			&	(*(*info).plotpos).refloopx1 = refloopx1
		(*(*info).plotpos).refloopy0 = refloopy0			&	(*(*info).plotpos).refloopy1 = refloopy1
		(*(*info).plotpos).refloopxplspw = refloopx1 - refloopx0	&	(*(*info).plotpos).refloopyplspw = refloopy1 - refloopy0
		(*(*info).plotaxes).refloopxticklen = -1 * (*(*info).plotaxes).ticklen / refloopheight
		(*(*info).plotaxes).refloopyticklen = -1 * (*(*info).plotaxes).ticklen / refloopwidth
		(*(*info).dispparams).refloopnlxreb = (*(*info).plotpos).refloopxplspw * (*(*info).winsizes).refloopxres 
		(*(*info).dispparams).refloopntreb = (*(*info).plotpos).refloopyplspw * (*(*info).winsizes).refloopyres 
	ENDELSE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [error,(*(*info).winsizes).refloopxres,(*(*info).winsizes).refloopyres,(*(*info).plotpos).refloopx0,(*(*info).plotpos).refloopx1,$
		(*(*info).plotpos).refloopy0,(*(*info).plotpos).refloopy1], labels=['error','refloopxres','refloopyres','refloopx0','refloopx1','refloopy0','refloopy1']
	WIDGET_CONTROL, (*(*info).winids).refloopdrawid, DRAW_XSIZE = (*(*info).winsizes).refloopxres, DRAW_YSIZE = (*(*info).winsizes).refloopyres
	WIDGET_CONTROL, event.TOP, SET_UVALUE = info
	CRISPEX_DISPLAYS_REFLOOPSLAB_REPLOT_AXES, event
	CRISPEX_DRAW_REFLOOPSLAB, event
END

PRO CRISPEX_DISPLAYS_REFLOOPSLAB, event, NO_DRAW=no_draw
; Reference, loopslab window creation procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).winswitch).showrefloop = 1
	WIDGET_CONTROL,/HOURGLASS
	CRISPEX_LOOP_GET_REFSLAB, event		
	title = 'CRISPEX'+(*(*info).sesparams).instance_label+$
    ': Reference T-slice along loop'
	CRISPEX_WINDOW, (*(*info).winsizes).refloopxres, $
    (*(*info).winsizes).refloopyres, (*(*info).winids).root, title, tlb, wid, $
    (*(*info).winsizes).xywinx+(*(*info).winsizes).xdelta, $
		((*(*info).winswitch).showsp + (*(*info).winswitch).showphis) * $
    (*(*info).winsizes).ydelta, DRAWID=refloopdrawid, RESIZING=1, $
    RES_HANDLER='CRISPEX_DISPLAYS_REFLOOPSLAB_RESIZE'
	PLOT, FINDGEN((*(*info).loopsdata).refloopsize), $
    *(*(*info).dispparams).tarr_ref, /NODATA, $
    YR=[(*(*info).dispparams).t_low_ref, (*(*info).dispparams).t_upp_ref], $
		/YS, POS=[(*(*info).plotpos).refloopx0,(*(*info).plotpos).refloopy0,$
    (*(*info).plotpos).refloopx1,(*(*info).plotpos).refloopy1],$
		YTICKLEN=(*(*info).plotaxes).refloopyticklen, $
    XTICKLEN=(*(*info).plotaxes).refloopxticklen, /XS, $
    YTITLE=(*(*info).plottitles).spytitle, XTITLE='Pixel along loop',$
		BACKGROUND=(*(*info).plotparams).bgplotcol, $
    COLOR=(*(*info).plotparams).plotcol
	(*(*info).winids).reflooptlb = tlb		&	(*(*info).winids).refloopwid = wid		
  (*(*info).winids).refloopdrawid = refloopdrawid
	(*(*info).winids).refloopwintitle = title 
	WIDGET_CONTROL, (*(*info).winids).reflooptlb, SET_UVALUE = info
	IF ~KEYWORD_SET(NO_DRAW) THEN BEGIN
		CRISPEX_UPDATE_LP, event
		CRISPEX_ZOOM_LOOP, event
		CRISPEX_DRAW, event
	ENDIF
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).winids).reflooptlb,$
      (*(*info).winids).refloopwid,(*(*info).winids).refloopdrawid], $
      labels=['reflooptlb','refloopwid','refloopdrawid']
END

PRO CRISPEX_DISPLAYS_PLOT_RESIZE, event, new_xres_tmp, new_yres_tmp, $
  init_xres, init_yres, init_xmargin, init_xwall, new_xres, new_yres, new_width, new_height, $
	x0, x1, y0, y1, v_dop_set, INX0=inx0, INX1=inx1, INY0=iny0, INY1=iny1, ERROR=error, $
  SLICE=slice, DETSPECT=detspect, STOKES_SELECT=stokes_select
; Handles the display plot resizing
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (N_ELEMENTS(v_dop_set) NE 1) THEN v_dop_set = 0
	IF KEYWORD_SET(DETSPECT) THEN BEGIN												; If considering main detailed spectrum
		curns = TOTAL((*(*info).stokesparams).select_sp)
		IF KEYWORD_SET(STOKES_SELECT) THEN BEGIN
			prevns = TOTAL((*(*info).stokesparams).prev_select_sp)
			new_xres_tmp = init_xres											; Default: no change in xsize
			new_yres_tmp = init_yres											; Default: no change in ysize
			IF (v_dop_set EQ 1) THEN offset = init_xmargin ELSE offset = init_xwall
			IF (prevns GT curns) THEN BEGIN											; If reducing the selected Stokes
        ; If new number is 2, prev was 3
				IF (curns EQ 2) THEN $
          new_yres_tmp = (init_yres + offset - v_dop_set*init_xwall) / 2. $
        ELSE IF (curns EQ 1) THEN $
          new_xres_tmp = (init_xres + init_xwall) / 2. 				;If new number is 1, prev was 2
			ENDIF ELSE BEGIN												; If increasing the selected Stokes
        ; If new number is 3, prev was 2
				IF (curns EQ 3) THEN $
          new_yres_tmp = 2. * init_yres - offset + v_dop_set*init_xwall $
        ELSE IF (curns EQ 2) THEN $
          new_xres_tmp = 2. * init_xres - init_xwall					; If new number is 2, prev was 1
			ENDELSE
		ENDIF
		IF (curns LE 2) THEN BEGIN
			npanels = curns	&	cols = curns
			rowarr = REPLICATE(0,curns)
		ENDIF ELSE BEGIN
			npanels = 4	&	cols = 2
			rowarr = [1,1,0,0]
		ENDELSE
		rows = CEIL(npanels / FLOAT(cols))
		x0 = FLTARR(npanels)
		x1 = FLTARR(npanels)
		y0 = FLTARR(npanels)
		y1 = FLTARR(npanels)
	ENDIF ELSE BEGIN														; All other plot windows
		rows = 1	&	cols = 1
	ENDELSE
	dx = ABS(new_xres_tmp - init_xres)
	dy = ABS(new_yres_tmp - init_yres)
  ; Actual recalculation of plot area
	IF ((dx NE 0) OR (dy NE 0)) THEN BEGIN
		new_margin = init_xmargin/new_xres_tmp
		new_wall = init_xwall/new_xres_tmp
		new_xres = new_xres_tmp
		new_yres = new_yres_tmp
		new_width = (1 - (cols*new_margin + new_wall))/FLOAT(cols)
			IF ((v_dop_set EQ 1) OR $
        (KEYWORD_SET(SLICE) AND ((*(*info).dataparams).ns GT 1))) THEN $
        new_height = (new_yres/FLOAT(new_xres) - (new_margin*(rows+1) + new_wall*(rows-1))) / $
          FLOAT(rows) $
      ELSE $
        new_height = (new_yres/FLOAT(new_xres) - (new_wall + rows*new_margin) ) / FLOAT(rows)
		IF KEYWORD_SET(DETSPECT) THEN BEGIN
			x0 = new_margin + (INDGEN(npanels) MOD cols) * (new_width + new_margin) 
			x1 = x0 + new_width 
			y0 = (new_margin + rowarr * (new_height + new_margin + v_dop_set*new_wall)) * new_xres/new_yres
			y1 = y0 + new_height * new_xres/new_yres
		ENDIF ELSE BEGIN
			x0 = new_margin 
			x1 = x0 + new_width
			y0 = new_margin * new_xres/new_yres
			y1 = y0 + new_height * new_xres/new_yres 
		ENDELSE
	ENDIF ELSE BEGIN															; If no change in size (Stokes select)
		x0 = inx0	&	x1 = inx1
		y0 = iny0	&	y1 = iny1
		new_xres = new_xres_tmp
		new_yres = new_yres_tmp
		new_width = inx1[0] - inx0[0]
		new_height = iny1[0] - iny0[0]
	ENDELSE
	dxpl = x1[0] - x0[0]	&	dypl = y1[0] - y0[0]
	IF ((dxpl LE 0) OR (dypl LE 0) OR (x0[0] LE 0) OR (y0[0] LE 0)) THEN error = 1 ELSE error = 0
END

PRO CRISPEX_DISPLAYS_LS_RESIZE, event, STOKES_SELECT=stokes_select
; Detailed spectrum window resize handler, gets new window dimensions and calls (re)display routines
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF KEYWORD_SET(STOKES_SELECT) THEN BEGIN
		newlsxres = (*(*info).winsizes).lsxres	&	newlsyres = (*(*info).winsizes).lsyres
	ENDIF ELSE BEGIN
		newlsxres = event.X		&	newlsyres = event.Y
	ENDELSE
	CRISPEX_DISPLAYS_PLOT_RESIZE, event, newlsxres, newlsyres, (*(*info).winsizes).lsxres, $
    (*(*info).winsizes).lsyres, (*(*info).plotpos).lsxmargin_init, $
    (*(*info).plotpos).lsxwall_init, lsxres, lsyres, lswidth, lsheight, $
		lsx0, lsx1, lsy0, lsy1, (*(*info).plotswitch).v_dop_set, INX0=(*(*info).plotpos).lsx0, $
    INX1=(*(*info).plotpos).lsx1, INY0=(*(*info).plotpos).lsy0, INY1=(*(*info).plotpos).lsy1, $
    ERROR=error, /DETSPECT, STOKES_SELECT=stokes_select
	IF error THEN CRISPEX_DISPLAYS_RESIZE_ERROR, event ELSE BEGIN
		(*(*info).winsizes).lsxres = lsxres	& 	(*(*info).winsizes).lsyres = lsyres
		(*(*info).plotpos).lsx0 = lsx0		&	(*(*info).plotpos).lsx1 = lsx1
		(*(*info).plotpos).lsy0 = lsy0		&	(*(*info).plotpos).lsy1 = lsy1
		(*(*info).plotaxes).lsxticklen = (*(*info).plotaxes).ticklen / lsheight
		(*(*info).plotaxes).lsyticklen = (*(*info).plotaxes).ticklen / lswidth
	ENDELSE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN BEGIN
		nstokes_sel = TOTAL((*(*info).stokesparams).select_sp)
		CRISPEX_VERBOSE_GET, event, [error,(*(*info).winsizes).lsxres,(*(*info).winsizes).lsyres,(*(*info).plotpos).lsx0,(*(*info).plotpos).lsx1,(*(*info).plotpos).lsy0,(*(*info).plotpos).lsy1], $
			labels=['error','lsxres','lsyres',REPLICATE('lsx0',nstokes_sel),REPLICATE('lsx1',nstokes_sel),REPLICATE('lsy0',nstokes_sel),REPLICATE('lsy1',nstokes_sel)]
	ENDIF
	WIDGET_CONTROL, (*(*info).winids).lsdrawid, DRAW_XSIZE = (*(*info).winsizes).lsxres, DRAW_YSIZE = (*(*info).winsizes).lsyres
	WIDGET_CONTROL, event.TOP, SET_UVALUE = info
  CRISPEX_DRAW_SPECTRAL_MAIN, event, /LS_ONLY
END

PRO CRISPEX_DISPLAYS_IMREFBLINK_TOGGLE, event
; Sets the playback mode to blink of main and reference image
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event, /IGNORE_LAST
	(*(*info).winswitch).showimref = event.SELECT
	(*(*info).pbparams).imrefmode = event.SELECT
	WIDGET_CONTROL, (*(*info).ctrlscp).lp_blink_but, SENSITIVE=ABS((*(*info).pbparams).imrefmode-1)
	IF (*(*info).winswitch).showimref THEN BEGIN
		title = 'CRISPEX'+(*(*info).sesparams).instance_label+': Main vs. reference image blink'
		CRISPEX_WINDOW, (*(*info).winsizes).xywinx, (*(*info).winsizes).xywiny, $
      (*(*info).winids).root, title, imreftlb, imrefwid, $
			(*(*info).winsizes).imrefxoffset,(*(*info).winsizes).imrefyoffset, $
      DRAWID = imrefdrawid, DRAWBASE = imrefdrawbase
		(*(*info).winids).imreftlb = imreftlb		&	(*(*info).winids).imrefwid = imrefwid	&	(*(*info).winids).imrefdrawid = imrefdrawid
		(*(*info).winids).imrefdrawbase = imrefdrawbase	&	(*(*info).winids).imrefwintitle = title
		IF ((*(*info).feedbparams).count_pbstats EQ 0) THEN (*(*info).feedbparams).pbstats = SYSTIME(/SECONDS)
		WIDGET_CONTROL, (*(*info).pbparams).bg, TIMER = 0.0
		WIDGET_CONTROL, imrefdrawid, EVENT_PRO = 'CRISPEX_CURSOR', /SENSITIVE, /DRAW_MOTION_EVENTS, /TRACKING_EVENTS,/DRAW_BUTTON_EVENTS
		WIDGET_CONTROL, imreftlb, SET_UVALUE = info
		XMANAGER, 'CRISPEX', imreftlb, /NO_BLOCK
	ENDIF ELSE BEGIN
		WIDGET_CONTROL, (*(*info).winids).imreftlb, /DESTROY
		(*(*info).scaling).imrefscaling = 0
		(*(*info).winids).imreftlb = 0
		IF ((*(*info).winids).feedbacktlb NE 0) THEN BEGIN
			(*(*info).feedbparams).count_pbstats = 0
			WIDGET_CONTROL, (*(*info).ctrlsfeedb).close_button, /SENSITIVE
		ENDIF
	ENDELSE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).winids).imreftlb,(*(*info).winids).imrefwid,(*(*info).winids).imrefdrawid], labels=['imreftlb','imrefwid','imrefdrawid']
END

PRO CRISPEX_DISPLAYS_IMREF_LS_TOGGLE, event, NO_DRAW=no_draw
; Detailed spectrum window creation procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event, /IGNORE_LAST
	IF (*(*info).ctrlsswitch).imrefdetspect THEN BEGIN	; For reference detailed spectrum window
		IF ((*(*info).winswitch).showrefls EQ 0) THEN BEGIN
			title = 'CRISPEX'+(*(*info).sesparams).instance_label+': '+((*(*info).plottitles).reflswintitle)[(*(*info).plotswitch).refheightset]
			CRISPEX_WINDOW, (*(*info).winsizes).reflsxres, $
        (*(*info).winsizes).reflsyres, (*(*info).winids).root, title, tlb, wid,$
        (*(*info).winsizes).reflsxoffset, (*(*info).winsizes).reflsyoffset, $
        DRAWID = lsdrawid, RESIZING = 1, RES_HANDLER = 'CRISPEX_DISPLAYS_REFLS_RESIZE'
			(*(*info).winids).reflstlb = tlb		&	(*(*info).winids).reflswid = wid	&	(*(*info).winswitch).showrefls = 1
			(*(*info).winids).reflsdrawid = lsdrawid	&	(*(*info).winids).reflswintitle = title
			WIDGET_CONTROL, (*(*info).winids).reflstlb, SET_UVALUE = info
      CRISPEX_UPDATE_REFSSP, event
			IF ~KEYWORD_SET(NO_DRAW) THEN CRISPEX_DRAW_SPECTRAL_REF, event, /LS_ONLY
		ENDIF ELSE BEGIN
			WIDGET_CONTROL, (*(*info).winids).reflstlb, /DESTROY
			(*(*info).winids).reflstlb = 0
			(*(*info).winswitch).showrefls = 0
		ENDELSE
		IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).winids).reflstlb,(*(*info).winids).reflswid,(*(*info).winids).reflsdrawid], labels=['reflstlb','reflswid','reflsdrawid']
	ENDIF ELSE BEGIN
		IF ((*(*info).winswitch).showls EQ 0) THEN BEGIN
			title = 'CRISPEX'+(*(*info).sesparams).instance_label+': '+((*(*info).plottitles).lswintitle)[(*(*info).plotswitch).heightset]
			CRISPEX_WINDOW, (*(*info).winsizes).lsxres, (*(*info).winsizes).lsyres, $
        (*(*info).winids).root, title, tlb, wid, $
        (*(*info).winsizes).lsxoffset, (*(*info).winsizes).lsyoffset, $
        DRAWID = lsdrawid, RESIZING = 1, $
				RES_HANDLER = 'CRISPEX_DISPLAYS_LS_RESIZE'
			(*(*info).winids).lstlb = tlb		&	(*(*info).winids).lswid = wid	&	(*(*info).winswitch).showls = 1
			(*(*info).winids).lsdrawid = lsdrawid	&	(*(*info).winids).lswintitle = title
			WIDGET_CONTROL, (*(*info).winids).lstlb, SET_UVALUE = info
      CRISPEX_UPDATE_SSP, event
			IF ~KEYWORD_SET(NO_DRAW) THEN CRISPEX_DRAW_SPECTRAL_MAIN, event, /LS_ONLY
		ENDIF ELSE BEGIN
			WIDGET_CONTROL, (*(*info).winids).lstlb, /DESTROY
			(*(*info).winids).lstlb = 0
			(*(*info).winswitch).showls = 0
		ENDELSE
		IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).winids).lstlb,(*(*info).winids).lswid,(*(*info).winids).lsdrawid], labels=['lstlb','lswid','lsdrawid']
	ENDELSE
END

PRO CRISPEX_DISPLAYS_PHIS_REPLOT_AXES, event, NO_AXES=no_axes
; Updates temporal spectrum display window plot axes range according to set parameters
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WSET, (*(*info).winids).phiswid
	IF (*(*info).plotswitch).v_dop_set THEN extratitle = '!C' ELSE extratitle = ''
	IF (*(*info).plotswitch).multichannel THEN $
    title = 'Stokes '+((*(*info).stokesparams).labels)[(*(*info).dataparams).s]+extratitle $
  ELSE $
    title = ''
  ytitle = 'Position along slit [pixel]'
  ; Set axes parameters depending on # of diagnostics
  IF ((*(*info).intparams).ndisp_diagnostics GT 1) THEN BEGIN
    xticklen = 1E-9   & xtitle = ''
    xtickname = REPLICATE(' ',60)
    xtlen_basic_fac = 0.5
    xtlen_major_fac = 0.8
    IF KEYWORD_SET(NO_AXES) THEN BEGIN
      yticklen = 1E-9 & ytitle = ''
      ytickname = REPLICATE(' ',60)
    ENDIF ELSE BEGIN
      yticklen = (*(*info).plotaxes).phisyticklen
      ytickname = ''
    ENDELSE
  ENDIF ELSE BEGIN
    xticklen = (*(*info).plotaxes).phisxticklen
    xtitle = (*(*info).plottitles).spxtitle
    xtlen_basic_fac = 1.
    yticklen = (*(*info).plotaxes).phisyticklen
    xtickname = ''  & ytickname = ''
  ENDELSE
;  xticklen = xtlen_basic_fac * (*(*info).plotaxes).phisxticklen
  topxtitle = title
  IF (*(*info).plotswitch).v_dop_set THEN topxtitle += 'Doppler velocity [km/s]'
  ; Determine plot ranges
    (*(*info).plotaxes).phis_yrange = $
              [-(((*(*info).phiparams).nw_cur - (*(*info).phiparams).nphi)/2. + $
                 (*(*info).phiparams).sphi)-0.5, (*(*info).phiparams).nw_cur - $
               (((*(*info).phiparams).nw_cur - (*(*info).phiparams).nphi)/2. + $
                 (*(*info).phiparams).sphi)-0.5]
    phis_xrange = [(*(*info).dataparams).lps[(*(*info).dispparams).lp_low],$
          (*(*info).dataparams).lps[(*(*info).dispparams).lp_upp]]
  ; Plot basic axes box
	PLOT, (*(*info).dataparams).lps, FINDGEN((*(*info).phiparams).nw_cur), /NODATA, $
    YRANGE = (*(*info).plotaxes).phis_yrange, /YS, XRANGE=phis_xrange, $
		XSTYLE = (*(*info).plotswitch).v_dop_set * 8 + 1,  $
    YTICKLEN = yticklen, YTITLE=ytitle, YTICKNAME=ytickname, $
    XTICKLEN = xticklen, XTITLE=xtitle, XTICKNAME=xtickname, $
		POS = [(*(*info).plotpos).phisx0,(*(*info).plotpos).phisy0,$
             (*(*info).plotpos).phisx1,(*(*info).plotpos).phisy1], $
    BACKGROUND = (*(*info).plotparams).bgplotcol, COLOR = (*(*info).plotparams).plotcol;, $
    NOERASE=((*(*info).intparams).ndiagnostics GT 1)
  IF ~KEYWORD_SET(NO_AXES) THEN BEGIN
    ; Plot xtitle(s)
    IF ((*(*info).intparams).ndiagnostics GT 1) THEN $
        XYOUTS,(*(*info).plotpos).phisxplspw/2.+(*(*info).plotpos).phisx0,$
          (*(*info).plotpos).phisy0/3.,(*(*info).plottitles).spxtitle,ALIGNMENT=0.5, $
          COLOR = (*(*info).plotparams).plotcol,/NORMAL
    ; Loop over all diagnostics for plotting of detailed spectrum
    FOR d=0,(*(*info).intparams).ndisp_diagnostics-1 DO BEGIN
      ; No need to check for count: there is always at least one diagnostic displayed 
      disp_idx = (WHERE((*(*info).intparams).disp_diagnostics EQ 1))[d]
      ; Determine xrange to display
      IF ((*(*info).intparams).ndiagnostics GT 1) THEN BEGIN
        phis_xrange = (*(*info).dataparams).lps[[(*(*info).intparams).diag_start[disp_idx],$
          ((*(*info).intparams).diag_start[disp_idx]+(*(*info).intparams).diag_width[disp_idx]-1)]]
        vdop_xrange = (*(*(*info).plotaxes).v_dop[disp_idx])[$
          [0,(*(*(*info).intparams).diag_widths)[d]-1]]
      ENDIF ELSE $
        vdop_xrange = (*(*(*info).plotaxes).v_dop[0])[$
          [(*(*info).dispparams).lp_low,(*(*info).dispparams).lp_upp]]
      IF (d EQ 0) THEN offset = 0 ELSE offset = TOTAL((*(*(*info).plotaxes).diag_range_phis)[0:(d-1)])
      ; Determine lower left corner position of plot
      phisx0 = (*(*info).plotpos).phisx0 + offset
      phisx1 = (*(*(*info).plotaxes).diag_range_phis)[d] + phisx0
      ; Plot axes sub-box
  	  PLOT, (*(*info).dataparams).lps, FINDGEN((*(*info).phiparams).nw_cur), /NODATA, $
        YRANGE=(*(*info).plotaxes).phis_yrange, /YS, XRANGE=phis_xrange, $
        XSTYLE = (*(*info).plotswitch).v_dop_set * 8 + 1, $
        POS = [phisx0,(*(*info).plotpos).phisy0,phisx1,(*(*info).plotpos).phisy1], $
        YTICKLEN=1E-9, XTICKLEN=xticklen, $
        YTICKNAME=REPLICATE(' ',60), XTICKNAME=xtickname, $
        XTICKINTERVAL=(*(*(*info).plotaxes).xtickinterval)[0], $
        XTICK_GET=xtickvals, XMINOR=(0-((*(*info).intparams).ndisp_diagnostics GT 1)), $
        BACKGROUND = (*(*info).plotparams).bgplotcol, COLOR = (*(*info).plotparams).plotcol,$
        /NOERASE
      ; In case of multiple diagnostics
      IF ((*(*info).intparams).ndisp_diagnostics GT 1) THEN BEGIN
        ; Redraw x-axis with custom labelling
        IF (*(*info).plotswitch).xtick_reset THEN BEGIN
          (*(*info).plotaxes).xtickvals[d] = $
            PTR_NEW(CRISPEX_PLOTAXES_XTICKVALS_SELECT(xtickvals, $
            TICKSEP=(*(*(*info).plotaxes).xtickinterval)[1]))
          IF (d EQ ((*(*info).intparams).ndisp_diagnostics-1)) THEN $
            (*(*info).plotswitch).xtick_reset = 0
        ENDIF
        wherenonempty = WHERE(*(*(*info).plotaxes).xtickvals[d] NE ' ', count)
        IF (count GT 0) THEN BEGIN
          FOR k=0,N_ELEMENTS(wherenonempty)-1 DO BEGIN
            PLOTS,[1.,1.]*FLOAT((*(*(*info).plotaxes).xtickvals[d])[wherenonempty[k]]), $
              [(*(*info).plotaxes).phis_yrange[0], xtlen_major_fac*$
              ((*(*info).plotaxes).phis_yrange[1]-(*(*info).plotaxes).phis_yrange[0])*$
              (*(*info).plotaxes).phisxticklen+(*(*info).plotaxes).phis_yrange[0]], $
              COLOR=(*(*info).plotparams).plotcol
          ENDFOR
        ENDIF
        AXIS, XAXIS=0, XTICKLEN=xtlen_basic_fac*(*(*info).plotaxes).phisxticklen, $
          XRANGE=phis_xrange, /XS, $
          XTICKNAME=*(*(*info).plotaxes).xtickvals[d], XMINOR=-1, $
          COLOR=(*(*info).plotparams).plotcol, $
          XTICKINTERVAL=(*(*(*info).plotaxes).xtickinterval)[0]
      ENDIF
      ; Display Doppler top axis if Doppler set, else regular top axis
  		IF ((*(*info).plotswitch).v_dop_set EQ 1) THEN BEGIN
        IF (d EQ 0) THEN $
          XYOUTS,((*(*info).plotpos).phisx1-(*(*info).plotpos).phisx0)/2.+$
            (*(*info).plotpos).phisx0,$
            (*(*info).plotpos).phisy0/5.*3+(*(*info).plotpos).phisy1, topxtitle, $
            ALIGNMENT=0.5, COLOR = (*(*info).plotparams).plotcol,/NORMAL
        topxtitle = ''
        ;Draw top axis
        IF ((*(*info).intparams).ndisp_diagnostics GT 1) THEN BEGIN
          ; Plot the initial tick marks and get the tick vals
          AXIS, XAXIS=1, XRANGE=vdop_xrange, $
            XSTYLE=1, XTITLE = topxtitle, COLOR = (*(*info).plotparams).plotcol,$
            XTICKINTERVAL=(*(*(*info).plotaxes).xdoptickinterval)[0], $
            XTICKNAME=REPLICATE(' ',60), $
            XTICK_GET=xdoptickvals, XTICKLEN=1E-9
          ; Redraw x-axis with custom labelling
          IF (*(*info).plotswitch).xdoptick_reset THEN BEGIN
            (*(*info).plotaxes).xdoptickvals[d] = $
              PTR_NEW(CRISPEX_PLOTAXES_XTICKVALS_SELECT(xdoptickvals, $
              TICKSEP=(*(*(*info).plotaxes).xdoptickinterval)[1],$
              /DOPPLER))
            wherenonempty = WHERE(*(*(*info).plotaxes).xdoptickvals[d] NE ' ')
            ; Determine Doppler tick mark locations
            (*(*info).plotaxes).xdoptickloc[d] = $
              PTR_NEW(CRISPEX_PLOTAXES_XDOPTICKLOC(xdoptickvals, wherenonempty, $
              vdop_xrange, phis_xrange))
            IF (d EQ ((*(*info).intparams).ndisp_diagnostics-1)) THEN $
              (*(*info).plotswitch).xdoptick_reset = 0
          ENDIF
          FOR k=0,N_ELEMENTS(*(*(*info).plotaxes).xdoptickloc[d])-1 DO BEGIN
            PLOTS,[1.,1.]*(*(*(*info).plotaxes).xdoptickloc[d])[k], $
              [(*(*info).plotaxes).phis_yrange[1], -xtlen_major_fac*$
              ((*(*info).plotaxes).phis_yrange[1]-(*(*info).plotaxes).phis_yrange[0])*$
              (*(*info).plotaxes).phisxticklen+(*(*info).plotaxes).phis_yrange[1]], $
              COLOR=(*(*info).plotparams).plotcol
          ENDFOR
          ; Add the labels      
          AXIS, XAXIS=1, XRANGE=vdop_xrange, /XS, $
            XTICKNAME=*(*(*info).plotaxes).xdoptickvals[d], $
            COLOR=(*(*info).plotparams).plotcol, $
            XTICKLEN=xtlen_basic_fac*(*(*info).plotaxes).phisxticklen, $
            XTICKINTERVAL=(*(*(*info).plotaxes).xdoptickinterval)[0], XMINOR=-1
        ENDIF ELSE $
          ; Else plot Doppler axis with automatic tick mark settings
        	AXIS, XAXIS=1, XTICKLEN=(*(*info).plotaxes).phisxticklen, XRANGE=vdop_xrange, $
            XSTYLE=1, XTITLE=topxtitle, COLOR=(*(*info).plotparams).plotcol
      ENDIF ELSE $
  			AXIS, XAXIS=1, XTICKLEN = (*(*info).plotaxes).phisxticklen, XRANGE = xrange, XSTYLE=1, $
          XTITLE = topxtitle, COLOR = (*(*info).plotparams).plotcol, $
          XTICKNAME=REPLICATE(' ',60)
    ENDFOR
  ENDIF
END

PRO CRISPEX_DISPLAYS_PHIS_RESIZE, event							
; Spectral phi slice window resize handler, gets new window dimensions and calls (re)display routines
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	CRISPEX_DISPLAYS_PLOT_RESIZE, event, event.X, event.Y, (*(*info).winsizes).phisxres, (*(*info).winsizes).phisyres, (*(*info).plotpos).phisxmargin_init, (*(*info).plotpos).phisxwall_init, $
		phisxres, phisyres, phiswidth, phisheight, phisx0, phisx1, phisy0, phisy1, $
  (*(*info).plotswitch).v_dop_set, ERROR=error, /SLICE
	IF error THEN CRISPEX_DISPLAYS_RESIZE_ERROR, event ELSE BEGIN
		(*(*info).winsizes).phisxres = phisxres			& 	(*(*info).winsizes).phisyres = phisyres
		(*(*info).plotpos).phisx0 = phisx0			&	(*(*info).plotpos).phisx1 = phisx1
		(*(*info).plotpos).phisy0 = phisy0			&	(*(*info).plotpos).phisy1 = phisy1
		(*(*info).plotpos).phisxplspw = phisx1 - phisx0		&	(*(*info).plotpos).phisyplspw = phisy1 - phisy0
		(*(*info).plotaxes).phisxticklen = -1 * (*(*info).plotaxes).ticklen / phisheight
		(*(*info).plotaxes).phisyticklen = -1 * (*(*info).plotaxes).ticklen / phiswidth
		(*(*info).dispparams).phisnlpreb = (*(*info).plotpos).phisxplspw * (*(*info).winsizes).phisxres 
		(*(*info).dispparams).nphireb = (*(*info).plotpos).phisyplspw * (*(*info).winsizes).phisyres 
	ENDELSE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [error,(*(*info).winsizes).phisxres,(*(*info).winsizes).phisyres,(*(*info).plotpos).phisx0,(*(*info).plotpos).phisx1,$
		(*(*info).plotpos).phisy0,(*(*info).plotpos).phisy1], labels=['error','phisxres','phisyres','phisx0','phisx1','phisy0','phisy1']
	WIDGET_CONTROL, (*(*info).winids).phisdrawid, DRAW_XSIZE = (*(*info).winsizes).phisxres, DRAW_YSIZE = (*(*info).winsizes).phisyres
	WIDGET_CONTROL, event.TOP, SET_UVALUE = info
  CRISPEX_DRAW_GET_SPECTRAL_AXES, event, /MAIN
  CRISPEX_DISPLAYS_PHIS_REPLOT_AXES, event
	CRISPEX_DRAW_PHIS, event
END

PRO CRISPEX_DISPLAYS_PHIS_TOGGLE, event, NO_DRAW=no_draw
; Spectral phi slice window creation procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event, /IGNORE_LAST
	IF ((*(*info).winswitch).showphis EQ 0) THEN BEGIN
		WIDGET_CONTROL,/HOURGLASS
		wintitle = 'CRISPEX'+(*(*info).sesparams).instance_label+': '+$
      ((*(*info).plottitles).phiswintitle)[(*(*info).plotswitch).heightset]
		CRISPEX_WINDOW, (*(*info).winsizes).phisxres, (*(*info).winsizes).phisyres, $
      (*(*info).winids).root, wintitle, tlb, wid, $
      (*(*info).winsizes).phisxoffset, (*(*info).winsizes).phisyoffset, $
      DRAWID = phisdrawid, RESIZING = 1, RES_HANDLER = 'CRISPEX_DISPLAYS_PHIS_RESIZE'
		(*(*info).winids).phistlb = tlb			&	(*(*info).winids).phiswid = wid
		(*(*info).winids).phisdrawid = phisdrawid	&	(*(*info).winids).phiswintitle = wintitle 
		WIDGET_CONTROL, (*(*info).winids).phistlb, SET_UVALUE = info
		(*(*info).ctrlsswitch).bwd_insensitive = 0	
		(*(*info).ctrlsswitch).fwd_insensitive = 0
		(*(*info).winswitch).showphis = 1
    CRISPEX_DISPRANGE_LP_RANGE, event, /NO_DRAW
	ENDIF ELSE BEGIN
		WIDGET_CONTROL, (*(*info).winids).phistlb, /DESTROY
		(*(*info).winids).phistlb = 0
		(*(*info).winswitch).showphis = 0
	ENDELSE
	WIDGET_CONTROL, (*(*info).ctrlscp).phi_slider, SENSITIVE = (*(*info).winswitch).showphis
	WIDGET_CONTROL, (*(*info).ctrlscp).nphi_slider, SENSITIVE = (*(*info).winswitch).showphis
	WIDGET_CONTROL, (*(*info).ctrlscp).bwd_move_slit, SENSITIVE = (*(*info).winswitch).showphis
	WIDGET_CONTROL, (*(*info).ctrlscp).fwd_move_slit, SENSITIVE = (*(*info).winswitch).showphis
  IF (*(*info).winswitch).showphis THEN BEGIN
  	CRISPEX_PHISLIT_DIRECTION, event
    CRISPEX_UPDATE_PHISLIT_COORDS, event
    CRISPEX_DISPLAYS_PHIS_REPLOT_AXES, event
    CRISPEX_UPDATE_SLICES, event, NO_DRAW=no_draw
  ENDIF
	WIDGET_CONTROL, (*(*info).ctrlscp).slice_button, SENSITIVE = 0
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).winids).phistlb,(*(*info).winids).phiswid,$
      (*(*info).winids).phisdrawid], labels=['phistlb','phiswid','phisdrawid']
END

PRO CRISPEX_DISPLAYS_REF_TOGGLE, event, NO_DRAW=no_draw
; Reference image window creation procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event, /IGNORE_LAST
	(*(*info).winswitch).showref = event.SELECT
	IF (*(*info).winswitch).showref THEN BEGIN
		title = 'CRISPEX'+(*(*info).sesparams).instance_label+': Reference image'
		CRISPEX_WINDOW, (*(*info).winsizes).refwinx, (*(*info).winsizes).refwiny, $
      (*(*info).winids).root, title, reftlb, refwid, $
      (*(*info).winsizes).refxoffset, (*(*info).winsizes).refyoffset, $
      DRAWID = refdrawid, DRAWBASE = refdrawbase, $
      /SCROLL, XSCROLL=xscroll, YSCROLL=yscroll, /REFERENCE
    (*(*info).ctrlsref).xrefpos_slider = xscroll
    (*(*info).ctrlsref).yrefpos_slider = yscroll
    WIDGET_CONTROL, (*(*info).ctrlsref).xrefpos_slider, $
      SET_VALUE=(*(*info).zooming).xrefpos, SENSITIVE=((*(*info).zooming).factor NE 1)
    WIDGET_CONTROL, (*(*info).ctrlsref).yrefpos_slider, $
      SET_VALUE=(*(*info).zooming).yrefpos, SENSITIVE=((*(*info).zooming).factor NE 1)
		(*(*info).winids).reftlb = reftlb		
    (*(*info).winids).refwid = refwid	
    (*(*info).winids).refdrawid = refdrawid
		(*(*info).winids).refdrawbase = refdrawbase	
    (*(*info).winids).refwintitle = title
		IF ~KEYWORD_SET(NO_DRAW) THEN BEGIN
			CRISPEX_UPDATE_T, event
			CRISPEX_DRAW_REF, event
		ENDIF
		WIDGET_CONTROL, refdrawid, EVENT_PRO = 'CRISPEX_CURSOR', /SENSITIVE, $
      /DRAW_MOTION_EVENTS, /TRACKING_EVENTS,/DRAW_BUTTON_EVENTS
		WIDGET_CONTROL, reftlb, SET_UVALUE = info
		XMANAGER, 'CRISPEX', reftlb, /NO_BLOCK
	ENDIF ELSE BEGIN
		WIDGET_CONTROL, (*(*info).winids).reftlb, /DESTROY
		(*(*info).winids).reftlb = 0
	ENDELSE
	WIDGET_CONTROL, (*(*info).ctrlscp).lp_ref_but, SENSITIVE = $
    (((*(*info).dataparams).nlp EQ (*(*info).dataparams).refnlp) AND $
     ((*(*info).dataparams).refnlp GT 1))
	WIDGET_CONTROL, (*(*info).ctrlscp).lp_ref_slider, $
    SENSITIVE = (((*(*info).dataparams).refnlp GT 1) AND $
    ABS((*(*info).ctrlsswitch).lp_ref_lock-1))
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, $
      [(*(*info).winids).reftlb,(*(*info).winids).refwid, $
      (*(*info).winids).refdrawid], labels=['reftlb','refwid','refdrawid']
END

PRO CRISPEX_DISPLAYS_RESIZE_ERROR, event
; Opens error window on resize error
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	CRISPEX_WINDOW_OK, event,'ERROR!',$
    'Window resize request cannot be completed: '+$
    'resize values beyond boundaries. Reverted to old window size.',$
		OK_EVENT='CRISPEX_CLOSE_EVENT_WINDOW', BASE=tlb
	(*(*info).winids).errtlb = tlb
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).winids).errtlb], labels=['errtlb']
END

PRO CRISPEX_DISPLAYS_RESTORE_LOOPSLAB_REPLOT_AXES, event				
; Updates restored loopslab display window plot axes range according to set parameters
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	FOR i=0,N_ELEMENTS(*(*(*info).winids).restloopwid)-1 DO BEGIN
		WSET, (*(*(*info).winids).restloopwid)[i]
    sel_idx = (*(*(*info).restoreparams).disp_loopnr)[i]
		PLOT, FINDGEN(N_ELEMENTS(*(*(*(*info).restoreparams).xr)[sel_idx])),$
      *(*(*info).dispparams).tarr_main, $
      /NODATA, YR=[(*(*info).dispparams).t_low_main, (*(*info).dispparams).t_upp_main], $
			/YS, POS=[(*(*info).plotpos).restloopx0,(*(*info).plotpos).restloopy0,	$
      (*(*info).plotpos).restloopx1,(*(*info).plotpos).restloopy1], $
			YTICKLEN = (*(*info).plotaxes).restloopyticklen, XTICKLEN = (*(*info).plotaxes).restloopxticklen, /XS, YTITLE = (*(*info).plottitles).spytitle, XTITLE = 'Pixel along loop', $
			BACKGROUND = (*(*info).plotparams).bgplotcol, COLOR = (*(*info).plotparams).plotcol
		IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*(*info).winids).restloopwid)[i]], labels=['Window ID for replot']
	ENDFOR
END

PRO CRISPEX_DISPLAYS_RESTORE_LOOPSLAB_RESIZE, event				
; Restored loopslab window resize handler, gets new window dimensions and calls (re)display routines
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	CRISPEX_DISPLAYS_PLOT_RESIZE, event, event.X, event.Y, (*(*info).winsizes).restloopxres, (*(*info).winsizes).restloopyres, (*(*info).plotpos).restloopxmargin_init, (*(*info).plotpos).restloopxwall_init, $
		restloopxres, restloopyres, restloopwidth, restloopheight, restloopx0, restloopx1, restloopy0, $
  restloopy1, ERROR=error, /SLICE
	IF error THEN CRISPEX_DISPLAYS_RESIZE_ERROR, event ELSE BEGIN
		(*(*info).winsizes).restloopxres = restloopxres			& 	(*(*info).winsizes).restloopyres = restloopyres
		(*(*info).plotpos).restloopx0 = restloopx0			&	(*(*info).plotpos).restloopx1 = restloopx1
		(*(*info).plotpos).restloopy0 = restloopy0			&	(*(*info).plotpos).restloopy1 = restloopy1
		(*(*info).plotpos).restloopxplspw = restloopx1 - restloopx0	&	(*(*info).plotpos).restloopyplspw = restloopy1 - restloopy0
		(*(*info).plotaxes).restloopxticklen = -1 * (*(*info).plotaxes).ticklen / restloopheight
		(*(*info).plotaxes).restloopyticklen = -1 * (*(*info).plotaxes).ticklen / restloopwidth
		(*(*info).dispparams).restloopnlxreb = (*(*info).plotpos).restloopxplspw * (*(*info).winsizes).restloopxres 
		(*(*info).dispparams).restloopntreb = (*(*info).plotpos).restloopyplspw * (*(*info).winsizes).restloopyres 
	ENDELSE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [error,(*(*info).winsizes).loopxres,(*(*info).winsizes).loopyres,(*(*info).plotpos).loopx0,(*(*info).plotpos).loopx1,$
		(*(*info).plotpos).loopy0,(*(*info).plotpos).loopy1], labels=['error','loopxres','loopyres','loopx0','loopx1','loopy0','loopy1']
	FOR i=0,N_ELEMENTS(*(*(*info).winids).restloopdrawid)-1 DO WIDGET_CONTROL, (*(*(*info).winids).restloopdrawid)[i], DRAW_XSIZE = (*(*info).winsizes).restloopxres, DRAW_YSIZE = (*(*info).winsizes).restloopyres
	WIDGET_CONTROL, event.TOP, SET_UVALUE = info
	CRISPEX_DISPLAYS_RESTORE_LOOPSLAB_REPLOT_AXES, event
	CRISPEX_DRAW_REST_LOOP, event
END

PRO CRISPEX_DISPLAYS_RESTORE_LOOPSLAB_SELECT, event						
; Restored loopslab display window creation procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, (*(*info).ctrlsrestore).disp_list, GET_VALUE = list_values
	IF (event.INDEX GT 0) THEN BEGIN
		(*(*info).winswitch).showrestloop = 1
		sel_disp_loop = WHERE(*(*(*info).restoreparams).disp_loopnr EQ (event.INDEX-1), count)
    IF (count GT 0) THEN BEGIN 
      ; If the selected loop is being displayed, it should be destroyed
			WIDGET_CONTROL, (*(*(*info).winids).restlooptlb)[sel_disp_loop], /DESTROY
      ; Change dropdown selection field accordingly
			list_values[event.INDEX] = 'Display time slice '+STRTRIM(event.INDEX-1,2)
			WIDGET_CONTROL, (*(*info).ctrlsrestore).disp_list, $
        SET_VALUE = list_values, SET_COMBOBOX_SELECT = event.INDEX
      ; Change dropdown selection field accordingly
			(*(*(*info).winids).restlooptlb)[sel_disp_loop] = 0
      ; Check what loops are displayed
			wherenot0 = WHERE(*(*(*info).winids).restlooptlb NE 0, count, $
        COMPLEMENT=where0)
			where0 = where0[0]
			old_restricted_t_range = $
        TOTAL(*(*(*info).dispswitch).restricted_t_range)
			old_restricted_lp_range = $
        TOTAL(*(*(*info).dispswitch).restricted_lp_range)
			old_restricted_lp_ref_range = $
        TOTAL(*(*(*info).dispswitch).restricted_lp_ref_range)
      ; If there are still loops being displayed, adjust selection made for
      ; variables
      IF (count GT 0) THEN BEGIN
				*(*(*info).winids).restlooptlb = $
          (*(*(*info).winids).restlooptlb)[wherenot0]
				*(*(*info).winids).restloopwid = $
          (*(*(*info).winids).restloopwid)[wherenot0]
				*(*(*info).winids).restloopdrawid = $
          (*(*(*info).winids).restloopdrawid)[wherenot0]
				*(*(*info).restoreparams).disp_loopnr = $
          (*(*(*info).restoreparams).disp_loopnr)[wherenot0]
				*(*(*info).restoreparams).disp_imref = $
          (*(*(*info).restoreparams).disp_imref)[wherenot0]
				*(*(*info).dispswitch).restricted_t_range = $
          (*(*(*info).dispswitch).restricted_t_range)[wherenot0]
				*(*(*info).dispswitch).restricted_lp_range = $
          (*(*(*info).dispswitch).restricted_lp_range)[wherenot0]
				*(*(*info).dispswitch).restricted_lp_ref_range = $
          (*(*(*info).dispswitch).restricted_lp_ref_range)[wherenot0]
				*(*(*info).restoreparams).disp_slices = $
					(*(*(*info).restoreparams).disp_slices)[wherenot0]
				*(*(*info).restoreparams).disp_ref_slices = $
          (*(*(*info).restoreparams).disp_ref_slices)[wherenot0]
				sel_reorder = WHERE(wherenot0 GT where0, count)
        ; If there were loop indices above the one closed, the indices need to
        ; be reordered
        IF (count GT 0) THEN BEGIN
					FOR k=0,N_ELEMENTS(sel_reorder)-1 DO BEGIN
						*(*(*(*info).loopsdata).rest_loopslice[where0+k]) = $
              *(*(*(*info).loopsdata).rest_loopslice[wherenot0[sel_reorder[k]]])
						*(*(*(*info).loopsdata).rest_loopslab[where0+k]) = $
              *(*(*(*info).loopsdata).rest_loopslab[wherenot0[sel_reorder[k]]])
						*(*(*(*info).loopsdata).rest_crossloc[where0+k]) = $
              *(*(*(*info).loopsdata).rest_crossloc[wherenot0[sel_reorder[k]]])
					ENDFOR
				ENDIF ELSE k=0
				*(*(*(*info).loopsdata).rest_loopslice[where0+k]) = 0
				*(*(*(*info).loopsdata).rest_loopslab[where0+k]) = 0
				*(*(*(*info).loopsdata).rest_crossloc[where0+k]) = 0
			ENDIF ELSE BEGIN
        ; If there are no more loops being displayed, reset all variables
				*(*(*info).restoreparams).disp_loopnr = -1
				*(*(*info).restoreparams).disp_imref = -1
				(*(*info).restoreparams).disp_slices = PTR_NEW(0)
				(*(*info).restoreparams).disp_ref_slices = PTR_NEW(0)
				(*(*info).winids).restlooptlb = PTR_NEW(0)
				(*(*info).dispswitch).restricted_t_range = PTR_NEW(0)
				(*(*info).dispswitch).restricted_lp_range = PTR_NEW(0)
				(*(*info).dispswitch).restricted_lp_ref_range = PTR_NEW(0)
				(*(*info).winswitch).showrestloop = 0
				*(*(*(*info).loopsdata).rest_loopslice[0]) = 0 
				*(*(*(*info).loopsdata).rest_loopslab[0]) = 0
				*(*(*(*info).loopsdata).rest_crossloc[0]) = 0
			ENDELSE
			IF ((TOTAL(*(*(*info).dispswitch).restricted_t_range) EQ 0) AND $
        old_restricted_t_range) THEN CRISPEX_DISPRANGE_T_RESET, event
			IF ((TOTAL(*(*(*info).dispswitch).restricted_lp_range) EQ 0) AND $
        old_restricted_lp_range) THEN CRISPEX_DISPRANGE_LP_RESET, event
			IF ((TOTAL(*(*(*info).dispswitch).restricted_lp_ref_range) EQ 0) AND $
        old_restricted_lp_ref_range) THEN CRISPEX_DISPRANGE_LP_REF_RESET, event
			WIDGET_CONTROL, (*(*info).ctrlscp).lp_slider, $
        SENSITIVE = (TOTAL(*(*(*info).restoreparams).disp_slices) EQ 0) 
			WIDGET_CONTROL, (*(*info).ctrlscp).lp_ref_slider, $
        SENSITIVE = (TOTAL(*(*(*info).restoreparams).disp_ref_slices) EQ 0) 
		ENDIF ELSE BEGIN
      ; If displaying a new loop, change the display filename
			(*(*info).restoreparams).disp_loopfile = (*(*(*info).restoreparams).cfiles)[event.INDEX-1]
			refbase = FILE_BASENAME(STRMID((*(*info).dataparams).refimfilename,0,$
                  STRPOS((*(*info).dataparams).refimfilename,'.',/REVERSE_SEARCH)))
      ; Check whether it is a main or reference loop
			IF (STRLEN(refbase) GT 0) THEN $
        disp_imref = STRCMP(refbase,FILE_BASENAME($
          (*(*info).restoreparams).disp_loopfile),STRLEN(refbase)) $
      ELSE $
        disp_imref = 0
      ; If there are already loops being displayed, append variables to current
      ; selection
			IF (TOTAL(*(*(*info).restoreparams).disp_loopnr) GE 0) THEN BEGIN
				*(*(*info).restoreparams).disp_loopnr = $
          [*(*(*info).restoreparams).disp_loopnr,event.INDEX-1] 
				*(*(*info).restoreparams).disp_imref = $
          [*(*(*info).restoreparams).disp_imref,disp_imref]
			ENDIF ELSE BEGIN
        ; Else initialise variables
				*(*(*info).restoreparams).disp_loopnr = event.INDEX-1
				*(*(*info).restoreparams).disp_imref = disp_imref
			ENDELSE
      ; Adjust dropdown menu labels
			list_values[event.INDEX] = 'Hide time slice '+STRTRIM(event.INDEX-1,2)
			WIDGET_CONTROL, (*(*info).ctrlsrestore).disp_list, SET_VALUE=list_values,$
        SET_COMBOBOX_SELECT = event.INDEX
      ; Start displaying corresponding loopslab
			CRISPEX_DISPLAYS_RESTORE_LOOPSLAB, event
		ENDELSE
	ENDIF ELSE BEGIN
		(*(*info).restoreparams).disp_loopfile = '0'
		IF (*(*info).winswitch).showrestloop THEN BEGIN
			(*(*info).winswitch).showrestloop = 0
			CRISPEX_DISPRANGE_T_RESET, event
			CRISPEX_DISPRANGE_LP_RESET, event
			CRISPEX_DISPRANGE_LP_REF_RESET, event
			FOR i=0,N_ELEMENTS(*(*(*info).winids).restlooptlb)-1 DO BEGIN
				WIDGET_CONTROL, (*(*(*info).winids).restlooptlb)[i], /DESTROY
				list_values[(*(*(*info).restoreparams).disp_loopnr)[i]+1] = $
          'Display time slice '+STRTRIM((*(*(*info).restoreparams).disp_loopnr)[i],2)
				*(*(*(*info).loopsdata).rest_loopslice[i]) = 0
				*(*(*(*info).loopsdata).rest_loopslab[i]) = 0
				*(*(*(*info).loopsdata).rest_crossloc[i]) = 0
			ENDFOR
			WIDGET_CONTROL, (*(*info).ctrlsrestore).disp_list, SET_VALUE=list_values,$
        SET_COMBOBOX_SELECT = event.INDEX
			(*(*info).winids).restlooptlb = PTR_NEW(0)
			(*(*info).dispswitch).restricted_t_range = PTR_NEW(0)
			(*(*info).dispswitch).restricted_lp_range = PTR_NEW(0)
			*(*(*info).restoreparams).disp_loopnr = -1
			(*(*info).restoreparams).disp_slices = PTR_NEW(0)
			(*(*info).restoreparams).disp_ref_slices = PTR_NEW(0)
		ENDIF
		WIDGET_CONTROL,(*(*info).ctrlscp).lp_slider,/SENSITIVE
	ENDELSE
END

PRO CRISPEX_DISPLAYS_RESTORE_LOOPSLAB, event, NO_DRAW=no_draw, INDEX=index
; Restored loopslab display window creation procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
		update_t_range = 0
		update_lp_range = 0
		restricted_t_range = 0
		restricted_lp_range = 0
		restricted_lp_ref_range = 0
		ref_slice_only = 0
		WIDGET_CONTROL,/HOURGLASS
		RESTORE, (*(*info).restoreparams).disp_loopfile
		IF (N_ELEMENTS(INDEX) EQ 1) THEN $
      idx = index $
    ELSE $
      idx = N_ELEMENTS(*(*(*info).restoreparams).disp_loopnr)-1
    sel_idx = (*(*(*info).restoreparams).disp_loopnr)[idx]
		*(*(*(*info).loopsdata).rest_crossloc[idx]) = vertices
		IF (N_ELEMENTS(loop_slab) GT 0) THEN $
      loopslab = loop_slab $
    ELSE $
      loopslab = loop_slice
		*(*(*(*info).loopsdata).rest_loopslab[idx]) = loopslab
    ; Initialise empty slice 
    *(*(*(*info).loopsdata).rest_empty_slice)[sel_idx] = $
      MAKE_ARRAY(N_ELEMENTS(*(*(*(*info).restoreparams).xr)[sel_idx]),$
      (SIZE(loopslab))[2], TYPE=SIZE(loopslab, /TYPE))
    ; Arbitrary, but consistent, minimum value such that the gaps are really
    ; black compared to the data values
    min_dispslice_data = -(1+(MIN(loopslab) LT 0)*2) * ABS(MIN(loopslab))
    IF ((*(*(*(*info).loopsdata).rest_empty_slice)[sel_idx])[0,0] NE $
      min_dispslice_data) THEN $
      REPLICATE_INPLACE, *(*(*(*info).loopsdata).rest_empty_slice)[sel_idx], min_dispslice_data
		slice_only = (SIZE(*(*(*(*info).loopsdata).rest_loopslab[idx]),/N_DIMENSIONS) LT 3)
		IF slice_only THEN BEGIN			; Only a slice
			*(*(*(*info).loopsdata).rest_loopslice[idx]) = *(*(*(*info).loopsdata).rest_loopslab[idx])
			IF ((SIZE(*(*(*(*info).loopsdata).rest_loopslice[idx])))[2] NE $
        (*(*info).dataparams).nt) THEN BEGIN
				IF (N_ELEMENTS(t_low) EQ 0) THEN BEGIN
					CRISPEX_WINDOW_OK, event, 'WARNING!', $
						'The slice to be loaded has a reduced temporal range,'+$
            'however the format in which it was saved does not '+$
						'allow for correct slice restoration. If display '+$
            'is required, please save the slice again.', $
            OK_EVENT='CRISPEX_CLOSE_EVENT_WINDOW', BASE=tlb
					(*(*info).winids).warntlb = tlb
					RETURN
				ENDIF ELSE BEGIN
					IF ((t_low GE (*(*info).dispparams).t_upp) OR $
              (t_upp LT (*(*info).dispparams).t_low)) THEN BEGIN
						CRISPEX_WINDOW_OK, event, 'WARNING!', $
							'The temporal range of the loaded slice falls outside '+$
              'the range set by the currently loaded slices. If '+$
							'display is required, please close all currently '+$
              'loaded slices before proceeding.', $
              OK_EVENT='CRISPEX_CLOSE_EVENT_WINDOW', BASE=tlb
						(*(*info).winids).warntlb = tlb
						WIDGET_CONTROL, (*(*info).ctrlsrestore).disp_list, GET_VALUE = list_values
						caseidx = (*(*(*info).restoreparams).disp_loopnr)[idx]
						list_values[caseidx+1] = 'Display time slice '+STRTRIM(caseidx,2)
						WIDGET_CONTROL, (*(*info).ctrlsrestore).disp_list, SET_VALUE = list_values, $
              SET_COMBOBOX_SELECT = caseidx+1
						*(*(*info).restoreparams).disp_loopnr = (*(*(*info).restoreparams).disp_loopnr)[0:idx-1]
						*(*(*info).restoreparams).disp_imref = (*(*(*info).restoreparams).disp_imref)[0:idx-1]
            (*(*info).winswitch).showrestloop = 0
						RETURN
					ENDIF ELSE BEGIN
						update_t_range = 1
						restricted_t_range = 1
						(*(*info).dispparams).t_low = t_low
						(*(*info).dispparams).t_upp = t_upp
						IF (N_ELEMENTS(t_saved) EQ 0) THEN $
              (*(*info).dispparams).t = (*(*info).dispparams).t_low $
            ELSE $
              (*(*info).dispparams).t = t_saved
						WIDGET_CONTROL, (*(*info).ctrlscp).reset_trange_but, SENSITIVE = 0
						WIDGET_CONTROL, (*(*info).ctrlscp).lower_t_text, $
              SET_VALUE = STRTRIM((*(*info).dispparams).t_low,2), SENSITIVE = 0
						WIDGET_CONTROL, (*(*info).ctrlscp).upper_t_text, $
              SET_VALUE = STRTRIM((*(*info).dispparams).t_upp,2), SENSITIVE = 0
					ENDELSE
				ENDELSE
			ENDIF
			IF (*(*(*info).restoreparams).disp_imref)[idx] THEN BEGIN
				restricted_lp_ref_range = 1
				(*(*info).dataparams).lp_ref = spect_pos > (*(*info).dispparams).lp_ref_low < (*(*info).dispparams).lp_ref_upp 
				WIDGET_CONTROL,(*(*info).ctrlscp).lp_ref_slider, SENSITIVE = 0, $
          SET_VALUE = (*(*info).dataparams).lp_ref
				ref_slice_only = 1	&	slice_only = 0
			ENDIF ELSE BEGIN
				restricted_lp_range = 1
				(*(*info).dataparams).lp = spect_pos > (*(*info).dispparams).lp_low < (*(*info).dispparams).lp_upp
				WIDGET_CONTROL,(*(*info).ctrlscp).lp_slider,SENSITIVE = 0, SET_VALUE = (*(*info).dataparams).lp
				WIDGET_CONTROL,(*(*info).ctrlscp).lower_lp_text, SENSITIVE = 0
				WIDGET_CONTROL,(*(*info).ctrlscp).upper_lp_text, SENSITIVE = 0
			ENDELSE
			CRISPEX_UPDATE_T, event
		ENDIF ELSE BEGIN										; A full or partial slab
			IF ((SIZE(*(*(*(*info).loopsdata).rest_loopslab[idx])))[2] NE (*(*info).dataparams).nt) THEN BEGIN
				IF (N_ELEMENTS(t_saved) EQ 0) THEN $
          (*(*info).dispparams).t = (*(*info).dispparams).t_low $
        ELSE $
          (*(*info).dispparams).t = t_saved
				IF (N_ELEMENTS(t_low) EQ 0) THEN BEGIN
					CRISPEX_WINDOW_OK, event, 'WARNING!', $
						'The slice to be loaded has a reduced temporal range, '+$
            'however the format in which it was saved does not '+$
						'allow for correct slice restoration. If display '+$
            'is required, please save the slice again.', $
            OK_EVENT='CRISPEX_CLOSE_EVENT_WINDOW', BASE=tlb
					(*(*info).winids).warntlb = tlb
					RETURN
				ENDIF ELSE BEGIN
					IF ((t_low GE (*(*info).dispparams).t_upp) OR $
            (t_upp LT (*(*info).dispparams).t_low)) THEN BEGIN
						CRISPEX_WINDOW_OK, event, 'WARNING!', $
							'The temporal range of the loaded slice falls outside '+$
              'the range set by the currently loaded slices. If '+$
							'display is required, please close all currently '+$
              'loaded slices before proceeding.', $
              OK_EVENT='CRISPEX_CLOSE_EVENT_WINDOW', BASE=tlb
						(*(*info).winids).warntlb = tlb
						WIDGET_CONTROL, (*(*info).ctrlsrestore).disp_list, GET_VALUE = list_values
						caseidx = (*(*(*info).restoreparams).disp_loopnr)[idx]
						list_values[caseidx+1] = 'Display time slice '+STRTRIM(caseidx,2)
						WIDGET_CONTROL, (*(*info).ctrlsrestore).disp_list, SET_VALUE = list_values, $
              SET_COMBOBOX_SELECT = caseidx+1
						*(*(*info).restoreparams).disp_loopnr = (*(*(*info).restoreparams).disp_loopnr)[0:idx-1]
						*(*(*info).restoreparams).disp_imref = (*(*(*info).restoreparams).disp_imref)[0:idx-1]
						RETURN
					ENDIF ELSE BEGIN
						update_t_range = 1
						restricted_t_range = 1
						(*(*info).dispparams).t_low = t_low
						(*(*info).dispparams).t_upp = t_upp
						IF (N_ELEMENTS(t) EQ 0) THEN $
              (*(*info).dispparams).t = (*(*info).dispparams).t_low $
            ELSE $
              (*(*info).dispparams).t = t
						WIDGET_CONTROL, (*(*info).ctrlscp).lower_t_text, $
              SET_VALUE = STRTRIM((*(*info).dispparams).t_low,2), SENSITIVE = 0
						WIDGET_CONTROL, (*(*info).ctrlscp).upper_t_text, $
              SET_VALUE = STRTRIM((*(*info).dispparams).t_upp,2), SENSITIVE = 0
					ENDELSE
				ENDELSE
			ENDIF
			IF (*(*(*info).restoreparams).disp_imref)[idx] THEN nlp_comp = (*(*info).dataparams).refnlp ELSE nlp_comp = (*(*info).dataparams).nlp
			IF ((SIZE(*(*(*(*info).loopsdata).rest_loopslab[idx])))[3] NE nlp_comp) THEN BEGIN
				update_lp_range = 1
				IF (*(*(*info).restoreparams).disp_imref)[idx] THEN BEGIN	; Reference
					restricted_lp_ref_range = 1
					(*(*info).dispparams).lp_ref_low = spect_pos_low > (*(*info).dispparams).lp_ref_low
					(*(*info).dispparams).lp_ref_upp = spect_pos_upp < (*(*info).dispparams).lp_ref_upp
					(*(*info).dispparams).lp_ref_range = (*(*info).dispparams).lp_ref_upp - (*(*info).dispparams).lp_ref_low + 1
					(*(*info).dataparams).lp_ref = spect_pos > (*(*info).dispparams).lp_ref_low < (*(*info).dispparams).lp_ref_upp
					WIDGET_CONTROL,(*(*info).ctrlscp).lp_ref_slider, SET_SLIDER_MIN = (*(*info).dispparams).lp_ref_low, SET_SLIDER_MAX = (*(*info).dispparams).lp_ref_upp, $
						SET_VALUE = (*(*info).dataparams).lp_ref
				ENDIF ELSE BEGIN						; Main
					restricted_lp_range = 1
					(*(*info).dispparams).lp_low = spect_pos_low > (*(*info).dispparams).lp_low
					(*(*info).dispparams).lp_upp = spect_pos_upp < (*(*info).dispparams).lp_upp
					(*(*info).dataparams).lp = spect_pos > (*(*info).dispparams).lp_low < (*(*info).dispparams).lp_upp
					WIDGET_CONTROL, (*(*info).ctrlscp).lower_lp_text, SET_VALUE = STRTRIM((*(*info).dispparams).lp_low,2), SENSITIVE = 0
					WIDGET_CONTROL, (*(*info).ctrlscp).upper_lp_text, SET_VALUE = STRTRIM((*(*info).dispparams).lp_upp,2), SENSITIVE = 0
					WIDGET_CONTROL,(*(*info).ctrlscp).lp_slider,SET_SLIDER_MIN = (*(*info).dispparams).lp_low, SET_SLIDER_MAX = (*(*info).dispparams).lp_upp, SET_VALUE = (*(*info).dataparams).lp
				ENDELSE
			ENDIF
			CRISPEX_UPDATE_LP, event
		ENDELSE
		IF (loop_size GT 0) THEN (*(*(*info).loopsdata).rest_loopsize)[idx] = loop_size ELSE (*(*(*info).loopsdata).rest_loopsize)[idx] = (SIZE(loopslab))[1]
		wintitle = 'CRISPEX'+(*(*info).sesparams).instance_label+': T-slice along loop '
		CRISPEX_WINDOW, (*(*info).winsizes).restloopxres, (*(*info).winsizes).restloopyres, (*(*info).winids).root, wintitle+STRTRIM((*(*(*info).restoreparams).disp_loopnr)[idx],2), tlb, wid, $
			(*(*info).winsizes).xywinx+(*(*info).winsizes).xdelta,((*(*info).winswitch).showsp + (*(*info).winswitch).showphis) * (*(*info).winsizes).ydelta, DRAWID = disp_rest_loopdrawid, RESIZING = 1, $
			RES_HANDLER = 'CRISPEX_DISPLAYS_RESTORE_LOOPSLAB_RESIZE'
;		PLOT, FINDGEN((*(*(*info).loopsdata).rest_loopsize)[idx]), $
		PLOT, FINDGEN(N_ELEMENTS(*(*(*(*info).restoreparams).xr)[idx])), $
      *(*(*info).dispparams).tarr_main, $
      /NODATA, YR=[(*(*info).dispparams).t_low_main, (*(*info).dispparams).t_upp_main], $
			/YS, POS=[(*(*info).plotpos).restloopx0,(*(*info).plotpos).restloopy0,$
      (*(*info).plotpos).restloopx1,(*(*info).plotpos).restloopy1], $
			YTICKLEN = (*(*info).plotaxes).restloopyticklen, XTICKLEN = (*(*info).plotaxes).restloopxticklen, /XS, YTITLE = (*(*info).plottitles).spytitle, XTITLE = 'Pixel along loop',$
			BACKGROUND = (*(*info).plotparams).bgplotcol, COLOR = (*(*info).plotparams).plotcol
		IF ((*(*(*info).winids).restlooptlb)[0] NE 0) THEN BEGIN
			*(*(*info).winids).restlooptlb = [*(*(*info).winids).restlooptlb,tlb]
			*(*(*info).winids).restloopwid = [*(*(*info).winids).restloopwid,wid]
			*(*(*info).winids).restloopdrawid = [*(*(*info).winids).restloopdrawid,disp_rest_loopdrawid]
			*(*(*info).winids).restloopwintitle = [*(*(*info).winids).restloopwintitle,wintitle]
			*(*(*info).dispswitch).restricted_t_range = [*(*(*info).dispswitch).restricted_t_range,restricted_t_range]
			*(*(*info).dispswitch).restricted_lp_range = [*(*(*info).dispswitch).restricted_lp_range,restricted_lp_range]
			*(*(*info).dispswitch).restricted_lp_ref_range = [*(*(*info).dispswitch).restricted_lp_ref_range,restricted_lp_ref_range]
			*(*(*info).restoreparams).disp_slices = [*(*(*info).restoreparams).disp_slices,slice_only]
			*(*(*info).restoreparams).disp_ref_slices = [*(*(*info).restoreparams).disp_ref_slices,ref_slice_only]
		ENDIF ELSE BEGIN
			*(*(*info).winids).restlooptlb = tlb
			*(*(*info).winids).restloopwid = wid
			*(*(*info).winids).restloopdrawid = disp_rest_loopdrawid
			*(*(*info).winids).restloopwintitle = wintitle
			*(*(*info).dispswitch).restricted_t_range = restricted_t_range
			*(*(*info).dispswitch).restricted_lp_range = restricted_lp_range
			*(*(*info).dispswitch).restricted_lp_ref_range = restricted_lp_ref_range
			*(*(*info).restoreparams).disp_slices = slice_only
			*(*(*info).restoreparams).disp_ref_slices = ref_slice_only
		ENDELSE
		WIDGET_CONTROL, (*(*(*info).winids).restlooptlb)[N_ELEMENTS(*(*(*info).winids).restlooptlb)-1], SET_UVALUE = info
		IF update_t_range THEN BEGIN
			CRISPEX_DISPRANGE_T_RANGE, event
			WIDGET_CONTROL, (*(*info).ctrlscp).reset_trange_but, SENSITIVE = 0
		ENDIF
		IF update_lp_range THEN BEGIN
			CRISPEX_DISPRANGE_LP_RANGE, event
			WIDGET_CONTROL, (*(*info).ctrlscp).reset_lprange_but, SENSITIVE = 0
		ENDIF
		IF ((update_t_range EQ 0) AND (update_lp_range EQ 0) AND ~KEYWORD_SET(NO_DRAW)) THEN CRISPEX_DRAW, event
		IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [*(*(*info).winids).restlooptlb,*(*(*info).winids).restloopwid,*(*(*info).winids).restloopdrawid], $
			labels=['restlooptlb','restloopwid','restloopdrawid']
END

PRO CRISPEX_DISPLAYS_RETRIEVE_DET_LOOPSLAB_REPLOT_AXES, event
; Updates retrieved detection loopslab display window plot axes range according to set parameters
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WSET, (*(*info).winids).retrdetwid
	PLOT, FINDGEN(N_ELEMENTS((*(*(*(*info).detparams).xlr)[$
    (*(*info).detparams).idx])[*,0])), *(*(*info).dispparams).tarr_main, $
    /NODATA, YR=[(*(*info).dispparams).t_low_main, (*(*info).dispparams).t_upp_main], $
    /YS, POS=[(*(*info).plotpos).retrdetx0,(*(*info).plotpos).retrdety0,$
    (*(*info).plotpos).retrdetx1,(*(*info).plotpos).retrdety1], $
		YTICKLEN = (*(*info).plotaxes).retrdetyticklen, XTICKLEN = (*(*info).plotaxes).retrdetxticklen, /XS, YTITLE = (*(*info).plottitles).spytitle, XTITLE = 'Pixel along loop', $
		BACKGROUND = (*(*info).plotparams).bgplotcol, COLOR = (*(*info).plotparams).plotcol
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).winids).retrdetwid], labels=['Window ID for replot']
END

PRO CRISPEX_DISPLAYS_RETRIEVE_DET_LOOPSLAB_RESIZE, event	
; Retrieved detection loopslab window resize handler, gets new window dimensions and calls (re)display routines
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	CRISPEX_DISPLAYS_PLOT_RESIZE, event, event.X, event.Y, (*(*info).winsizes).retrdetxres, (*(*info).winsizes).retrdetyres, (*(*info).plotpos).retrdetxmargin_init, (*(*info).plotpos).retrdetxwall_init, $
		retrdetxres, retrdetyres, retrdetwidth, retrdetheight, retrdetx0, retrdetx1, retrdety0, $
  retrdety1, ERROR=error, /SLICE
	IF error THEN CRISPEX_DISPLAYS_RESIZE_ERROR, event ELSE BEGIN
		(*(*info).winsizes).retrdetxres = retrdetxres			& 	(*(*info).winsizes).retrdetyres = retrdetyres
		(*(*info).plotpos).retrdetx0 = retrdetx0			&	(*(*info).plotpos).retrdetx1 = retrdetx1
		(*(*info).plotpos).retrdety0 = retrdety0			&	(*(*info).plotpos).retrdety1 = retrdety1
		(*(*info).plotpos).retrdetxplspw = retrdetx1 - retrdetx0	&	(*(*info).plotpos).retrdetyplspw = retrdety1 - retrdety0
		(*(*info).plotaxes).retrdetxticklen = -1 * (*(*info).plotaxes).ticklen / retrdetheight
		(*(*info).plotaxes).retrdetyticklen = -1 * (*(*info).plotaxes).ticklen / retrdetwidth
		(*(*info).dispparams).retrdetnlxreb = (*(*info).plotpos).retrdetxplspw * (*(*info).winsizes).retrdetxres 
		(*(*info).dispparams).retrdetntreb = (*(*info).plotpos).retrdetyplspw * (*(*info).winsizes).retrdetyres 
	ENDELSE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [error,(*(*info).winsizes).loopxres,(*(*info).winsizes).loopyres,(*(*info).plotpos).loopx0,(*(*info).plotpos).loopx1,$
		(*(*info).plotpos).loopy0,(*(*info).plotpos).loopy1], labels=['error','loopxres','loopyres','loopx0','loopx1','loopy0','loopy1']
	WIDGET_CONTROL, (*(*info).winids).retrdetdrawid, DRAW_XSIZE = (*(*info).winsizes).retrdetxres, DRAW_YSIZE = (*(*info).winsizes).retrdetyres
	WIDGET_CONTROL, event.TOP, SET_UVALUE = info
	CRISPEX_DISPLAYS_RETRIEVE_DET_LOOPSLAB_REPLOT_AXES, event
	CRISPEX_DRAW_RETR_DET, event
END

PRO CRISPEX_DISPLAYS_RETRIEVE_DET_LOOPSLAB, event, NO_DRAW=no_draw
; Retrieved detection loopslab display window creation procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	IF ~KEYWORD_SET(NO_DRAW) THEN (*(*info).detparams).idx = event.INDEX-1
	IF ((*(*info).detparams).idx GE 0) THEN BEGIN
    ; If a detection is already being displayed, close that window
		IF ((*(*info).winids).retrdettlb GT 0) THEN $
      WIDGET_CONTROL, (*(*info).winids).retrdettlb, /DESTROY
		(*(*info).winswitch).showretrdet = 1
		WIDGET_CONTROL,/HOURGLASS
    ; Gather input parameters
    maxpass = ((*(*info).detparams).lp_up-(*(*info).detparams).lp_dn+1) * $
      (*(*info).detparams).width
    t_0 = SYSTIME(/SECONDS)
    inparams = {xlp:*(*(*(*info).detparams).xlp)[(*(*info).detparams).idx], $
      ylp:*(*(*(*info).detparams).ylp)[(*(*info).detparams).idx], $
      xlr:*(*(*(*info).detparams).xlr)[(*(*info).detparams).idx], $
      ylr:*(*(*(*info).detparams).ylr)[(*(*info).detparams).idx], $
      nx:(*(*info).dataparams).nx, ny:(*(*info).dataparams).ny, $
      lp_dn:(*(*info).detparams).lp_dn, lp_up:(*(*info).detparams).lp_up, $
      no_nlp:((*(*info).dataparams).nlp LE 1), idx:(*(*info).detparams).idx, $
      detimref:1, data:(*(*info).data).imagedata, t_0:t_0, maxpass:maxpass}
    ; Get the detection slab
		CRISPEX_RETRIEVE_DET_GET_SLAB, event, inparams, w_lpts_out, gapresult_out, $
      loopslab_out, crossloc_out, loopsize_out, t_det_out, t_low_out, $
      t_upp_out
    (*(*info).detparams).ngaps = gapresult_out.ngaps
    *(*(*info).detparams).databounds = gapresult_out.databounds
    *(*(*info).detparams).wdatabounds = gapresult_out.wdatabounds
	  *(*(*info).loopsdata).det_loopslab = loopslab_out
	  *(*(*info).loopsdata).det_crossloc = crossloc_out
	  (*(*info).loopsdata).det_loopsize = loopsize_out
    (*(*info).dispparams).t_low = t_low_out
    (*(*info).dispparams).t_upp = t_upp_out
    (*(*info).dispparams).t = t_det_out
		IF ~KEYWORD_SET(NO_DRAW) THEN CRISPEX_UPDATE_LP, event
    ; Set window title and create window
		title = 'CRISPEX'+(*(*info).sesparams).instance_label+$
      ': T-slice along detection '
		CRISPEX_WINDOW, (*(*info).winsizes).retrdetxres, $
      (*(*info).winsizes).retrdetyres, (*(*info).winids).root, $
      title+STRTRIM((*(*info).detparams).idx,2), tlb, wid, $
			(*(*info).winsizes).xywinx+(*(*info).winsizes).xdelta,$
      ((*(*info).winswitch).showsp + (*(*info).winswitch).showphis) * $
      (*(*info).winsizes).ydelta, DRAWID = disp_retr_detdrawid, RESIZING = 1, $
			RES_HANDLER = 'CRISPEX_DISPLAYS_RETRIEVE_DET_LOOPSLAB_RESIZE'
    ; Plot basic axes box
		PLOT, FINDGEN(N_ELEMENTS((*(*(*(*info).detparams).xlr)[$
      (*(*info).detparams).idx])[*,0])), *(*(*info).dispparams).tarr_main, $
      /NODATA, YR=[(*(*info).dispparams).t_low_main, $
      (*(*info).dispparams).t_upp_main], $
      /YS, POS=[(*(*info).plotpos).retrdetx0,(*(*info).plotpos).retrdety0,$
      (*(*info).plotpos).retrdetx1,(*(*info).plotpos).retrdety1], $
			YTICKLEN = (*(*info).plotaxes).retrdetyticklen, $
      XTICKLEN = (*(*info).plotaxes).retrdetxticklen, /XS, $
      YTITLE = (*(*info).plottitles).spytitle, XTITLE = 'Pixel along loop', $
			BACKGROUND = (*(*info).plotparams).bgplotcol, $
      COLOR = (*(*info).plotparams).plotcol
		(*(*info).winids).retrdettlb = tlb	
    (*(*info).winids).retrdetwid = wid	
    (*(*info).winids).retrdetdrawid = disp_retr_detdrawid
		(*(*info).winids).retrdetwintitle = title
    ; Pass on the info pointer
		WIDGET_CONTROL, (*(*info).winids).retrdettlb, SET_UVALUE = info
    ; Adjust temporal range depending on the selected detection and delta time
		IF ~KEYWORD_SET(NO_DRAW) THEN CRISPEX_DISPRANGE_T_RANGE, event
		WIDGET_CONTROL, (*(*info).ctrlscp).lower_t_text, $
      SET_VALUE=STRTRIM((*(*info).dispparams).t_low,2), SENSITIVE=0
		WIDGET_CONTROL, (*(*info).ctrlscp).upper_t_text, $
      SET_VALUE=STRTRIM((*(*info).dispparams).t_upp,2), SENSITIVE=0 
	ENDIF ELSE BEGIN
		IF (*(*info).winswitch).showretrdet THEN BEGIN
			(*(*info).winswitch).showretrdet = 0
			WIDGET_CONTROL, (*(*info).winids).retrdettlb, /DESTROY
			(*(*info).winids).retrdettlb = 0
		ENDIF
	ENDELSE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).winids).retrdettlb,$
      (*(*info).winids).retrdetwid,(*(*info).winids).retrdetdrawid], $
	  	labels=['retrdettlb','retrdetwid','retrdetdrawid']
END
	
PRO CRISPEX_DISPLAYS_REFLS_RESIZE, event							
; Detailed spectrum window resize handler, gets new window dimensions and calls (re)display routines
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	CRISPEX_DISPLAYS_PLOT_RESIZE, event, event.X, event.Y, (*(*info).winsizes).reflsxres, $
    (*(*info).winsizes).reflsyres, (*(*info).plotpos).reflsxmargin_init, $
    (*(*info).plotpos).reflsxwall_init, reflsxres, reflsyres, reflswidth, reflsheight, $
    reflsx0, reflsx1, reflsy0, reflsy1, (*(*info).plotswitch).v_dop_set_ref, ERROR=error
	IF error THEN CRISPEX_DISPLAYS_RESIZE_ERROR, event ELSE BEGIN
		(*(*info).winsizes).reflsxres = reflsxres	& 	(*(*info).winsizes).reflsyres = reflsyres
		(*(*info).plotpos).reflsx0 = reflsx0		&	(*(*info).plotpos).reflsx1 = reflsx1
		(*(*info).plotpos).reflsy0 = reflsy0		&	(*(*info).plotpos).reflsy1 = reflsy1
		(*(*info).plotaxes).reflsxticklen = (*(*info).plotaxes).ticklen / reflsheight
		(*(*info).plotaxes).reflsyticklen = (*(*info).plotaxes).ticklen / reflswidth
	ENDELSE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [error,(*(*info).winsizes).reflsxres,(*(*info).winsizes).reflsyres,(*(*info).plotpos).reflsx0,(*(*info).plotpos).reflsx1,$
		(*(*info).plotpos).reflsy0,(*(*info).plotpos).reflsy1], labels=['error','reflsxres','reflsyres','reflsx0','reflsx1','reflsy0','reflsy1']
	WIDGET_CONTROL, (*(*info).winids).reflsdrawid, DRAW_XSIZE = (*(*info).winsizes).reflsxres, DRAW_YSIZE = (*(*info).winsizes).reflsyres
	WIDGET_CONTROL, event.TOP, SET_UVALUE = info
  CRISPEX_DRAW_SPECTRAL_REF, event, /LS_ONLY
END

PRO CRISPEX_DISPLAYS_REFSP_REPLOT_AXES, event, NO_AXES=no_axes
; Updates reference temporal spectrum display window plot axes range according to set parameters
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WSET, (*(*info).winids).refspwid
  ; Set axes parameters depending on # of diagnostics
  IF ((*(*info).intparams).ndisp_refdiagnostics GT 1) THEN BEGIN
    xticklen = 1E-9   & xtitle = ''
    xtickname = REPLICATE(' ',60)
    xtlen_basic_fac = 0.5
    xtlen_major_fac = 0.8
    IF KEYWORD_SET(NO_AXES) THEN BEGIN
      yticklen = 1E-9 & ytitle = ''
      ytickname = REPLICATE(' ',60)
    ENDIF ELSE BEGIN
      yticklen = (*(*info).plotaxes).refspyticklen
      ytitle = (*(*info).plottitles).spytitle
      ytickname = ''
    ENDELSE
  ENDIF ELSE BEGIN
    xticklen = (*(*info).plotaxes).refspxticklen
    xtitle = (*(*info).plottitles).refspxtitle
    yticklen = (*(*info).plotaxes).refspyticklen
    ytitle = (*(*info).plottitles).spytitle
    xtlen_basic_fac = 1.
    xtickname = ''  & ytickname = ''
  ENDELSE
  xticklen = xtlen_basic_fac * (*(*info).plotaxes).spxticklen
  t_low_y = (*(*info).dispparams).t_low_ref
  t_upp_y = (*(*info).dispparams).t_upp_ref
  xrange = [(*(*info).dataparams).reflps[(*(*info).dispparams).lp_ref_low], $
            (*(*info).dataparams).reflps[(*(*info).dispparams).lp_ref_upp]]
  correct_axes = (FLOOR(ALOG10(ABS(t_upp_y))) GE 3)
  IF ((t_low_y NE 0.) AND ~KEYWORD_SET(correct_axes)) THEN $
    correct_axes = (FLOOR(ALOG10(ABS(t_low_y))) LE -2) 
  IF correct_axes THEN BEGIN
 	  order_corr = FLOOR(ALOG10(ABS(t_upp_y)))
 	  IF ~KEYWORD_SET(NO_AXES) THEN ytitle += ' (x10!U'+STRTRIM(order_corr,2)+'!N)'
    t_low_y /= (10.^(order_corr))
    t_upp_y /= (10.^(order_corr))
  ENDIF 
  IF (*(*info).plotswitch).v_dop_set_ref THEN topxtitle = 'Doppler velocity [km/s]'
  ; Plot basic axes box
  PLOT, (*(*info).dataparams).lps, *(*(*info).dispparams).tarr_ref, $
    YR = [t_low_y,t_upp_y], /YS, XR=xrange, $
    XSTYLE = (*(*info).plotswitch).v_dop_set_ref * 8 + 1, $
  	YTICKLEN = yticklen, YTITLE = ytitle, YTICKNAME = ytickname, $
    XTICKLEN = 1E-9, XTITLE = xtitle, XTICKNAME = REPLICATE(' ',60), $
    POS = [(*(*info).plotpos).refspx0,(*(*info).plotpos).refspy0,(*(*info).plotpos).refspx1,$
    (*(*info).plotpos).refspy1], BACKGROUND=(*(*info).plotparams).bgplotcol, $
    COLOR=(*(*info).plotparams).plotcol, /NODATA, NOERASE=KEYWORD_SET(NO_AXES)
  ; In case of multiple diagnostics and regular replotting of axes
  ; Determine proportional spectral window sizes
  diag_widths = (*(*info).intparams).refdiag_width[$
    WHERE((*(*info).intparams).disp_refdiagnostics EQ 1)]
  diag_ratio = diag_widths / FLOAT(TOTAL(diag_widths))
  diag_range = diag_ratio * (*(*info).plotpos).refxplspw
  IF ~KEYWORD_SET(NO_AXES) THEN BEGIN
    ; Plot xtitle(s)
    IF ((*(*info).intparams).ndisp_refdiagnostics GT 1) THEN $
      XYOUTS,(*(*info).plotpos).refxplspw/2.+(*(*info).plotpos).refspx0,$
        (*(*info).plotpos).refspy0/3.,(*(*info).plottitles).refspxtitle,ALIGNMENT=0.5,$
        COLOR = (*(*info).plotparams).plotcol,/NORMAL
    ; Loop over all diagnostics for plotting of axes boxes
    FOR d=0,(*(*info).intparams).ndisp_refdiagnostics-1 DO BEGIN
      disp_idx = (WHERE((*(*info).intparams).disp_refdiagnostics EQ 1))[d]
      ; Determine xrange to display
      IF ((*(*info).intparams).nrefdiagnostics GT 1) THEN BEGIN
        xrange = (*(*info).dataparams).reflps[[(*(*info).intparams).refdiag_start[disp_idx],$
          ((*(*info).intparams).refdiag_start[disp_idx]+(*(*info).intparams).refdiag_width[disp_idx]-1)]]
        vdop_xrange = (*(*(*info).plotaxes).v_dop_ref[disp_idx])[[0,diag_widths[d]-1]]
      ENDIF ELSE $
        vdop_xrange = (*(*(*info).plotaxes).v_dop_ref[0])[$
          [(*(*info).dispparams).lp_ref_low,(*(*info).dispparams).lp_ref_upp]]
      IF (d EQ 0) THEN offset = 0 ELSE offset = TOTAL(diag_range[0:(d-1)])
      ; Determine lower left corner position of plot
      refspx0 = (*(*info).plotpos).refspx0 + offset
      refspx1 = diag_range[d] + refspx0
      PLOT, (*(*info).dataparams).lps, *(*(*info).dispparams).tarr_ref, $
        /NODATA, YR=[t_low_y,t_upp_y], /YS, $
  			XRANGE=xrange, XSTYLE = (*(*info).plotswitch).v_dop_set_ref * 8 + 1, $
        POS = [refspx0,(*(*info).plotpos).refspy0,refspx1,(*(*info).plotpos).refspy1], $
        YTICKLEN=(*(*info).plotaxes).refspyticklen, $
        XTICKLEN=xticklen, YTICKNAME=REPLICATE(' ',60), XTICKNAME=xtickname, $
        XTICKINTERVAL=(*(*(*info).plotaxes).xreftickinterval)[0], $
        BACKGROUND = (*(*info).plotparams).bgplotcol, COLOR = (*(*info).plotparams).plotcol,$
        /NOERASE, XTICK_GET=xtickvals, $
        XMINOR=(0-((*(*info).intparams).ndisp_refdiagnostics GT 1))
      ; In case of multiple diagnostics
      IF ((*(*info).intparams).ndisp_refdiagnostics GT 1) THEN BEGIN
        ; Redraw x-axis with custom labelling
        IF (*(*info).plotswitch).xreftick_reset THEN BEGIN
          (*(*info).plotaxes).xreftickvals[d] = $
            PTR_NEW(CRISPEX_PLOTAXES_XTICKVALS_SELECT(xtickvals, $
            TICKSEP=(*(*(*info).plotaxes).xreftickinterval)[1]))
          IF (d EQ ((*(*info).intparams).ndisp_refdiagnostics-1)) THEN $
            (*(*info).plotswitch).xreftick_reset = 0
        ENDIF
        wherenonempty = WHERE(*(*(*info).plotaxes).xreftickvals[d] NE ' ', count)
        IF (count GT 0) THEN BEGIN
          FOR k=0,N_ELEMENTS(wherenonempty)-1 DO BEGIN
            PLOTS,[1.,1.]*FLOAT((*(*(*info).plotaxes).xreftickvals[d])[wherenonempty[k]]), $
              [t_low_y,xtlen_major_fac*(t_upp_y-t_low_y)*(*(*info).plotaxes).refspxticklen+$
              t_low_y], $
              COLOR=(*(*info).plotparams).plotcol
          ENDFOR
        ENDIF
        AXIS, XAXIS=0, XTICKLEN=xtlen_basic_fac*(*(*info).plotaxes).refspxticklen, $
          XRANGE=xrange, /XS, $
          XTICKNAME=*(*(*info).plotaxes).xreftickvals[d], XMINOR=-1, $
          COLOR=(*(*info).plotparams).plotcol, $
          XTICKINTERVAL=(*(*(*info).plotaxes).xreftickinterval)[0]
      ENDIF
      ; Display Doppler top axis if Doppler set, else regular top axis
  		IF ((*(*info).plotswitch).v_dop_set_ref EQ 1) THEN BEGIN
        IF (d EQ 0) THEN $
          XYOUTS,((*(*info).plotpos).refspx1-(*(*info).plotpos).refspx0)/2.+$
            (*(*info).plotpos).refspx0,$
            (*(*info).plotpos).refspy0/5.*3+(*(*info).plotpos).refspy1, topxtitle, $
            ALIGNMENT=0.5, COLOR = (*(*info).plotparams).plotcol,/NORMAL
        topxtitle = ''
        ;Draw top axis
        IF ((*(*info).intparams).ndisp_refdiagnostics GT 1) THEN BEGIN
          ; Plot the initial tick marks and get the tick vals
          AXIS, XAXIS=1, XRANGE=vdop_xrange, $
            XSTYLE=1, XTITLE = topxtitle, COLOR = (*(*info).plotparams).plotcol,$
            XTICKINTERVAL=(*(*(*info).plotaxes).xrefdoptickinterval)[0], $
            XTICKNAME=REPLICATE(' ',60), $
            XTICK_GET=xdoptickvals, XTICKLEN=1E-9
          ; Redraw x-axis with custom labelling
          IF (*(*info).plotswitch).xrefdoptick_reset THEN BEGIN
            (*(*info).plotaxes).xrefdoptickvals[d] = $
              PTR_NEW(CRISPEX_PLOTAXES_XTICKVALS_SELECT(xdoptickvals, $
              TICKSEP=(*(*(*info).plotaxes).xrefdoptickinterval)[1],$
              /DOPPLER))
            wherenonempty = WHERE(*(*(*info).plotaxes).xrefdoptickvals[d] NE ' ')
            ; Determine Doppler tick mark locations
            (*(*info).plotaxes).xrefdoptickloc[d] = $
              PTR_NEW(CRISPEX_PLOTAXES_XDOPTICKLOC(xdoptickvals, wherenonempty, $
              vdop_xrange, xrange))
            IF (d EQ ((*(*info).intparams).ndisp_refdiagnostics-1)) THEN $
              (*(*info).plotswitch).xrefdoptick_reset = 0
          ENDIF
          FOR k=0,N_ELEMENTS(*(*(*info).plotaxes).xrefdoptickloc[d])-1 DO BEGIN
            PLOTS,[1.,1.]*(*(*(*info).plotaxes).xrefdoptickloc[d])[k], $
              [t_upp_y,-xtlen_major_fac*(*(*info).plotaxes).refspxticklen*(t_upp_y-t_low_y)+$
              t_upp_y], $
              COLOR=(*(*info).plotparams).plotcol
          ENDFOR
          ; Add the labels
          AXIS, XAXIS=1, XRANGE=vdop_xrange, /XS, $
            XTICKNAME=*(*(*info).plotaxes).xrefdoptickvals[d], $
            COLOR=(*(*info).plotparams).plotcol, $
            XTICKLEN=xtlen_basic_fac*(*(*info).plotaxes).refspxticklen, $
            XTICKINTERVAL=(*(*(*info).plotaxes).xrefdoptickinterval)[0], XMINOR=-1
        ENDIF ELSE $
          ; Else plot Doppler axis with automatic tick mark settings
        	AXIS, XAXIS=1, XTICKLEN=(*(*info).plotaxes).refspxticklen, XRANGE=vdop_xrange, $
            XSTYLE=1, XTITLE=topxtitle, COLOR = (*(*info).plotparams).plotcol
      ENDIF ELSE $
  			AXIS, XAXIS=1, XTICKLEN = (*(*info).plotaxes).refspxticklen, XRANGE = xrange, XSTYLE=1, $
          XTITLE = topxtitle, COLOR = (*(*info).plotparams).plotcol, $
          XTICKNAME=REPLICATE(' ',60)
    ENDFOR
  ENDIF
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).winids).refspwid], labels=['Window ID for replot']
END

PRO CRISPEX_DISPLAYS_REFSP_RESIZE, event
; Reference temporal spectrum window resize handler, gets new window dimensions and calls (re)display routines
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	CRISPEX_DISPLAYS_PLOT_RESIZE, event, event.X, event.Y, (*(*info).winsizes).refspxres, (*(*info).winsizes).refspyres, (*(*info).plotpos).refspxmargin_init, (*(*info).plotpos).refspxwall_init, $
		refspxres, refspyres, refspwidth, refspheight, refspx0, refspx1, refspy0, refspy1, $
  (*(*info).plotswitch).v_dop_set_ref, ERROR=error, /SLICE
	IF error THEN CRISPEX_DISPLAYS_RESIZE_ERROR, event ELSE BEGIN
		(*(*info).winsizes).refspxres = refspxres		& 	(*(*info).winsizes).refspyres = refspyres
		(*(*info).plotpos).refspx0 = refspx0			&	(*(*info).plotpos).refspx1 = refspx1
		(*(*info).plotpos).refspy0 = refspy0			&	(*(*info).plotpos).refspy1 = refspy1
		(*(*info).plotpos).refxplspw = refspx1 - refspx0	&	(*(*info).plotpos).refyplspw = refspy1 - refspy0
		(*(*info).plotaxes).refspxticklen = -1 * (*(*info).plotaxes).ticklen / refspheight
		(*(*info).plotaxes).refspyticklen = -1 * (*(*info).plotaxes).ticklen / refspwidth
		(*(*info).dispparams).refnlpreb = (*(*info).plotpos).refxplspw * (*(*info).winsizes).refspxres 
		(*(*info).dispparams).refntreb = (*(*info).plotpos).refyplspw * (*(*info).winsizes).refspyres 
	ENDELSE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [error, (*(*info).winsizes).refspxres,(*(*info).winsizes).refspyres,(*(*info).plotpos).refspx0,(*(*info).plotpos).refspx1,$
		(*(*info).plotpos).refspy0,(*(*info).plotpos).refspy1], labels=['error','refspxres','refspyres','refspx0','refspx1','refspy0','refspy1']
	WIDGET_CONTROL, (*(*info).winids).refspdrawid, DRAW_XSIZE = (*(*info).winsizes).refspxres, DRAW_YSIZE = (*(*info).winsizes).refspyres
	WIDGET_CONTROL, event.TOP, SET_UVALUE = info
	CRISPEX_DISPLAYS_REFSP_REPLOT_AXES, event
  *(*(*info).data).refspslice_congrid = CONGRID( *(*(*info).data).refspslice, $
    (*(*info).dispparams).refnlpreb, (*(*info).dispparams).refntreb, $
    INTERP=(*(*info).dispparams).interpspslice, /CENTER)
  CRISPEX_DRAW_SPECTRAL_REF, event, /SP_ONLY
END

PRO CRISPEX_DISPLAYS_REFSP_TOGGLE, event, NO_DRAW=no_draw
; Reference temporal spectrum display window creation procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event, /IGNORE_LAST
  ; If window doesn't exist, create it
	IF ((*(*info).winswitch).showrefsp EQ 0) THEN BEGIN
		title = 'CRISPEX'+(*(*info).sesparams).instance_label+': '+$
      ((*(*info).plottitles).refspwintitle)[(*(*info).plotswitch).refheightset]
    ; Create window
		CRISPEX_WINDOW, (*(*info).winsizes).refspxres, (*(*info).winsizes).refspyres, $
      (*(*info).winids).root, title, refsptlb, refspwid, $
      (*(*info).winsizes).refspxoffset, (*(*info).winsizes).refspyoffset, $
      DRAWID = refspdrawid, RESIZING = 1, RES_HANDLER = 'CRISPEX_DISPLAYS_REFSP_RESIZE'
    ; Save window variables
		(*(*info).winids).refsptlb = refsptlb		&	(*(*info).winids).refspwid = refspwid	&	(*(*info).winswitch).showrefsp = 1
		(*(*info).winids).refspdrawid = refspdrawid	&	(*(*info).winids).refspwintitle = title 
		WIDGET_CONTROL, (*(*info).winids).refsptlb, SET_UVALUE = info
    ; Fill window
    CRISPEX_DISPLAYS_REFSP_REPLOT_AXES, event
    CRISPEX_UPDATE_REFSPSLICE, event
		IF ~KEYWORD_SET(NO_DRAW) THEN CRISPEX_DRAW_SPECTRAL_REF, event, /SP_ONLY
  ; If window exists, destroy it
	ENDIF ELSE BEGIN
		WIDGET_CONTROL, (*(*info).winids).refsptlb, /DESTROY
		(*(*info).winids).refsptlb = 0
		(*(*info).winswitch).showrefsp = 0
	ENDELSE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).winids).refsptlb,(*(*info).winids).refspwid,$
      (*(*info).winids).refspdrawid], labels=['refsptlb','refspwid','refspdrawid']
END

PRO CRISPEX_DISPLAYS_SJI_TOGGLE, event, NO_DRAW=no_draw
; Reference image window creation procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event, /IGNORE_LAST
	(*(*info).winswitch).showsji = event.SELECT
	IF (*(*info).winswitch).showsji THEN BEGIN
		title = 'CRISPEX'+(*(*info).sesparams).instance_label+': Slit-jaw image'
		CRISPEX_WINDOW, (*(*info).winsizes).sjiwinx, (*(*info).winsizes).sjiwiny, $
      (*(*info).winids).root, title, sjitlb, sjiwid, $
      (*(*info).winsizes).sjixoffset, (*(*info).winsizes).sjiyoffset,$
      DRAWID = sjidrawid, DRAWBASE = sjidrawbase, $
      /SCROLL, XSCROLL=xscroll, YSCROLL=yscroll, /SJI
    (*(*info).ctrlssji).xsjipos_slider = xscroll
    (*(*info).ctrlssji).ysjipos_slider = yscroll
    WIDGET_CONTROL, (*(*info).ctrlssji).xsjipos_slider, $
      SET_VALUE=(*(*info).zooming).xsjipos, SENSITIVE=((*(*info).zooming).factor NE 1)
    WIDGET_CONTROL, (*(*info).ctrlssji).ysjipos_slider, $
      SET_VALUE=(*(*info).zooming).ysjipos, SENSITIVE=((*(*info).zooming).factor NE 1)
		(*(*info).winids).sjitlb = sjitlb		&	(*(*info).winids).sjiwid = sjiwid	
    (*(*info).winids).sjidrawid = sjidrawid
		(*(*info).winids).sjidrawbase = sjidrawbase	&	(*(*info).winids).sjiwintitle = title
		IF ~KEYWORD_SET(NO_DRAW) THEN BEGIN
			CRISPEX_UPDATE_T, event
			CRISPEX_DRAW_SJI, event
		ENDIF
    WIDGET_CONTROL, sjitlb, SET_UVALUE=info
	ENDIF ELSE BEGIN
		WIDGET_CONTROL, (*(*info).winids).sjitlb, /DESTROY
		(*(*info).winids).sjitlb = 0
	ENDELSE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).winids).sjitlb,(*(*info).winids).sjiwid,$
      (*(*info).winids).sjidrawid], labels=['sjitlb','sjiwid','sjidrawid']
END

PRO CRISPEX_DISPLAYS_SP_REPLOT_AXES, event, NO_AXES=no_axes
; Updates temporal spectrum display window plot axes range according to set parameters
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WSET, (*(*info).winids).spwid
	IF (*(*info).plotswitch).v_dop_set THEN extratitle = '!C' ELSE extratitle = ''
	IF (*(*info).plotswitch).multichannel THEN $
    title = 'Stokes '+((*(*info).stokesparams).labels)[(*(*info).dataparams).s]+extratitle $
  ELSE $
    title = ''
  ; Set axes parameters depending on # of diagnostics
  IF ((*(*info).intparams).ndisp_diagnostics GT 1) THEN BEGIN
    xticklen = 1E-9   & xtitle = ''
    xtickname = REPLICATE(' ',60)
    xtlen_basic_fac = 0.5
    xtlen_major_fac = 0.8
    IF KEYWORD_SET(NO_AXES) THEN BEGIN
      yticklen = 1E-9 & ytitle = ''
      ytickname = REPLICATE(' ',60)
    ENDIF ELSE BEGIN
      yticklen = (*(*info).plotaxes).spyticklen
      ytitle = (*(*info).plottitles).spytitle
      ytickname = ''
    ENDELSE
  ENDIF ELSE BEGIN
    xticklen = (*(*info).plotaxes).spxticklen
    xtitle = (*(*info).plottitles).spxtitle
    yticklen = (*(*info).plotaxes).spyticklen
    ytitle = (*(*info).plottitles).spytitle
    xtlen_basic_fac = 1.
    xtickname = ''  & ytickname = ''
  ENDELSE
  xticklen = xtlen_basic_fac * (*(*info).plotaxes).spxticklen
  t_low_y = (*(*info).dispparams).t_low_main
  t_upp_y = (*(*info).dispparams).t_upp_main
  xrange = [(*(*info).dataparams).lps[(*(*info).dispparams).lp_low], $
            (*(*info).dataparams).lps[(*(*info).dispparams).lp_upp]]
  correct_axes = (FLOOR(ALOG10(ABS(t_upp_y))) GE 3)
  IF ((t_low_y NE 0.) AND ~KEYWORD_SET(correct_axes)) THEN $
    correct_axes = (FLOOR(ALOG10(ABS(t_low_y))) LE -2) 
  IF correct_axes THEN BEGIN
 	  order_corr = FLOOR(ALOG10(ABS(t_upp_y)))
 	  IF ~KEYWORD_SET(NO_AXES) THEN ytitle += ' (x10!U'+STRTRIM(order_corr,2)+'!N)'
    t_low_y /= (10.^(order_corr))
    t_upp_y /= (10.^(order_corr))
  ENDIF 
  topxtitle = title
  IF (*(*info).plotswitch).v_dop_set THEN topxtitle += 'Doppler velocity [km/s]'
  ; Plot basic axes box
  PLOT, (*(*info).dataparams).lps, *(*(*info).dispparams).tarr_main, $
    YR = [t_low_y,t_upp_y], /YS, XR=xrange, $
    XSTYLE = (*(*info).plotswitch).v_dop_set * 8 + 1, $
  	YTICKLEN = yticklen, YTITLE = ytitle, YTICKNAME = ytickname, $
    XTICKLEN = 1E-9, XTITLE = xtitle, XTICKNAME = REPLICATE(' ',60), $
    POS = [(*(*info).plotpos).spx0,(*(*info).plotpos).spy0,$
           (*(*info).plotpos).spx1,(*(*info).plotpos).spy1], $
    BACKGROUND=(*(*info).plotparams).bgplotcol, COLOR=(*(*info).plotparams).plotcol, $
    /NODATA, NOERASE=KEYWORD_SET(NO_AXES)
  ; In case of multiple diagnostics and regular replotting of axes
  IF ~KEYWORD_SET(NO_AXES) THEN BEGIN
    ; Determine proportional spectral window sizes
    diag_widths = (*(*info).intparams).diag_width[$
      WHERE((*(*info).intparams).disp_diagnostics EQ 1)]
    diag_ratio = diag_widths / FLOAT(TOTAL(diag_widths))
    diag_range = diag_ratio * (*(*info).plotpos).xplspw 
    ; Plot xtitle(s)
    IF ((*(*info).intparams).ndisp_diagnostics GT 1) THEN $
      XYOUTS,(*(*info).plotpos).xplspw/2.+(*(*info).plotpos).spx0,$
        (*(*info).plotpos).spy0/3.,(*(*info).plottitles).spxtitle,ALIGNMENT=0.5, $
        COLOR = (*(*info).plotparams).plotcol,/NORMAL
    ; Loop over all diagnostics for plotting of axes boxes
    FOR d=0,(*(*info).intparams).ndisp_diagnostics-1 DO BEGIN
      disp_idx = (WHERE((*(*info).intparams).disp_diagnostics EQ 1))[d]
      ; Determine xrange to display
      IF ((*(*info).intparams).ndiagnostics GT 1) THEN BEGIN
        xrange = (*(*info).dataparams).lps[[(*(*info).intparams).diag_start[disp_idx],$
          ((*(*info).intparams).diag_start[disp_idx]+(*(*info).intparams).diag_width[disp_idx]-1)]]
        vdop_xrange = (*(*(*info).plotaxes).v_dop[disp_idx])[[0,diag_widths[d]-1]]
      ENDIF ELSE $
        vdop_xrange = (*(*(*info).plotaxes).v_dop[0])[$
          [(*(*info).dispparams).lp_low,(*(*info).dispparams).lp_upp]]
      IF (d EQ 0) THEN offset = 0 ELSE offset = TOTAL(diag_range[0:(d-1)])
      ; Determine lower left corner position of plot
      spx0 = (*(*info).plotpos).spx0 + offset
      spx1 = diag_range[d] + spx0
  		PLOT, (*(*info).dataparams).lps, *(*(*info).dispparams).tarr_main, $
        /NODATA, YR=[t_low_y,t_upp_y], $
  			/YS, XRANGE=xrange, XSTYLE = (*(*info).plotswitch).v_dop_set * 8 + 1, $
        POS = [spx0,(*(*info).plotpos).spy0,spx1,(*(*info).plotpos).spy1], $
        YTICKLEN=(*(*info).plotaxes).spyticklen, $
        XTICKLEN=xticklen, YTICKNAME=REPLICATE(' ',60), XTICKNAME=xtickname, $
        XTICKINTERVAL=(*(*(*info).plotaxes).xtickinterval)[0], $
        BACKGROUND = (*(*info).plotparams).bgplotcol, COLOR = (*(*info).plotparams).plotcol,$
        /NOERASE, XTICK_GET=xtickvals, $
        XMINOR=(0-((*(*info).intparams).ndisp_diagnostics GT 1))
      ; In case of multiple diagnostics
      IF ((*(*info).intparams).ndisp_diagnostics GT 1) THEN BEGIN
        ; Redraw x-axis with custom labelling
        IF (*(*info).plotswitch).xtick_reset THEN BEGIN
          (*(*info).plotaxes).xtickvals[d] = $
            PTR_NEW(CRISPEX_PLOTAXES_XTICKVALS_SELECT(xtickvals, $
            TICKSEP=(*(*(*info).plotaxes).xtickinterval)[1]))
          IF (d EQ ((*(*info).intparams).ndisp_diagnostics-1)) THEN $
            (*(*info).plotswitch).xtick_reset = 0
        ENDIF
        wherenonempty = WHERE(*(*(*info).plotaxes).xtickvals[d] NE ' ', count)
        IF (count GT 0) THEN BEGIN
          FOR k=0,N_ELEMENTS(wherenonempty)-1 DO BEGIN
            PLOTS,[1.,1.]*FLOAT((*(*(*info).plotaxes).xtickvals[d])[wherenonempty[k]]), $
              [t_low_y,xtlen_major_fac*(t_upp_y-t_low_y)*(*(*info).plotaxes).spxticklen+$
              t_low_y], $
              COLOR=(*(*info).plotparams).plotcol
          ENDFOR
        ENDIF
        AXIS, XAXIS=0, XTICKLEN=xtlen_basic_fac*(*(*info).plotaxes).spxticklen, $
          XRANGE=xrange, /XS, $
          XTICKNAME=*(*(*info).plotaxes).xtickvals[d], XMINOR=-1, $
          COLOR=(*(*info).plotparams).plotcol, $
          XTICKINTERVAL=(*(*(*info).plotaxes).xtickinterval)[0]
      ENDIF
      ; Display Doppler top axis if Doppler set, else regular top axis
  		IF ((*(*info).plotswitch).v_dop_set EQ 1) THEN BEGIN
        IF (d EQ 0) THEN $
          XYOUTS,((*(*info).plotpos).spx1-(*(*info).plotpos).spx0)/2.+$
            (*(*info).plotpos).spx0,$
            (*(*info).plotpos).spy0/5.*3+(*(*info).plotpos).spy1, topxtitle, $
            ALIGNMENT=0.5, COLOR = (*(*info).plotparams).plotcol,/NORMAL
        topxtitle = ''
        ;Draw top axis
        IF ((*(*info).intparams).ndisp_diagnostics GT 1) THEN BEGIN
          ; Plot the initial tick marks and get the tick vals
          AXIS, XAXIS=1, XRANGE=vdop_xrange, $
            XSTYLE=1, XTITLE = topxtitle, COLOR = (*(*info).plotparams).plotcol,$
            XTICKINTERVAL=(*(*(*info).plotaxes).xdoptickinterval)[0], XTICKNAME=REPLICATE(' ',60), $
            XTICK_GET=xdoptickvals, XTICKLEN=1E-9
          ; Redraw x-axis with custom labelling
          IF (*(*info).plotswitch).xdoptick_reset THEN BEGIN
            (*(*info).plotaxes).xdoptickvals[d] = $
              PTR_NEW(CRISPEX_PLOTAXES_XTICKVALS_SELECT(xdoptickvals, $
              TICKSEP=(*(*(*info).plotaxes).xdoptickinterval)[1],$
              /DOPPLER))
            wherenonempty = WHERE(*(*(*info).plotaxes).xdoptickvals[d] NE ' ')
            ; Determine Doppler tick mark locations
            (*(*info).plotaxes).xdoptickloc[d] = $
              PTR_NEW(CRISPEX_PLOTAXES_XDOPTICKLOC(xdoptickvals, wherenonempty, $
              vdop_xrange, xrange))
            IF (d EQ ((*(*info).intparams).ndisp_diagnostics-1)) THEN $
              (*(*info).plotswitch).xdoptick_reset = 0
          ENDIF
          FOR k=0,N_ELEMENTS(*(*(*info).plotaxes).xdoptickloc[d])-1 DO BEGIN
            PLOTS,[1.,1.]*(*(*(*info).plotaxes).xdoptickloc[d])[k], $
              [t_upp_y,-xtlen_major_fac*(*(*info).plotaxes).spxticklen*(t_upp_y-t_low_y)+$
              t_upp_y], $
              COLOR=(*(*info).plotparams).plotcol
          ENDFOR
          ; Add the labels
          AXIS, XAXIS=1, XRANGE=vdop_xrange, /XS, $
            XTICKNAME=*(*(*info).plotaxes).xdoptickvals[d], $
            COLOR=(*(*info).plotparams).plotcol, $
            XTICKLEN=xtlen_basic_fac*(*(*info).plotaxes).spxticklen, $
            XTICKINTERVAL=(*(*(*info).plotaxes).xdoptickinterval)[0], XMINOR=-1
        ENDIF ELSE $
          ; Else plot Doppler axis with automatic tick mark settings
        	AXIS, XAXIS=1, XTICKLEN=(*(*info).plotaxes).spxticklen, XRANGE=vdop_xrange, $
            XSTYLE=1, XTITLE=topxtitle, COLOR = (*(*info).plotparams).plotcol
      ENDIF ELSE $
  			AXIS, XAXIS=1, XTICKLEN=(*(*info).plotaxes).spxticklen, XRANGE=xrange, XSTYLE=1, $
          XTITLE=topxtitle, COLOR=(*(*info).plotparams).plotcol, $
          XTICKNAME=REPLICATE(' ',60)
    ENDFOR
  ENDIF
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).winids).spwid], labels=['Window ID for replot']
END

PRO CRISPEX_DISPLAYS_SP_RESIZE, event
; Temporal spectrum window resize handler, gets new window dimensions and calls (re)display routines
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	CRISPEX_DISPLAYS_PLOT_RESIZE, event, event.X, event.Y, (*(*info).winsizes).spxres, (*(*info).winsizes).spyres, (*(*info).plotpos).spxmargin_init, (*(*info).plotpos).spxwall_init, $
		spxres, spyres, spwidth, spheight, spx0, spx1, spy0, spy1, (*(*info).plotswitch).v_dop_set, $
  ERROR=error, /SLICE
	IF error THEN CRISPEX_DISPLAYS_RESIZE_ERROR, event ELSE BEGIN
		(*(*info).winsizes).spxres = spxres		& 	(*(*info).winsizes).spyres = spyres
		(*(*info).plotpos).spx0 = spx0			&	(*(*info).plotpos).spx1 = spx1
		(*(*info).plotpos).spy0 = spy0			&	(*(*info).plotpos).spy1 = spy1
		(*(*info).plotpos).xplspw = spx1 - spx0		&	(*(*info).plotpos).yplspw = spy1 - spy0
		(*(*info).plotaxes).spxticklen = -1 * (*(*info).plotaxes).ticklen / spheight
		(*(*info).plotaxes).spyticklen = -1 * (*(*info).plotaxes).ticklen / spwidth
		(*(*info).dispparams).nlpreb = (*(*info).plotpos).xplspw * (*(*info).winsizes).spxres 
		(*(*info).dispparams).ntreb = (*(*info).plotpos).yplspw * (*(*info).winsizes).spyres 
	ENDELSE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [error,(*(*info).winsizes).spxres,(*(*info).winsizes).spyres,(*(*info).plotpos).spx0,(*(*info).plotpos).spx1,$
		(*(*info).plotpos).spy0,(*(*info).plotpos).spy1], labels=['error','spxres','spyres','spx0','spx1','spy0','spy1']
	WIDGET_CONTROL, (*(*info).winids).spdrawid, DRAW_XSIZE = (*(*info).winsizes).spxres, DRAW_YSIZE = (*(*info).winsizes).spyres
	WIDGET_CONTROL, event.TOP, SET_UVALUE = info
  CRISPEX_DRAW_GET_SPECTRAL_AXES, event, /MAIN
	CRISPEX_DISPLAYS_SP_REPLOT_AXES, event
  *(*(*info).data).spslice_congrid = CONGRID( *(*(*info).data).spslice, (*(*info).dispparams).nlpreb, $
    (*(*info).dispparams).ntreb, INTERP = (*(*info).dispparams).interpspslice, /CENTER)
  CRISPEX_DRAW_SPECTRAL_MAIN, event,/SP_ONLY
END

PRO CRISPEX_DISPLAYS_SP_TOGGLE, event, NO_DRAW=no_draw
; Temporal spectrum display window creation procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event, /IGNORE_LAST
  ; If window doesn't exist, create it
	IF ((*(*info).winswitch).showsp EQ 0) THEN BEGIN
		wintitle = 'CRISPEX'+(*(*info).sesparams).instance_label+': '+$
      ((*(*info).plottitles).spwintitle)[(*(*info).plotswitch).heightset]
    ; Create window
		CRISPEX_WINDOW, (*(*info).winsizes).spxres, (*(*info).winsizes).spyres, $
      (*(*info).winids).root, wintitle, tlb, wid, (*(*info).winsizes).spxoffset, $
      (*(*info).winsizes).spyoffset, DRAWID = spdrawid, RESIZING = 1, $
      RES_HANDLER = 'CRISPEX_DISPLAYS_SP_RESIZE'
    ; Save window variables
		(*(*info).winids).sptlb = tlb		&	(*(*info).winids).spwid = wid	&	(*(*info).winswitch).showsp = 1
		(*(*info).winids).spdrawid = spdrawid	&	(*(*info).winids).spwintitle = wintitle
		WIDGET_CONTROL, (*(*info).winids).sptlb, SET_UVALUE = info
    ; Fill window
    CRISPEX_DISPLAYS_SP_REPLOT_AXES, event
    CRISPEX_UPDATE_SPSLICE, event
		IF ~KEYWORD_SET(NO_DRAW) THEN CRISPEX_DRAW_SPECTRAL_MAIN, event,/SP_ONLY
  ; If window does exist, destroy it
	ENDIF ELSE BEGIN
		WIDGET_CONTROL, (*(*info).winids).sptlb, /DESTROY
		(*(*info).winids).sptlb = 0
		(*(*info).winswitch).showsp = 0
	ENDELSE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).winids).sptlb,(*(*info).winids).spwid,$
      (*(*info).winids).spdrawid], labels=['sptlb','spwid','spdrawid']
END

PRO CRISPEX_DISPLAYS_STOKES_SELECT_XY_RECOVER_YRANGE, event
; Restores lower/upper y-values of specific Stokes component detailed spectrum plot for input
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, (*(*info).ctrlscp).lower_y_text, $
    SET_VALUE = STRTRIM((*(*(*info).plotaxes).ls_low_y)[(*(*info).dataparams).s],2)
	WIDGET_CONTROL, (*(*info).ctrlscp).upper_y_text, $
    SET_VALUE = STRTRIM((*(*(*info).plotaxes).ls_upp_y)[(*(*info).dataparams).s],2)
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*(*info).plotaxes).ls_low_y)[(*(*info).dataparams).s],$
                                 (*(*(*info).plotaxes).ls_upp_y)[(*(*info).dataparams).s]], $
                            		labels=['Lower detspect y-value','Upper detspect y-value']
	IF (*(*info).winswitch).showint THEN BEGIN
		WIDGET_CONTROL, (*(*info).ctrlsint).lower_y_int_text, $
      SET_VALUE = STRTRIM((*(*(*info).plotaxes).int_low_y)[(*(*info).dataparams).s],2)
		WIDGET_CONTROL, (*(*info).ctrlsint).upper_y_int_text, $
      SET_VALUE = STRTRIM((*(*(*info).plotaxes).int_upp_y)[(*(*info).dataparams).s],2)
		IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
      CRISPEX_VERBOSE_GET, event, [(*(*(*info).plotaxes).int_low_y)[(*(*info).dataparams).s],$
                                   (*(*(*info).plotaxes).int_upp_y)[(*(*info).dataparams).s]], $
                            			labels=['Lower int y-value','Upper int y-value']
	ENDIF
END

;================================================================================= DISPLAY RANGE PROCEDURES
PRO CRISPEX_DISPRANGE_INT_LOW, event
; Handles change in lower y-value of intensity versus time display window
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, (*(*info).ctrlsint).lower_y_int_text, GET_VALUE = textvalue
	(*(*(*info).plotaxes).int_low_y)[(*(*info).dataparams).s] = FLOAT(textvalue[0])
	IF ((*(*(*info).plotaxes).int_low_y)[(*(*info).dataparams).s] GE (*(*(*info).plotaxes).int_upp_y)[(*(*info).dataparams).s]) THEN $
		(*(*(*info).plotaxes).int_upp_y)[(*(*info).dataparams).s] = (*(*(*info).plotaxes).int_low_y)[(*(*info).dataparams).s] + 1 
	WIDGET_CONTROL, (*(*info).ctrlsint).upper_y_int_text, SET_VALUE = STRTRIM((*(*(*info).plotaxes).int_upp_y)[(*(*info).dataparams).s],2)
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*(*info).plotaxes).int_low_y)[(*(*info).dataparams).s],(*(*(*info).plotaxes).int_upp_y)[(*(*info).dataparams).s]], $
		labels=['Lower int y-value','Upper int y-value']
	CRISPEX_DRAW_INT, event
END

PRO CRISPEX_DISPRANGE_INT_UPP, event
; Handles change in upper y-value of intensity versus time display window
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, (*(*info).ctrlsint).upper_y_int_text, GET_VALUE = textvalue
	(*(*(*info).plotaxes).int_upp_y)[(*(*info).dataparams).s] = FLOAT(textvalue[0]) 
	IF ((*(*(*info).plotaxes).int_upp_y)[(*(*info).dataparams).s] LE (*(*(*info).plotaxes).int_low_y)[(*(*info).dataparams).s]) THEN $
		(*(*(*info).plotaxes).int_low_y)[(*(*info).dataparams).s] = (*(*(*info).plotaxes).int_upp_y)[(*(*info).dataparams).s] - 1 
	WIDGET_CONTROL, (*(*info).ctrlsint).lower_y_int_text, SET_VALUE = STRTRIM((*(*(*info).plotaxes).int_low_y)[(*(*info).dataparams).s],2)
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*(*info).plotaxes).int_low_y)[(*(*info).dataparams).s],(*(*(*info).plotaxes).int_upp_y)[(*(*info).dataparams).s]], $
		labels=['Lower int y-value','Upper int y-value']
	CRISPEX_DRAW_INT, event
END

PRO CRISPEX_DISPRANGE_INT_T_LOW, event
; Handles change in lower t-value of intensity versus time display window
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, (*(*info).ctrlsint).lower_t_int_text, GET_VALUE = textvalue
	(*(*info).plotaxes).int_low_t = FLOAT(textvalue[0])
	IF ((*(*info).plotaxes).int_low_t GE (*(*info).plotaxes).int_upp_t) THEN (*(*info).plotaxes).int_low_t = (*(*info).plotaxes).int_upp_t - 1
	IF ((*(*info).plotaxes).int_low_t LT (*(*info).dispparams).t_first) THEN (*(*info).plotaxes).int_low_t = (*(*info).dispparams).t_first
	WIDGET_CONTROL, (*(*info).ctrlsint).lower_t_int_text, SET_VALUE = STRTRIM((*(*info).plotaxes).int_low_t,2)
	CRISPEX_DISPRANGE_INT_T_RANGE, event
	CRISPEX_DRAW_INT, event
END

PRO CRISPEX_DISPRANGE_INT_T_UPP, event
; Handles change in upper t-value of intensity versus time display window
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, (*(*info).ctrlsint).upper_t_int_text, GET_VALUE = textvalue
	(*(*info).plotaxes).int_upp_t = FLOAT(textvalue[0]) 
	IF ((*(*info).plotaxes).int_upp_t LE (*(*info).plotaxes).int_low_t) THEN (*(*info).plotaxes).int_upp_t = (*(*info).plotaxes).int_low_t + 1
	IF ((*(*info).plotaxes).int_upp_t GT (*(*info).dispparams).t_last) THEN (*(*info).plotaxes).int_upp_t = (*(*info).dispparams).t_last
	WIDGET_CONTROL, (*(*info).ctrlsint).upper_t_int_text, SET_VALUE = STRTRIM((*(*info).plotaxes).int_upp_t,2)
	CRISPEX_DISPRANGE_INT_T_RANGE, event
	CRISPEX_DRAW_INT, event
END

PRO CRISPEX_DISPRANGE_INT_LOCK_T, event
; Locks main temporal range to intensity versus time display temporal range
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).intparams).lock_t = event.SELECT
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).intparams).lock_t], labels=['Lock main to int temporal range']
	CRISPEX_DISPRANGE_INT_T_RANGE, event
END

PRO CRISPEX_DISPRANGE_INT_T_RANGE, event
; Locks main temporal range to intensity versus time display temporal range
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (*(*info).intparams).lock_t THEN BEGIN
		(*(*info).dispparams).t_low = (*(*info).plotaxes).int_low_t
		(*(*info).dispparams).t_upp = (*(*info).plotaxes).int_upp_t
	ENDIF ELSE BEGIN
		(*(*info).dispparams).t_low = (*(*info).dispparams).t_first
		(*(*info).dispparams).t_upp = (*(*info).dispparams).t_last
	ENDELSE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).plotaxes).int_low_t,(*(*info).plotaxes).int_upp_t,(*(*info).dispparams).t_low,(*(*info).dispparams).t_upp], $
		labels=['Lower int t-value','Upper int t-value','Lower t-value','Upper t-value']
	CRISPEX_DISPRANGE_T_RANGE, event
	WIDGET_CONTROL, (*(*info).ctrlscp).lower_t_text, SET_VALUE = STRTRIM((*(*info).dispparams).t_low,2)
	WIDGET_CONTROL, (*(*info).ctrlscp).upper_t_text, SET_VALUE = STRTRIM((*(*info).dispparams).t_upp,2)
	IF (*(*info).winswitch).showint THEN WIDGET_CONTROL, (*(*info).ctrlsint).reset_trange_but, SENSITIVE = (((*(*info).plotaxes).int_upp_t-(*(*info).plotaxes).int_low_t+1) NE (*(*info).dataparams).nt)
END

PRO CRISPEX_DISPRANGE_INT_T_RESET, event
; Handles reset of temporal boundaries and calls (re)display routine
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).plotaxes).int_upp_t = (*(*info).dispparams).t_last
	(*(*info).plotaxes).int_low_t = (*(*info).dispparams).t_first
	CRISPEX_DISPRANGE_INT_T_RANGE, event
	WIDGET_CONTROL, (*(*info).ctrlsint).upper_t_int_text, SET_VALUE = STRTRIM((*(*info).dispparams).t_upp,2)
	WIDGET_CONTROL, (*(*info).ctrlsint).lower_t_int_text, SET_VALUE = STRTRIM((*(*info).dispparams).t_low,2)
	WIDGET_CONTROL, (*(*info).ctrlsint).reset_trange_but, SENSITIVE = 0
END

PRO CRISPEX_DISPRANGE_LS_LOW, event
; Handles change in lower y-value of detailed spectrum display window
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, (*(*info).ctrlscp).lower_y_text, GET_VALUE = textvalue
	IF (*(*info).ctrlsswitch).imrefdetspect THEN BEGIN
		(*(*info).plotaxes).ls_low_y_ref = FLOAT(textvalue[0]) 
		IF ((*(*info).plotaxes).ls_low_y_ref GE (*(*info).plotaxes).ls_upp_y_ref) THEN (*(*info).plotaxes).ls_upp_y_ref = (*(*info).plotaxes).ls_low_y_ref + 1 
		WIDGET_CONTROL, (*(*info).ctrlscp).upper_y_text, SET_VALUE = STRTRIM((*(*info).plotaxes).ls_upp_y_ref,2)
	ENDIF ELSE BEGIN
		(*(*(*info).plotaxes).ls_low_y)[(*(*info).dataparams).s] = FLOAT(textvalue[0]) 
		IF ((*(*(*info).plotaxes).ls_low_y)[(*(*info).dataparams).s] GE (*(*(*info).plotaxes).ls_upp_y)[(*(*info).dataparams).s]) THEN $
			(*(*(*info).plotaxes).ls_upp_y)[(*(*info).dataparams).s] = (*(*(*info).plotaxes).ls_low_y)[(*(*info).dataparams).s] + 1 
		WIDGET_CONTROL, (*(*info).ctrlscp).upper_y_text, SET_VALUE = STRTRIM((*(*(*info).plotaxes).ls_upp_y)[(*(*info).dataparams).s],2)
	ENDELSE
	CRISPEX_DISPRANGE_LS_RANGE, event
END

PRO CRISPEX_DISPRANGE_LS_UPP, event
; Handles change in upper y-value of detailed spectrum display window
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, (*(*info).ctrlscp).upper_y_text, GET_VALUE = textvalue
	IF (*(*info).ctrlsswitch).imrefdetspect THEN BEGIN
		(*(*info).plotaxes).ls_upp_y_ref = FLOAT(textvalue[0])
		IF ((*(*info).plotaxes).ls_upp_y_ref LE (*(*info).plotaxes).ls_low_y_ref) THEN (*(*info).plotaxes).ls_low_y_ref = (*(*info).plotaxes).ls_upp_y_ref - 1 
		WIDGET_CONTROL, (*(*info).ctrlscp).lower_y_text, SET_VALUE = STRTRIM((*(*info).plotaxes).ls_low_y_ref,2)
	ENDIF ELSE BEGIN
		(*(*(*info).plotaxes).ls_upp_y)[(*(*info).dataparams).s] = FLOAT(textvalue[0])
		IF ((*(*(*info).plotaxes).ls_upp_y)[(*(*info).dataparams).s] LE (*(*(*info).plotaxes).ls_low_y)[(*(*info).dataparams).s]) THEN $
			(*(*(*info).plotaxes).ls_low_y)[(*(*info).dataparams).s] = (*(*(*info).plotaxes).ls_upp_y)[(*(*info).dataparams).s] - 1 
		WIDGET_CONTROL, (*(*info).ctrlscp).lower_y_text, SET_VALUE = STRTRIM((*(*(*info).plotaxes).ls_low_y)[(*(*info).dataparams).s],2)
	ENDELSE
	CRISPEX_DISPRANGE_LS_RANGE, event
END

PRO CRISPEX_DISPRANGE_LS_RANGE, event, NO_DRAW=no_draw
; Determines range from change in lower or upper y-value of detailed spectrum display window and calls (re)display routine
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (*(*info).ctrlsswitch).imrefdetspect THEN (*(*info).plotaxes).ls_yrange_ref = (*(*info).plotaxes).ls_upp_y_ref - (*(*info).plotaxes).ls_low_y_ref ELSE $
		(*(*(*info).plotaxes).ls_yrange)[(*(*info).dataparams).s] = (*(*(*info).plotaxes).ls_upp_y)[(*(*info).dataparams).s] - (*(*(*info).plotaxes).ls_low_y)[(*(*info).dataparams).s] 
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*(*info).plotaxes).ls_low_y)[(*(*info).dataparams).s],(*(*(*info).plotaxes).ls_upp_y)[(*(*info).dataparams).s],$
		(*(*info).plotaxes).ls_low_y_ref,(*(*info).plotaxes).ls_upp_y_ref], labels=['Lower main y-value','Upper main y-value','Lower ref y-value','Upper ref y-value']
	IF ~KEYWORD_SET(NO_DRAW) THEN CRISPEX_DRAW, event
END

PRO CRISPEX_DISPRANGE_LS_SCALE_SELECT, event
; Handles the selection of scaling (or not) of the detailed spectrum to the maximum of the average spectrum
	WIDGET_CONTROL, event.TOP, GET_UVALUE=info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (*(*info).ctrlsswitch).imrefdetspect THEN (*(*info).dispswitch).ref_detspect_scale = event.SELECT ELSE (*(*info).dispswitch).detspect_scale = event.SELECT
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).dispswitch).detspect_scale,(*(*info).dispswitch).ref_detspect_scale], labels=['Scale main detspect','Scale ref detspect']
	CRISPEX_DISPRANGE_LS_SCALE, event
END


PRO CRISPEX_DISPRANGE_LS_SCALE, event
; Handles the scaling (or not) of the detailed spectrum to the maximum of the average spectrum
	WIDGET_CONTROL, event.TOP, GET_UVALUE=info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (*(*info).ctrlsswitch).imrefdetspect THEN CRISPEX_DISPRANGE_LS_SCALE_REF, event ELSE CRISPEX_DISPRANGE_LS_SCALE_MAIN, event
	CRISPEX_DISPRANGE_LS_RANGE, event
END

PRO CRISPEX_DISPRANGE_LS_SCALE_MAIN, event
; Handles the scaling (or not) of the main detailed spectrum to the maximum of the average spectrum
	WIDGET_CONTROL, event.TOP, GET_UVALUE=info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (*(*info).dispswitch).detspect_scale THEN BEGIN
		IF (*(*info).plotswitch).scalestokes THEN ms = (*(*info).dataparams).ms * ((*(*info).paramparams).scale_cubes)[0] ELSE ms = ((*(*info).dataparams).ms) * ((*(*info).paramparams).scale_cubes)[0]
		(*(*(*info).plotaxes).ls_low_y) /= ms 
		(*(*(*info).plotaxes).ls_upp_y) /= ms
	ENDIF ELSE BEGIN
		IF (*(*info).plotswitch).scalestokes THEN ms = (*(*info).dataparams).ms ELSE ms = ((*(*info).dataparams).ms)
		(*(*(*info).plotaxes).ls_low_y) *= ms * ((*(*info).paramparams).scale_cubes)[0]
		(*(*(*info).plotaxes).ls_upp_y) *= ms * ((*(*info).paramparams).scale_cubes)[0]
	ENDELSE
	WIDGET_CONTROL, (*(*info).ctrlscp).lower_y_text, SET_VALUE = STRTRIM((*(*(*info).plotaxes).ls_low_y)[(*(*info).dataparams).s],2)
	WIDGET_CONTROL, (*(*info).ctrlscp).upper_y_text, SET_VALUE = STRTRIM((*(*(*info).plotaxes).ls_upp_y)[(*(*info).dataparams).s],2)
END

PRO CRISPEX_DISPRANGE_LS_SCALE_REF, event
; Handles the scaling (or not) of the reference detailed spectrum to the maximum of the average spectrum
	WIDGET_CONTROL, event.TOP, GET_UVALUE=info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (*(*info).dispswitch).ref_detspect_scale THEN BEGIN
		(*(*info).plotaxes).ls_low_y_ref /= ((*(*info).dataparams).refms * ((*(*info).paramparams).scale_cubes)[1]) 
		(*(*info).plotaxes).ls_upp_y_ref /= ((*(*info).dataparams).refms * ((*(*info).paramparams).scale_cubes)[1])
	ENDIF ELSE BEGIN
		(*(*info).plotaxes).ls_low_y_ref *= (*(*info).dataparams).refms * ((*(*info).paramparams).scale_cubes)[1]
		(*(*info).plotaxes).ls_upp_y_ref *= (*(*info).dataparams).refms * ((*(*info).paramparams).scale_cubes)[1]
	ENDELSE
	WIDGET_CONTROL, (*(*info).ctrlscp).lower_y_text, SET_VALUE = STRTRIM((*(*info).plotaxes).ls_low_y_ref,2)
	WIDGET_CONTROL, (*(*info).ctrlscp).upper_y_text, SET_VALUE = STRTRIM((*(*info).plotaxes).ls_upp_y_ref,2)
END

PRO CRISPEX_DISPRANGE_LS_SUBTRACT, event
; Handles display of average subtracted spectrum in detailed spectrum window
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (*(*info).ctrlsswitch).imrefdetspect THEN (*(*info).plotswitch).ref_subtract = event.SELECT ELSE (*(*info).plotswitch).subtract = event.SELECT
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).plotswitch).subtract,(*(*info).plotswitch).ref_subtract], labels=['Subtract from main','Subtract from ref']
	CRISPEX_DRAW, event
END

PRO CRISPEX_DISPRANGE_T_LOW, event
; Handles change in lower t-value of accessed data cube
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, (*(*info).ctrlscp).lower_t_text, GET_VALUE = textvalue
	(*(*info).dispparams).t_low = FLOAT(textvalue[0])
	IF ((*(*info).dispparams).t_low GE (*(*info).dispparams).t_upp) THEN (*(*info).dispparams).t_low = (*(*info).dispparams).t_upp - 1
	IF ((*(*info).dispparams).t_low LT (*(*info).dispparams).t_first) THEN (*(*info).dispparams).t_low = (*(*info).dispparams).t_first
	WIDGET_CONTROL, (*(*info).ctrlscp).lower_t_text, SET_VALUE = STRTRIM((*(*info).dispparams).t_low,2)
	IF ((*(*info).winswitch).showint AND (*(*info).intparams).lock_t) THEN BEGIN
		(*(*info).plotaxes).int_low_t = (*(*info).dispparams).t_low
		CRISPEX_DISPRANGE_INT_T_RANGE, event
		IF (*(*info).winswitch).showint THEN WIDGET_CONTROL, (*(*info).ctrlsint).lower_t_int_text, SET_VALUE = STRTRIM((*(*info).dispparams).t_low,2)
	ENDIF ELSE CRISPEX_DISPRANGE_T_RANGE, event
END

PRO CRISPEX_DISPRANGE_T_UPP, event
; Handles change in upper t-value of accessed data cube
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, (*(*info).ctrlscp).upper_t_text, GET_VALUE = textvalue
	(*(*info).dispparams).t_upp = FLOAT(textvalue[0])
	IF ((*(*info).dispparams).t_upp LE (*(*info).dispparams).t_low) THEN (*(*info).dispparams).t_upp = (*(*info).dispparams).t_low + 1
	IF ((*(*info).dispparams).t_upp GT (*(*info).dispparams).t_last) THEN (*(*info).dispparams).t_upp = (*(*info).dispparams).t_last
	WIDGET_CONTROL, (*(*info).ctrlscp).upper_t_text, SET_VALUE = STRTRIM((*(*info).dispparams).t_upp,2)
	IF ((*(*info).winswitch).showint AND (*(*info).intparams).lock_t) THEN BEGIN
		(*(*info).plotaxes).int_upp_t = (*(*info).dispparams).t_upp
		CRISPEX_DISPRANGE_INT_T_RANGE, event
		IF (*(*info).winswitch).showint THEN WIDGET_CONTROL, (*(*info).ctrlsint).upper_t_int_text, SET_VALUE = STRTRIM((*(*info).dispparams).t_upp,2)
	ENDIF ELSE CRISPEX_DISPRANGE_T_RANGE, event
END

PRO CRISPEX_DISPRANGE_T_RANGE, event, NO_DRAW=no_draw, T_SET=t_set, RESET=reset
; Determines range from change in lower or upper t-value and calls (re)display routine
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (*(*info).winswitch).showretrdet THEN BEGIN
		(*(*info).dispparams).t_low = (*(*(*info).detparams).t)[(*(*info).detparams).idx] - $
      (*(*info).detparams).delta_t_dn > (*(*info).dispparams).t_first
		(*(*info).dispparams).t_upp = (*(*(*info).detparams).t)[(*(*info).detparams).idx] + $
      (*(*info).detparams).delta_t_up < (*(*info).dispparams).t_last
	ENDIF
	(*(*info).dispparams).t_range = (*(*info).dispparams).t_upp - (*(*info).dispparams).t_low + 1
	IF ((*(*info).dispparams).t_range NE (*(*info).dataparams).nt) THEN $
    WIDGET_CONTROL, (*(*info).ctrlscp).reset_trange_but, /SENSITIVE $
  ELSE $
    WIDGET_CONTROL, (*(*info).ctrlscp).reset_trange_but, SENSITIVE = 0
  IF (N_ELEMENTS(T_SET) EQ 1) THEN $
    (*(*info).dispparams).t = t_set $
  ELSE IF (~KEYWORD_SET(RESET) AND ((*(*info).winswitch).showretrdet EQ 0)) THEN BEGIN
    IF ((*(*info).dispparams).t LT (*(*info).dispparams).t_low) THEN $
      (*(*info).dispparams).t = (*(*info).dispparams).t_low $
    ELSE IF ((*(*info).dispparams).t GT (*(*info).dispparams).t_upp) THEN $
      (*(*info).dispparams).t = (*(*info).dispparams).t_upp
  ENDIF
	WIDGET_CONTROL, (*(*info).ctrlscp).t_slider, SET_SLIDER_MIN=(*(*info).dispparams).t_low, $
    SET_SLIDER_MAX=(*(*info).dispparams).t_upp, SET_VALUE=(*(*info).dispparams).t, $
    SENSITIVE=((*(*info).dispparams).t_upp NE (*(*info).dispparams).t_low)
	IF ((*(*info).dispparams).t_range - 1 LE 1) THEN BEGIN
		t_step = 1
		t_sens = 0 
	ENDIF ELSE BEGIN
		t_step = (*(*info).pbparams).t_step
		t_sens = 1
	ENDELSE
  ; Set real lower/upper time values for main
  IF ((*(*info).dataparams).mainnt GT 1) THEN BEGIN
    (*(*info).dispparams).t_low_main = (*(*(*info).dispparams).tarr_main)[(*(*info).dispparams).t_low]
    tarr_main_sel = (*(*(*info).dispparams).tarr_main)[$
      (*(*info).dispparams).t_low:(*(*info).dispparams).t_upp]
    wherene0 = WHERE(tarr_main_sel NE 0, count)
    IF (count NE 0) THEN $
      t_sel = wherene0[count-1] $
    ELSE $
      t_sel = 0
    (*(*info).dispparams).t_upp_main = tarr_main_sel[t_sel] ;Fix tarr[-1]=0
  ENDIF
  IF ((*(*info).dataparams).refnt GT 1) THEN BEGIN
    ; Set real lower/upper time values for reference
    (*(*info).dispparams).t_low_ref = (*(*(*info).dispparams).tarr_ref)[(*(*info).dispparams).t_low]
    tarr_ref = (*(*(*info).dispparams).tarr_ref)[$
      (*(*info).dispparams).t_low:(*(*info).dispparams).t_upp]
    wherene0 = WHERE(tarr_ref NE 0, count)
    IF (count NE 0) THEN $
      t_sel = wherene0[count-1] $
    ELSE $
      t_sel = 0
    (*(*info).dispparams).t_upp_ref = tarr_ref[t_sel] ;Fix tarr[-1]=0
  ENDIF
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).dispparams).t_low,(*(*info).dispparams).t_upp], $
      labels=['Lower t-value','Upper t-value']
	WIDGET_CONTROL, (*(*info).ctrlscp).t_step_slider, $
    SET_SLIDER_MAX=((*(*info).dispparams).t_range-1)>2,$
    SET_VALUE=t_step, SENSITIVE=t_sens
	IF ~KEYWORD_SET(NO_DRAW) THEN BEGIN
		CRISPEX_UPDATE_T, event
		IF (*(*info).winswitch).showsp THEN BEGIN
      CRISPEX_UPDATE_SPSLICE, event
      CRISPEX_DISPLAYS_SP_REPLOT_AXES, event
    ENDIF
		IF (*(*info).winswitch).showrefsp THEN BEGIN
      CRISPEX_UPDATE_REFSPSLICE, event
      CRISPEX_DISPLAYS_REFSP_REPLOT_AXES, event
    ENDIF
    CRISPEX_UPDATE_SLICES, event, /NO_DRAW, $
      NO_PHIS=((*(*info).winswitch).showphis EQ 0)
		IF (*(*info).winswitch).showloop THEN CRISPEX_DISPLAYS_LOOPSLAB_REPLOT_AXES, event
		IF (*(*info).winswitch).showrestloop THEN CRISPEX_DISPLAYS_RESTORE_LOOPSLAB_REPLOT_AXES, event
		IF (*(*info).winswitch).showretrdet THEN CRISPEX_DISPLAYS_RETRIEVE_DET_LOOPSLAB_REPLOT_AXES, event
		CRISPEX_DRAW, event
	ENDIF
END

PRO CRISPEX_DISPRANGE_T_RESET, event, NO_DRAW=no_draw, T_SET=t_set
; Handles reset of temporal boundaries and calls (re)display routine
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).dispparams).t_upp = (*(*info).dispparams).t_last
	(*(*info).dispparams).t_low = (*(*info).dispparams).t_first
	WIDGET_CONTROL, (*(*info).ctrlscp).upper_t_text, $
    SET_VALUE=STRTRIM((*(*info).dispparams).t_upp,2), SENSITIVE=((*(*info).dataparams).nt GT 1)
	WIDGET_CONTROL, (*(*info).ctrlscp).lower_t_text, $
    SET_VALUE=STRTRIM((*(*info).dispparams).t_low,2), SENSITIVE=((*(*info).dataparams).nt GT 1)
	WIDGET_CONTROL, (*(*info).ctrlscp).reset_trange_but, SENSITIVE = 0
	IF ((*(*info).winswitch).showint AND (*(*info).intparams).lock_t) THEN $
    CRISPEX_DISPRANGE_INT_T_RESET, event $
  ELSE $
    CRISPEX_DISPRANGE_T_RANGE, event, NO_DRAW=no_draw, T_SET=t_set, /RESET
END

PRO CRISPEX_DISPRANGE_GET_WARP, event, PHIS=phis
; Handles determining warping tie points
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  lps_sel = ((*(*info).dataparams).lps)[(*(*info).dispparams).lp_low:(*(*info).dispparams).lp_upp]
  min_lps = MIN(lps_sel, /NAN)
  IF KEYWORD_SET(PHIS) THEN $
    nt = (*(*info).phiparams).nphi $
  ELSE $
    nt = (*(*info).dataparams).nt
    xi = FINDGEN((*(*info).dispparams).lp_range) # REPLICATE(1,nt)
    xo = ((lps_sel-min_lps) / FLOAT(MAX(lps_sel-min_lps, /NAN)) * $
          (*(*info).dispparams).lp_range) # REPLICATE(1,nt)
    yi = REPLICATE(1,(*(*info).dispparams).lp_range) # FINDGEN(nt)
  IF KEYWORD_SET(PHIS) THEN BEGIN
    *(*(*info).dispparams).phisxi = xi
    *(*(*info).dispparams).phisyi = yi
    *(*(*info).dispparams).phisxo = xo
    *(*(*info).dispparams).phisyo = *(*(*info).dispparams).phisyi
  ENDIF ELSE BEGIN
    (*(*info).dispparams).xi = xi
    (*(*info).dispparams).yi = yi
    (*(*info).dispparams).xo = xo
    (*(*info).dispparams).yo = (*(*info).dispparams).yi
  ENDELSE
END

PRO CRISPEX_DISPRANGE_GET_WARP_TRIANGULATE, event, xo, yo, xi, yi, slice, PHIS=phis, NX=nx, NY=ny
  WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  WIDGET_CONTROL, /HOURGLASS
  ; Functionality taken from IDL's WARP_TRI
  IF (N_ELEMENTS(NX) NE 1) THEN nx = (SIZE(slice))[1]
  IF (N_ELEMENTS(NY) NE 1) THEN ny = (SIZE(slice))[2]
  gs = [1,1]				        ;Grid spacing
  b = [0,0, nx-1, ny-1]			;Bounds
  ; Triangulate given the input and output tie points
  TRIANGULATE, xo, yo, tr, bounds
  xtri_new = TRIGRID(xo, yo, xi, tr, gs, b)
  ytri_new = TRIGRID(xo, yo, yi, tr, gs, b)
  IF KEYWORD_SET(PHIS) THEN BEGIN
    *(*(*info).dispparams).phisxtri = xtri_new
    *(*(*info).dispparams).phisytri = ytri_new
  ENDIF ELSE BEGIN
    *(*(*info).dispparams).xtri = xtri_new
    *(*(*info).dispparams).ytri = ytri_new
  ENDELSE
END

PRO CRISPEX_DISPRANGE_LP_LOW, event, LP_SET=lp_set, NO_DRAW=no_draw
; Handles change in lower lp-value of accessed data cube
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  IF (N_ELEMENTS(LP_SET) EQ 1) THEN $
    textvalue = lp_set $
  ELSE $
	  WIDGET_CONTROL, (*(*info).ctrlscp).lower_lp_text, GET_VALUE = textvalue
	(*(*info).dispparams).lp_low = FLOAT(textvalue[0])
	IF ((*(*info).dispparams).lp_low GE (*(*info).dispparams).lp_upp) THEN $
    (*(*info).dispparams).lp_low = (*(*info).dispparams).lp_upp - 1
	IF ((*(*info).dispparams).lp_low LT (*(*info).dispparams).lp_first) THEN $
    (*(*info).dispparams).lp_low = (*(*info).dispparams).lp_first
	WIDGET_CONTROL, (*(*info).ctrlscp).lower_lp_text, SET_VALUE = STRTRIM((*(*info).dispparams).lp_low,2)
	CRISPEX_DISPRANGE_LP_RANGE, event, NO_DRAW=no_draw
END

PRO CRISPEX_DISPRANGE_LP_UPP, event, LP_SET=lp_set, NO_DRAW=no_draw
; Handles change in upper lp-value of accessed data cube
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  IF (N_ELEMENTS(LP_SET) EQ 1) THEN $
    textvalue = lp_set $
  ELSE $
	WIDGET_CONTROL, (*(*info).ctrlscp).upper_lp_text, GET_VALUE = textvalue
	(*(*info).dispparams).lp_upp = FLOAT(textvalue[0])
	IF ((*(*info).dispparams).lp_upp LE (*(*info).dispparams).lp_low) THEN $
    (*(*info).dispparams).lp_upp = (*(*info).dispparams).lp_low + 1
	IF ((*(*info).dispparams).lp_upp GT (*(*info).dispparams).lp_last) THEN $
    (*(*info).dispparams).lp_upp = (*(*info).dispparams).lp_last
	WIDGET_CONTROL, (*(*info).ctrlscp).upper_lp_text, SET_VALUE = STRTRIM((*(*info).dispparams).lp_upp,2)
	CRISPEX_DISPRANGE_LP_RANGE, event, NO_DRAW=no_draw
END

PRO CRISPEX_DISPRANGE_LP_RANGE, event, NO_DRAW=no_draw
; Determines range from change in lower or upper s-value and calls (re)display routine
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).dispparams).lp_range = (*(*info).dispparams).lp_upp - (*(*info).dispparams).lp_low + 1
	IF (((*(*info).intparams).ndiagnostics EQ 1) AND $
    ((*(*info).dispparams).lp_range NE (*(*info).dataparams).nlp)) THEN $
    WIDGET_CONTROL, (*(*info).ctrlscp).reset_lprange_but, /SENSITIVE $
  ELSE $
    WIDGET_CONTROL, (*(*info).ctrlscp).reset_lprange_but, SENSITIVE = 0
	IF ((*(*info).dataparams).lp LT (*(*info).dispparams).lp_low) THEN $
    (*(*info).dataparams).lp = (*(*info).dispparams).lp_low $
  ELSE IF ((*(*info).dataparams).lp GT (*(*info).dispparams).lp_upp) THEN $
    (*(*info).dataparams).lp = (*(*info).dispparams).lp_upp $
  ELSE $
		(*(*info).dataparams).lp = (*(*info).dataparams).lp
  CRISPEX_SLIDER_LP_UPDATE, event, /NO_DRAW
	WIDGET_CONTROL, (*(*info).ctrlscp).lp_slider, SET_SLIDER_MIN = (*(*info).dispparams).lp_low, $
                  SET_SLIDER_MAX = (*(*info).dispparams).lp_upp, SET_VALUE = (*(*info).dataparams).lp
	WIDGET_CONTROL, (*(*info).ctrlscp).lp_blink_slider, SET_SLIDER_MIN=(*(*info).dispparams).lp_low, $
    SET_SLIDER_MAX=(*(*info).dispparams).lp_upp, SET_VALUE=(*(*info).dataparams).lp, $
    SENSITIVE=(((*(*info).dispparams).lp_range-1) NE 1)
  IF ((*(*info).dispswitch).warpspslice AND (*(*info).winswitch).showphis) THEN BEGIN
    WIDGET_CONTROL, /HOURGLASS
    CRISPEX_DISPRANGE_GET_WARP, event, /PHIS
    CRISPEX_DISPRANGE_GET_WARP_TRIANGULATE, event, $
      *(*(*info).dispparams).phisxo,*(*(*info).dispparams).phisyo,$
      *(*(*info).dispparams).phisxi,*(*(*info).dispparams).phisyi, $
      *(*(*info).data).phislice, /PHIS, NX=(*(*info).dispparams).lp_range, NY=(*(*info).phiparams).nphi
  ENDIF
	IF ~KEYWORD_SET(NO_DRAW) THEN BEGIN
		CRISPEX_UPDATE_T, event
		IF (*(*info).winswitch).showsp THEN BEGIN
      CRISPEX_UPDATE_SPSLICE, event
      CRISPEX_DISPLAYS_SP_REPLOT_AXES, event
    ENDIF
		IF (*(*info).winswitch).showphis THEN BEGIN
      CRISPEX_UPDATE_PHISLICE, event, /NO_DRAW
      CRISPEX_DISPLAYS_PHIS_REPLOT_AXES, event
    ENDIF
		CRISPEX_DRAW, event
	ENDIF
	IF (*(*info).winswitch).showphis THEN BEGIN
		IF (*(*info).dataswitch).onecube THEN $
      WIDGET_CONTROL, (*(*info).ctrlscp).slice_button, SET_VALUE = 'Update spectral windows', $
                      SENSITIVE = 1  $
    ELSE $
      WIDGET_CONTROL, (*(*info).ctrlscp).slice_button, SENSITIVE = 1
	ENDIF
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).dispparams).lp_low,(*(*info).dispparams).lp_upp], $
                        labels=['Lower lp-value','Upper lp-value']
END

PRO CRISPEX_DISPRANGE_LP_RESET, event, NO_DRAW=no_draw
; Handles reset of spectral boundaries and calls (re)display routine
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).dispparams).lp_upp = (*(*info).dispparams).lp_last
	(*(*info).dispparams).lp_low = (*(*info).dispparams).lp_first
	WIDGET_CONTROL, (*(*info).ctrlscp).upper_lp_text, $
                  SET_VALUE = STRTRIM((*(*info).dispparams).lp_upp,2), /SENSITIVE
	WIDGET_CONTROL, (*(*info).ctrlscp).lower_lp_text, $
                  SET_VALUE = STRTRIM((*(*info).dispparams).lp_low,2), /SENSITIVE
	WIDGET_CONTROL, (*(*info).ctrlscp).reset_trange_but, SENSITIVE = 0
	WIDGET_CONTROL, (*(*info).ctrlscp).lp_slider, /SENSITIVE
	CRISPEX_DISPRANGE_LP_RANGE, event, NO_DRAW=no_draw
END

PRO CRISPEX_DISPRANGE_LP_REF_RANGE, event, NO_DRAW=no_draw, LP_LOW_SET=lp_low_set, $
  LP_UPP_SET=lp_upp_set
; Determines range from change in lower or upper s-value and calls (re)display routine
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  IF (N_ELEMENTS(LP_LOW_SET) EQ 1) THEN (*(*info).dispparams).lp_ref_low = lp_low_set
  IF (N_ELEMENTS(LP_UPP_SET) EQ 1) THEN (*(*info).dispparams).lp_ref_upp = lp_upp_set
	(*(*info).dispparams).lp_ref_range = (*(*info).dispparams).lp_ref_upp - (*(*info).dispparams).lp_ref_low + 1
	IF ((*(*info).dataparams).lp_ref LT (*(*info).dispparams).lp_ref_low) THEN $
    (*(*info).dataparams).lp_ref = (*(*info).dispparams).lp_ref_low $
  ELSE IF ((*(*info).dataparams).lp_ref GT (*(*info).dispparams).lp_ref_upp) THEN $
    (*(*info).dataparams).lp_ref = (*(*info).dispparams).lp_ref_upp 
  CRISPEX_SLIDER_LP_UPDATE, event, /NO_DRAW
	WIDGET_CONTROL, (*(*info).ctrlscp).lp_ref_slider, $
    SET_SLIDER_MIN = (*(*info).dispparams).lp_ref_low, $
    SET_SLIDER_MAX = (*(*info).dispparams).lp_ref_upp, SET_VALUE = (*(*info).dataparams).lp_ref
	IF ~KEYWORD_SET(NO_DRAW) THEN BEGIN
		IF (*(*info).winswitch).showrefsp THEN BEGIN
      CRISPEX_UPDATE_REFSPSLICE, event
      CRISPEX_DISPLAYS_REFSP_REPLOT_AXES, event
    ENDIF
		CRISPEX_UPDATE_T, event
		CRISPEX_DRAW, event
	ENDIF
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).dispparams).lp_ref_low,$
    (*(*info).dispparams).lp_ref_upp], labels=['Lower lp-value','Upper lp-value']
END

PRO CRISPEX_DISPRANGE_LP_REF_RESET, event, NO_DRAW=no_draw
; Handles reset of reference spectral boundaries and calls (re)display routine
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).dispparams).lp_ref_upp = (*(*info).dispparams).lp_ref_last
	(*(*info).dispparams).lp_ref_low = (*(*info).dispparams).lp_ref_first
	CRISPEX_DISPRANGE_LP_REF_RANGE, event, NO_DRAW=no_draw
END
;==================== DISPLAY DRAW PROCEDURES
PRO CRISPEX_DRAW_CURSCROSS_PLOT, event, curscolor, no_cursor=no_cursor, $
  no_number=no_number,thick=thick, no_endpoints=no_endpoints, $
  symsize=symsize, draw_mask=draw_mask, SJI=sji, REFERENCE=reference
  ; Handles overplotting of the cursor, slits and loop paths
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).phiparams).d_nphi_set = $
    (*(*info).zooming).factor * (*(*info).phiparams).nphi_set
  main_wid = 0
  ref_wid = 0
  sji_wid = 0
  IF KEYWORD_SET(SJI) THEN BEGIN
    sji_wid = ((*(*info).winids).current_wid EQ (*(*info).winids).sjidrawid)
    sx_loc = (*(*info).curs).sxsji
    sy_loc = (*(*info).curs).sysji
    IF (*(*info).overlayswitch).sjiraster THEN $
      CRISPEX_DRAW_RASTER_OVERLAYS, event, /SJI
  ENDIF ELSE IF KEYWORD_SET(REFERENCE) THEN BEGIN
    ref_wid = ((*(*info).winids).current_wid EQ (*(*info).winids).refdrawid)
    sx_loc = (*(*info).curs).sxref
    sy_loc = (*(*info).curs).syref
    IF (*(*info).overlayswitch).refraster THEN $
      CRISPEX_DRAW_RASTER_OVERLAYS, event, /REFERENCE
    IF ((*(*info).overlayswitch).rastertiming AND $
        (SIZE((*(*info).dataparams).tarr_raster_ref, /N_DIM) EQ 2)) THEN $
      CRISPEX_DRAW_RASTER_TIMING_OVERLAYS, event, /REFERENCE
  ENDIF ELSE BEGIN
    main_wid = ((*(*info).winids).current_wid EQ (*(*info).winids).xydrawid)
    sx_loc = (*(*info).curs).sx
    sy_loc = (*(*info).curs).sy
    IF ((*(*info).overlayswitch).rastertiming AND $
        (SIZE((*(*info).dataparams).tarr_raster_main, /N_DIM) EQ 2)) THEN $
      CRISPEX_DRAW_RASTER_TIMING_OVERLAYS, event, /MAIN
  ENDELSE
  ; Get current colour table arrays
  TVLCT, r_cur, g_cur, b_cur, /GET
  eqtc0 = (ARRAY_EQUAL(r_cur,BINDGEN(256)) AND ARRAY_EQUAL(g_cur,BINDGEN(256)) $
      AND ARRAY_EQUAL(b_cur,BINDGEN(256)))
  IF (eqtc0 EQ 0) THEN LOADCT,0,/SILENT
  ; Overplot phi-slit 
	IF (*(*info).winswitch).showphis THEN $ 
			PLOTS, ([-1,1]*(*(*info).phiparams).d_nphi_set*(*(*info).winsizes).xywinx/$
              (2.*(*(*info).dataparams).nx))*COS((*(*info).phiparams).angle*!DTOR) + $
              sx_loc, $
				      ([-1,1]*(*(*info).phiparams).d_nphi_set*(*(*info).winsizes).xywiny/$
              (2.*(*(*info).dataparams).ny))*SIN((*(*info).phiparams).angle*!DTOR) + $
              sy_loc, /DEVICE, COLOR = !P.COLOR ;$
  ; Overplot loop paths...
	IF ((*(*info).overlayswitch).loopslit AND $
    (((*(*info).loopparams).np GT 0) OR $
     ((*(*info).loopparams).np_ref GT 0) OR $
     ((*(*info).loopparams).np_sji GT 0))) THEN BEGIN
		CRISPEX_ZOOM_LOOP, event, REFERENCE=KEYWORD_SET(REFERENCE), $
      SJI=KEYWORD_SET(SJI)
    ; ... in reference window
    IF KEYWORD_SET(REFERENCE) THEN BEGIN
  		IF ~KEYWORD_SET(NO_ENDPOINTS) THEN $
        PLOTS, *(*(*info).overlayparams).sxp_ref, $
          *(*(*info).overlayparams).syp_ref, /DEVICE, COLOR=!P.COLOR, PSYM=1, $
          THICK=thick, SYMSIZE=symsize
  		IF ((*(*info).overlayparams).loop_linestyle EQ 1) THEN $
        PLOTS,*(*(*info).overlayparams).sxr_ref,$
          *(*(*info).overlayparams).syr_ref, /DEVICE, COLOR=!P.COLOR, PSYM=3, $
          THICK=thick $
  		ELSE $
        PLOTS,*(*(*info).overlayparams).sxr_ref,$
          *(*(*info).overlayparams).syr_ref,/DEVICE, COLOR=!P.COLOR, $
          LINESTYLE=(*(*info).overlayparams).loop_linestyle, THICK=thick
    ; ... in SJI window
    ENDIF ELSE IF KEYWORD_SET(SJI) THEN BEGIN
  		IF ~KEYWORD_SET(NO_ENDPOINTS) THEN $
        PLOTS, *(*(*info).overlayparams).sxp_sji, $
          *(*(*info).overlayparams).syp_sji, /DEVICE, COLOR=!P.COLOR, PSYM=1, $
          THICK=thick, SYMSIZE=symsize
  		IF ((*(*info).overlayparams).loop_linestyle EQ 1) THEN $
        PLOTS,*(*(*info).overlayparams).sxr_sji,$
          *(*(*info).overlayparams).syr_sji, /DEVICE, COLOR=!P.COLOR, PSYM=3, $
          THICK=thick $
  		ELSE $
        PLOTS,*(*(*info).overlayparams).sxr_sji,$
          *(*(*info).overlayparams).syr_sji,/DEVICE, COLOR=!P.COLOR, $
          LINESTYLE=(*(*info).overlayparams).loop_linestyle, THICK=thick
    ; ... in main window
    ENDIF ELSE BEGIN
  		IF ~KEYWORD_SET(NO_ENDPOINTS) THEN $
        PLOTS, *(*(*info).overlayparams).sxp, *(*(*info).overlayparams).syp, $
          /DEVICE, COLOR=!P.COLOR, PSYM=1, THICK=thick, SYMSIZE=symsize
  		IF ((*(*info).overlayparams).loop_linestyle EQ 1) THEN $
        PLOTS,*(*(*info).overlayparams).sxr,*(*(*info).overlayparams).syr, $
          /DEVICE, COLOR=!P.COLOR, PSYM=3, THICK=thick $
  		ELSE $
        PLOTS,*(*(*info).overlayparams).sxr,*(*(*info).overlayparams).syr, $
          /DEVICE, COLOR=!P.COLOR, THICK=thick, $
          LINESTYLE=(*(*info).overlayparams).loop_linestyle
    ENDELSE
	ENDIF ELSE IF ((*(*info).meas).np GE 1) THEN BEGIN
    ; Draw measurement
		CRISPEX_ZOOM_MEAS, event, REFERENCE=KEYWORD_SET(REFERENCE), $
      SJI=KEYWORD_SET(SJI)
    ; ... in reference window
    IF KEYWORD_SET(REFERENCE) THEN BEGIN
  		IF ~KEYWORD_SET(NO_ENDPOINTS) THEN BEGIN
  			PLOTS, *(*(*info).meas).sxp_ref,*(*(*info).meas).syp_ref, /DEVICE, $
          COLOR=!P.COLOR, PSYM=1, THICK=thick, SYMSIZE=symsize
  			PLOTS, *(*(*info).meas).sxp_ref,*(*(*info).meas).syp_ref, /DEVICE, $
          COLOR=!P.COLOR, LINESTYLE=0, THICK=thick, SYMSIZE=symsize
  		ENDIF
    ; ... in SJI window
    ENDIF ELSE IF KEYWORD_SET(SJI) THEN BEGIN
  		IF ~KEYWORD_SET(NO_ENDPOINTS) THEN BEGIN
  			PLOTS, *(*(*info).meas).sxp_sji,*(*(*info).meas).syp_sji, /DEVICE, $
          COLOR=!P.COLOR, PSYM=1, THICK=thick, SYMSIZE=symsize
  			PLOTS, *(*(*info).meas).sxp_sji,*(*(*info).meas).syp_sji, /DEVICE, $
          COLOR=!P.COLOR, LINESTYLE=0, THICK=thick, SYMSIZE=symsize
  		ENDIF
    ; ... in main window
    ENDIF ELSE BEGIN
  		IF ~KEYWORD_SET(NO_ENDPOINTS) THEN BEGIN
  			PLOTS, *(*(*info).meas).sxp,*(*(*info).meas).syp, /DEVICE, $
          COLOR=!P.COLOR, PSYM=1, THICK=thick, SYMSIZE=symsize
  			PLOTS, *(*(*info).meas).sxp,*(*(*info).meas).syp, /DEVICE, $
          COLOR=!P.COLOR, LINESTYLE=0, THICK=thick, SYMSIZE=symsize
  		ENDIF
    ENDELSE
	ENDIF ;ELSE 
  IF ~KEYWORD_SET(NO_CURSOR) THEN BEGIN
    ; Overplot cursor location
    IF ((main_wid OR ref_wid OR sji_wid) AND eqtc0) THEN BEGIN
      LOADCT, 13, /SILENT
      curscolor = 255
    ENDIF ELSE BEGIN
      IF (main_wid+ref_wid+sji_wid EQ 0) THEN curscolor = 255
    ENDELSE
    IF KEYWORD_SET(SJI) THEN BEGIN
      IF ((*(*info).dispswitch).xysji_out_of_range EQ 0) THEN $
        PLOTS, sx_loc, sy_loc, /DEVICE, PSYM=1, COLOR=curscolor, THICK=thick, $
          SYMSIZE=symsize
    ENDIF ELSE $
      PLOTS, sx_loc, sy_loc, /DEVICE, PSYM=1, COLOR=curscolor, THICK=thick, $
        SYMSIZE=symsize
  ENDIF
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, $
      [(*(*info).curs).sx,(*(*info).curs).sy,(*(*info).winsizes).xywinx,$
       (*(*info).winsizes).xywiny], labels=['sx','sy','xywinx','xywiny']
	CRISPEX_DRAW_LOOP_OVERLAYS, event, NO_NUMBER=no_number, THICK=thick, $
    NO_ENDPOINTS=no_endpoints, SYMSIZE=symsize, SJI=SJI, REFERENCE=reference
	IF draw_mask THEN CRISPEX_DRAW_MASK_OVERLAYS, event, REFERENCE=reference
  TVLCT, r_cur, g_cur, b_cur
END

PRO CRISPEX_DRAW_LOOP_LINESTYLE_0, event
; Handles setting of loop path linestyle to solid
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).overlayparams).loop_linestyle = 0
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).overlayparams).loop_linestyle], labels=['Loop linestyle']
	CRISPEX_DRAW, event
END

PRO CRISPEX_DRAW_LOOP_LINESTYLE_1, event
; Handles setting of loop path linestyle to dotted (i.e. actual loop points, not dots between the vertices)
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).overlayparams).loop_linestyle = 1
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).overlayparams).loop_linestyle], labels=['Loop linestyle']
	CRISPEX_DRAW, event
END

PRO CRISPEX_DRAW_LOOP_LINESTYLE_2, event
; Handles setting of loop path linestyle to dashed
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).overlayparams).loop_linestyle = 2
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).overlayparams).loop_linestyle], labels=['Loop linestyle']
	CRISPEX_DRAW, event
END

PRO CRISPEX_DRAW_LOOP_OVERLAYS, event, NO_NUMBER=no_number, THICK=thick, $
  NO_ENDPOINTS=no_endpoints, SYMSIZE=symsize, SJI=sji, REFERENCE=reference
; Handles overplotting of loop paths from the restored and retrieved loops as well as from the retrieved detections
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  ; Draw restored loop overlays if any are restored
	IF (((*(*info).loopswitch).restore_loops EQ 1) AND $
      ((*(*info).restoreparams).cfilecount GT 0)) THEN $
    CRISPEX_DRAW_LOOP_OVERLAYS_GET_LOOPS, event, NO_NUMBER=no_number, $
      THICK=thick, NO_ENDPOINTS=no_endpoints, SYMSIZE=symsize, SJI=sji, $
      REFERENCE=reference, /RESTORED
  ; Draw retrieved loop overlays if any are restored
	IF (((*(*info).retrparams).clfilecount GT 0) AND $
      ((*(*info).loopswitch).retrieve_loops EQ 1)) THEN $
      CRISPEX_DRAW_LOOP_OVERLAYS_GET_LOOPS, event, NO_NUMBER=no_number, $
        THICK=thick, NO_ENDPOINTS=no_endpoints, SYMSIZE=symsize, SJI=sji, $
        REFERENCE=reference, /RETRIEVED
	IF ((*(*info).loopswitch).retrieve_detfile EQ 1) THEN BEGIN
		condition = WHERE(*(*(*info).detparams).sel_dets EQ 1, conditioncount)
		IF (*(*info).overlayswitch).det_overlay_all THEN BEGIN
			detdrawn = (*(*info).detparams).nr_dets
      CRISPEX_DRAW_LOOP_OVERLAYS_GET_LOOPS, event, NO_NUMBER=no_number, $
        THICK=thick, NO_ENDPOINTS=no_endpoints, SYMSIZE=symsize, SJI=sji, $
        REFERENCE=reference, /DETECTION
		ENDIF ELSE IF (((*(*info).overlayswitch).det_overlay_all EQ 0) AND $
                    (conditioncount GT 0)) THEN BEGIN
				indices = WHERE((*(*(*info).detparams).sel_dets) EQ 1, count)
        IF (count GT 0) THEN BEGIN
          CRISPEX_DRAW_LOOP_OVERLAYS_GET_LOOPS, event, NO_NUMBER=no_number, $
            THICK=thick, NO_ENDPOINTS=no_endpoints, SYMSIZE=symsize, SJI=sji, $
            REFERENCE=reference, /DETECTION
  				detdrawn = N_ELEMENTS(indices)
        ENDIF ELSE detdrawn = 0
		ENDIF ELSE detdrawn = 0
		IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
      CRISPEX_VERBOSE_GET, event, $
        [(*(*info).detparams).nr_dets,conditioncount,detdrawn], $
        labels=['Detections retrieved','Detections selected','Detections drawn']
	ENDIF ELSE RETURN
END

PRO CRISPEX_DRAW_LOOP_OVERLAYS_GET_LOOPS, event, NO_NUMBER=no_number, THICK=thick, $
  NO_ENDPOINTS=no_endpoints, SYMSIZE=symsize, SJI=sji, REFERENCE=reference, $
  RESTORED=restored, RETRIEVED=retrieved, DETECTION=detection
; Handles overplotting of restored or retrieved loop paths
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  IF KEYWORD_SET(RESTORED) THEN BEGIN
    cfilecount = (*(*info).restoreparams).cfilecount
    overlalways = REPLICATE((*(*info).overlayswitch).overlalways, cfilecount)
    sel_loops = WHERE( ((overlalways EQ 1) OR $
      (*(*(*info).restoreparams).lp EQ (*(*info).dataparams).lp)) AND $
      (*(*(*info).restoreparams).sel_loops EQ 1), sel_count)
    xp = *(*(*info).restoreparams).xp
    yp = *(*(*info).restoreparams).yp
    xr = *(*(*info).restoreparams).xr
    yr = *(*(*info).restoreparams).yr
    imref = *(*(*info).restoreparams).imref
    sel_labels = ['Loops restored','Loops drawn']
  ENDIF ELSE IF KEYWORD_SET(RETRIEVED) THEN BEGIN
    sel_loops = WHERE(*(*(*info).retrparams).sel_loops EQ 1, sel_count)
    xp = *(*(*info).retrparams).xlp
    yp = *(*(*info).retrparams).ylp
    xr = *(*(*info).retrparams).xlr
    yr = *(*(*info).retrparams).ylr
    imref = REPLICATE(1,(*(*info).retrparams).clfilecount)
    sel_labels = ['Loops retrieved','Retrieved loops drawn']
  ENDIF ELSE IF KEYWORD_SET(DETECTION) THEN BEGIN
    sel_loops = WHERE(*(*(*info).detparams).overlay_dets EQ 1, sel_count)
    xp = *(*(*info).detparams).xlp
    yp = *(*(*info).detparams).ylp
		low = (*(*info).detparams).mid-FLOOR((*(*info).detparams).width/2.)
		upp = (*(*info).detparams).mid+FLOOR((*(*info).detparams).width/2.)
    xr = *(*(*info).detparams).xlr
    yr = *(*(*info).detparams).ylr
    imref = REPLICATE(1,(*(*info).detparams).nr_dets)
  ENDIF
  IF (sel_count GT 0) THEN BEGIN
    FOR i=0,sel_count-1 DO BEGIN
			xp_orig = *(xp)[sel_loops[i]]
			yp_orig = *(yp)[sel_loops[i]]
			xr_orig = *(xr)[sel_loops[i]]
			yr_orig = *(yr)[sel_loops[i]]
      IF KEYWORD_SET(DETECTION) THEN BEGIN
        xr_orig = xr_orig[*,low:upp]
        yr_orig = yr_orig[*,low:upp]
      ENDIF
      ; Convert main coordinates to device as default
      sxyp = CRISPEX_TRANSFORM_DATA2DEVICE(info, X=xp_orig, Y=yp_orig, $
        MAIN=((imref)[sel_loops[i]] NE 2), REF=((imref)[sel_loops[i]] EQ 2))
      sxyr = CRISPEX_TRANSFORM_DATA2DEVICE(info, X=xr_orig, Y=yr_orig, $
        MAIN=((imref)[sel_loops[i]] NE 2), REF=((imref)[sel_loops[i]] EQ 2))
      IF ((imref)[sel_loops[i]] EQ 2) THEN BEGIN
        ; imref=2: reference
        wcs_from = (*(*info).dataparams).wcs_ref
        pix_from2main = (*(*info).dataparams).pix_ref2main
        pix_from2sji = (*(*info).dataparams).pix_ref2sji
        dx_from = (*(*info).dataparams).refdx
        dy_from = (*(*info).dataparams).refdy
        xval_from = (*(*info).dataparams).xval_ref
        yval_from = (*(*info).dataparams).yval_ref
        xpix_from = (*(*info).dataparams).xpix_ref
        ypix_from = (*(*info).dataparams).ypix_ref
        nx = (*(*info).dataparams).refnx
        ny = (*(*info).dataparams).refny
      ENDIF ELSE BEGIN
        ; imref=1: main
        wcs_from = (*(*info).dataparams).wcs_main
        pix_from2ref = (*(*info).dataparams).pix_main2ref
        pix_from2sji = (*(*info).dataparams).pix_main2sji
        dx_from = (*(*info).dataparams).dx
        dy_from = (*(*info).dataparams).dy
        xval_from = (*(*info).dataparams).xval
        yval_from = (*(*info).dataparams).yval
        xpix_from = (*(*info).dataparams).xpix
        ypix_from = (*(*info).dataparams).ypix
        nx = (*(*info).dataparams).nx
        ny = (*(*info).dataparams).ny
      ENDELSE
      IF KEYWORD_SET(SJI) THEN BEGIN
        IF ((*(*info).dataswitch).wcs_set AND $
          (*(*info).dataswitch).sji_wcs_set) THEN BEGIN
          ; If WCS info available, use that for the transform
          IF (TOTAL(xp_orig LT 0) AND TOTAL(xp_orig GE nx) AND $
            TOTAL(yp_orig LT 0) AND TOTAL(yp_orig GE ny)) THEN BEGIN
            xp_sji = REFORM((pix_from2sji[*,xp_orig,0])[0,*])
            yp_sji = REFORM((pix_from2sji[*,0,yp_orig])[1,0,*])
            xyp_sji = {x:xp_sji, y:yp_sji}
          ENDIF ELSE $
            xyp_sji = CRISPEX_TRANSFORM_GET_WCS(xp_orig, yp_orig, $
              wcs_from, (*(*info).dataparams).wcs_sji, /PIXEL, /COORD)
          xyr_sji = CRISPEX_TRANSFORM_GET_WCS(xr_orig, yr_orig, $
            wcs_from, (*(*info).dataparams).wcs_sji, /PIXEL, /COORD, /NO_ROUND)
        ENDIF ELSE BEGIN
          ; Else, use header information for transform
          xyp_sji = CRISPEX_TRANSFORM_COORDS(xp_orig, yp_orig, $
            dx_from, (*(*info).dataparams).sjidx, $
            dy_from, (*(*info).dataparams).sjidy, $
            xval_from, (*(*info).dataparams).xval_sji, $
            yval_from, (*(*info).dataparams).yval_sji, $
            xpix_from, (*(*info).dataparams).xpix_sji, $
            ypix_from, (*(*info).dataparams).ypix_sji)
          xyr_sji = CRISPEX_TRANSFORM_COORDS(xr_orig, yr_orig, $
            dx_from, (*(*info).dataparams).sjidx, $
            dy_from, (*(*info).dataparams).sjidy, $
            xval_from, (*(*info).dataparams).xval_sji, $
            yval_from, (*(*info).dataparams).yval_sji, $
            xpix_from, (*(*info).dataparams).xpix_sji, $
            ypix_from, (*(*info).dataparams).ypix_sji)
        ENDELSE
        sxyp = CRISPEX_TRANSFORM_DATA2DEVICE(info, X=xyp_sji.x, $
          Y=xyp_sji.y, /SJI)
        sxyr = CRISPEX_TRANSFORM_DATA2DEVICE(info, X=xyr_sji.x, $
          Y=xyr_sji.y, /SJI)
      ENDIF ELSE IF KEYWORD_SET(REFERENCE) THEN BEGIN
        IF ((imref)[sel_loops[i]] NE 2) THEN BEGIN
          IF ((*(*info).dataswitch).wcs_set AND $
            (*(*info).dataswitch).ref_wcs_set) THEN BEGIN
            ; If WCS info available, use that for the transform
            IF (TOTAL(xp_orig LT 0) AND TOTAL(xp_orig GE nx) AND $
              TOTAL(yp_orig LT 0) AND TOTAL(yp_orig GE ny)) THEN BEGIN
              xp_ref = REFORM((pix_from2ref[*,xp_orig,0])[0,*])
              yp_ref = REFORM((pix_from2ref[*,0,yp_orig])[1,0,*])
              xyp_ref = {x:xp_ref, y:yp_ref}
            ENDIF ELSE $
              xyp_ref = CRISPEX_TRANSFORM_GET_WCS(xp_orig, yp_orig, $
                wcs_from, (*(*info).dataparams).wcs_ref, /PIXEL, /COORD)
            xyr_ref = CRISPEX_TRANSFORM_GET_WCS(xr_orig, yr_orig, $
              wcs_from, (*(*info).dataparams).wcs_ref, $
              /PIXEL, /COORD, /NO_ROUND)
          ENDIF ELSE IF ((*(*info).dispswitch).main2ref_no_map EQ 0) THEN BEGIN
            ; Else, use header information for transform
            xyp_ref = CRISPEX_TRANSFORM_COORDS(xp_orig, yp_orig, $
              dx_from, (*(*info).dataparams).refdx, $
              dy_from, (*(*info).dataparams).refdy, $
              xval_from, (*(*info).dataparams).xval_ref, $
              yval_from, (*(*info).dataparams).yval_ref, $
              xpix_from, (*(*info).dataparams).xpix_ref, $
              ypix_from, (*(*info).dataparams).ypix_ref)
            xyr_ref = CRISPEX_TRANSFORM_COORDS(xr_orig, yr_orig, $
              dx_from, (*(*info).dataparams).refdx, $
              dy_from, (*(*info).dataparams).refdy, $
              xval_from, (*(*info).dataparams).xval_ref, $
              yval_from, (*(*info).dataparams).yval_ref, $
              xpix_from, (*(*info).dataparams).xpix_ref, $
              ypix_from, (*(*info).dataparams).ypix_ref)
          ENDIF ELSE BEGIN
            ; Else no mapping is occuring, so use main values
            xyp_ref = {x:xp_orig, y:yp_orig}
            xyr_ref = {x:xr_orig, y:yr_orig}
          ENDELSE
          sxyp = CRISPEX_TRANSFORM_DATA2DEVICE(info, X=xyp_ref.x, $
            Y=xyp_ref.y, /REF)
          sxyr = CRISPEX_TRANSFORM_DATA2DEVICE(info, X=xyr_ref.x, $
            Y=xyr_ref.y, /REF)
        ENDIF 
      ENDIF ELSE BEGIN
        ; Else converting to main from ref, or directly from main
        IF ((imref)[sel_loops[i]] EQ 2) THEN BEGIN
          IF ((*(*info).dataswitch).wcs_set AND $
            (*(*info).dataswitch).ref_wcs_set) THEN BEGIN
            ; If WCS info available, use that for the transform
            IF (TOTAL(xp_orig LT 0) AND TOTAL(xp_orig GE nx) AND $
              TOTAL(yp_orig LT 0) AND TOTAL(yp_orig GE ny)) THEN BEGIN
              xp_main = REFORM((pix_from2main[*,xp_orig,0])[0,*])
              yp_main = REFORM((pix_from2main[*,0,yp_orig])[1,0,*])
              xyp = {x:xp_main, y:yp_main}
            ENDIF ELSE $
              xyp = CRISPEX_TRANSFORM_GET_WCS(xp_orig, yp_orig, $
                wcs_from, (*(*info).dataparams).wcs_main, /PIXEL, /COORD)
            xyr = CRISPEX_TRANSFORM_GET_WCS(xr_orig, yr_orig, $
              wcs_from, (*(*info).dataparams).wcs_main, $
              /PIXEL, /COORD, /NO_ROUND)
          ENDIF ELSE IF ((*(*info).dispswitch).main2ref_no_map EQ 0) THEN BEGIN
            ; Else, use header information for transform
            xyp = CRISPEX_TRANSFORM_COORDS(xp_orig, yp_orig, $
              dx_from, (*(*info).dataparams).dx, $
              dy_from, (*(*info).dataparams).dy, $
              xval_from, (*(*info).dataparams).xval, $
              yval_from, (*(*info).dataparams).yval, $
              xpix_from, (*(*info).dataparams).xpix, $
              ypix_from, (*(*info).dataparams).ypix)
            xyr = CRISPEX_TRANSFORM_COORDS(xr_orig, yr_orig, $
              dx_from, (*(*info).dataparams).dx, $
              dy_from, (*(*info).dataparams).dy, $
              xval_from, (*(*info).dataparams).xval, $
              yval_from, (*(*info).dataparams).yval, $
              xpix_from, (*(*info).dataparams).xpix, $
              ypix_from, (*(*info).dataparams).ypix)
          ENDIF ELSE BEGIN
            ; Else no mapping is occuring, so use main values
            xyp = {x:xp_orig, y:yp_orig}
            xyr = {x:xr_orig, y:yr_orig}
          ENDELSE
          sxyp = CRISPEX_TRANSFORM_DATA2DEVICE(info, X=xyp.x, $
            Y=xyp.y, /MAIN)
          sxyr = CRISPEX_TRANSFORM_DATA2DEVICE(info, X=xyr.x, $
            Y=xyr.y, /MAIN)
        ENDIF
      ENDELSE
			sxp_last = sxyp.x[(SIZE(sxyp.x))[1]-1]-1.5*(*(*info).zooming).factor
			syp_last = sxyp.y[(SIZE(sxyp.y))[1]-1]+1.5*(*(*info).zooming).factor
			IF ~KEYWORD_SET(NO_ENDPOINTS) THEN BEGIN
				PLOTS, sxyp.x, sxyp.y, PSYM = 1, COLOR = !P.COLOR, /DEVICE, $
          THICK=thick, SYMSIZE=symsize
				PLOTS, sxyp.x, sxyp.y, PSYM = 4, COLOR = !P.COLOR, /DEVICE, $
          THICK=thick, SYMSIZE=symsize
			ENDIF
			IF ~KEYWORD_SET(NO_NUMBER) THEN BEGIN
        text_out = STRTRIM(sel_loops[i],2)
        IF KEYWORD_SET(RETRIEVED) THEN $
          text_out = 'L'+text_out $
        ELSE IF KEYWORD_SET(DETECTION) THEN $
          text_out = 'D'+text_out
        XYOUTS,sxp_last,syp_last,text_out, /DEVICE
      ENDIF
			IF ((*(*info).overlayparams).loop_linestyle EQ 1) THEN $
        PLOTS, sxyr.x, sxyr.y, PSYM = 3, COLOR = !P.COLOR, /DEVICE, THICK=thick $
			ELSE $
        PLOTS, sxyr.x, sxyr.y, $
          LINESTYLE = (*(*info).overlayparams).loop_linestyle, COLOR = !P.COLOR,$
          /DEVICE, THICK=thick
    ENDFOR
  ENDIF
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [cfilecount, sel_count], labels=sel_labels
END

PRO CRISPEX_DRAW_MASK_OVERLAYS, event, REFERENCE=reference
; Handles the overlay of a mask
; Assumption throughout is that the mask has positional parameters (i.e.,
; nx/ny, dx/dy, xval/yval, etc.) identical to those of the main data
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  IF KEYWORD_SET(REFERENCE) THEN BEGIN
    xcoords =[(*(*info).zooming).xrefpos,(*(*info).zooming).xrefpos + $
              (*(*info).dataparams).d_refnx]
    ycoords = [(*(*info).zooming).yrefpos,(*(*info).zooming).yrefpos + $
               (*(*info).dataparams).d_refny]
    ; Convert boundaries of reference display to main coordinate system
    IF ((*(*info).dataswitch).wcs_set AND $
      (*(*info).dataswitch).ref_wcs_set) THEN BEGIN
      ; If WCS info available, use that for the transform
      xp = REFORM(((*(*info).dataparams).pix_ref2main[*,xcoords,0])[0,*])
      yp = REFORM(((*(*info).dataparams).pix_ref2main[*,0,ycoords])[1,0,*])
      xy_low_upp = {x:xp, y:yp}
    ENDIF ELSE BEGIN
      ; Else use header information for transform
      xy_low_upp = CRISPEX_TRANSFORM_COORDS(xcoords, ycoords, $
        (*(*info).dataparams).refdx, (*(*info).dataparams).dx, $
        (*(*info).dataparams).refdy, (*(*info).dataparams).dy, $
        (*(*info).dataparams).xval_ref, (*(*info).dataparams).xval, $
        (*(*info).dataparams).yval_ref, (*(*info).dataparams).yval, $
        (*(*info).dataparams).xpix_ref, (*(*info).dataparams).xpix, $
        (*(*info).dataparams).ypix_ref, (*(*info).dataparams).ypix)
    ENDELSE
    ; Determine boundaries of mask to be displayed
    xcoords_new = [ROUND(xy_low_upp.x[0] > 0), $
                   ROUND(xy_low_upp.x[1] < ((*(*info).dataparams).nx-1))]
    ycoords_new = [ROUND(xy_low_upp.y[0] > 0), $
                   ROUND(xy_low_upp.y[1] < ((*(*info).dataparams).ny-1))]
    ; Convert boundaries back to reference coordinate system
    IF ((*(*info).dataswitch).wcs_set AND $
      (*(*info).dataswitch).ref_wcs_set) THEN BEGIN
      ; If WCS info available, use that for the transform
      xp = REFORM(((*(*info).dataparams).pix_ref2main[*,xcoords_new,0])[0,*])
      yp = REFORM(((*(*info).dataparams).pix_ref2main[*,0,ycoords_new])[1,0,*])
      xypos_low_upp = {x:xp, y:yp}
    ENDIF ELSE BEGIN
      ; Else use header information for transform
      xypos_low_upp = CRISPEX_TRANSFORM_COORDS(xcoords_new, ycoords_new, $
        (*(*info).dataparams).dx, (*(*info).dataparams).refdx, $
        (*(*info).dataparams).dy, (*(*info).dataparams).refdy, $
        (*(*info).dataparams).xval, (*(*info).dataparams).xval_ref, $
        (*(*info).dataparams).yval, (*(*info).dataparams).yval_ref, $
        (*(*info).dataparams).xpix, (*(*info).dataparams).xpix_ref, $
        (*(*info).dataparams).ypix, (*(*info).dataparams).ypix_ref)
    ENDELSE
    ; Determine offset positioning of subset of mask slice
    position = [$
      (ROUND(xypos_low_upp.x[0])-(*(*info).zooming).xrefpos) / $
        FLOAT((*(*info).dataparams).d_refnx), $
      (ROUND(xypos_low_upp.y[0])-(*(*info).zooming).yrefpos) / $
        FLOAT((*(*info).dataparams).d_refny), $
      (ROUND(xypos_low_upp.x[1])-(*(*info).zooming).xrefpos) / $
        FLOAT((*(*info).dataparams).d_refnx), $
      (ROUND(xypos_low_upp.y[1])-(*(*info).zooming).yrefpos) / $
        FLOAT((*(*info).dataparams).d_refny)]
  ENDIF ELSE BEGIN
    ; If main data, use defaults
  	xcoords_new = [(*(*info).zooming).xpos, $
  	               (*(*info).zooming).xpos + (*(*info).dataparams).d_nx]
  	ycoords_new = [(*(*info).zooming).ypos, $
  	               (*(*info).zooming).ypos + (*(*info).dataparams).d_ny]
    position = [0,0,1,1]
  ENDELSE
  TVLCT, r_cur, g_cur, b_cur, /GET
	LOADCT, (*(*info).overlayparams).maskct, /SILENT
	CONTOUR, (*(*(*info).data).maskslice)[xcoords_new[0]:xcoords_new[1],$
    ycoords_new[0]:ycoords_new[1]], LEVELS=1, $
    /ISOTROPIC, XS=13, YS=13, COLOR=(*(*info).overlayparams).maskcolor, $
    POSITION=position, /NORMAL, /NOERASE
;	CONTOUR,(*(*(*info).data).maskslice)[x_low:x_upp,y_low:y_upp], $
;    COLOR=(*(*info).overlayparams).maskcolor-100, LEVELS = 1, $
;    /ISOTROPIC, XS=13,YS=13,POSITION=[0,0,1,1],/NORMAL, /NOERASE
  TVLCT, r_cur, g_cur, b_cur
END

PRO CRISPEX_DRAW_RASTER_OVERLAYS, event, REFERENCE=reference, SJI=sji
; Handles the overlay of raster contours on REFERENCE or SJI
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	LOADCT, (*(*info).overlayparams).maskct, /SILENT
  FOR i=0,(*(*info).dataparams).nx-1 DO BEGIN
    IF KEYWORD_SET(REFERENCE) THEN $
      sxyraster = CRISPEX_TRANSFORM_DATA2DEVICE(info, $
        X=(*(*info).dataparams).pix_main2ref[0,i,*], $
        Y=(*(*info).dataparams).pix_main2ref[1,i,*], /REF) $
    ELSE IF KEYWORD_SET(SJI) THEN $
      sxyraster = CRISPEX_TRANSFORM_DATA2DEVICE(info, $
        X=(*(*info).dataparams).pix_main2sji[0,i,*], $
        Y=(*(*info).dataparams).pix_main2sji[1,i,*], /SJI)
    PLOTS, sxyraster.x, sxyraster.y, COLOR=(*(*info).overlayparams).maskcolor, /DEVICE
  ENDFOR
	LOADCT, 0, /SILENT
END

PRO CRISPEX_DRAW_RASTER_TIMING_OVERLAYS, event, MAIN=main, REFERENCE=reference
; Handles the overlay of raster contours on REFERENCE or SJI
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  IF ((*(*info).dispparams).master_time EQ 0) OR ((*(*info).dispparams).master_time EQ 2) THEN BEGIN
    IF (SIZE((*(*info).dataparams).tarr_raster_main, /N_DIM) EQ 2) THEN $
      tarr_raster_ref = REFORM(((*(*info).dataparams).tarr_raster_main)[*,$
                          (*(*info).dispparams).t_main])  $
    ELSE $
      tarr_raster_ref = *(*(*info).dispparams).tarr_main
  ENDIF 
  IF ((*(*info).dispparams).master_time GE 1) THEN BEGIN
    IF (SIZE((*(*info).dataparams).tarr_raster_main, /N_DIM) EQ 2) THEN $
      tarr_raster_main = REFORM(((*(*info).dataparams).tarr_raster_main)[*,$
                          (*(*info).dispparams).t_main])  $
    ELSE $
      tarr_raster_main = *(*(*info).dispparams).tarr_main
  ENDIF
  CASE (*(*info).dispparams).master_time OF
    0:  BEGIN
          IF KEYWORD_SET(MAIN) THEN $
            ; Main is master timer, so sets "reference"
            tidx_main_sel = (*(*info).dispparams).toffset_main $
          ELSE BEGIN
            ; Check whether main is a raster, else get from single array
            IF (SIZE((*(*info).dataparams).tarr_raster_main, /N_DIM) EQ 2) THEN $
              tval_main_sel = ((*(*info).dataparams).tarr_raster_main)[$
                (*(*info).dispparams).toffset_main, (*(*info).dispparams).t_main] $
            ELSE $
              tval_main_sel = $
                (*(*(*info).dispparams).tarr_main)[(*(*info).dispparams).t_main]
            tdiff = ABS(tarr_raster_ref - tval_main_sel)
            tidx_ref_sel = (WHERE(tdiff EQ MIN(tdiff, /NAN)))[0]
          ENDELSE
        END
    1:  BEGIN
          ; Reference is master timer, so sets "reference"
          IF KEYWORD_SET(REFERENCE) THEN $
            tidx_ref_sel = (*(*info).dispparams).toffset_ref $
          ELSE BEGIN
            ; Check whether reference is a raster, else get from single array
            IF (SIZE((*(*info).dataparams).tarr_raster_ref, /N_DIM) EQ 2) THEN $
              tval_ref_sel = ((*(*info).dataparams).tarr_raster_ref)[$
                (*(*info).dispparams).toffset_ref, (*(*info).dispparams).t_ref] $
            ELSE $
              tval_ref_sel = $
                (*(*(*info).dispparams).tarr_ref)[(*(*info).dispparams).t_ref]
            tdiff = ABS(tarr_raster_main - tval_ref_sel)
            tidx_main_sel = (WHERE(tdiff EQ MIN(tdiff, /NAN)))[0]
          ENDELSE
        END
    2:  BEGIN
          ; SJI is master timer, so sets "reference"
          tval_sji_sel = $
            (*(*(*info).dispparams).tarr_sji)[(*(*info).dispparams).t_sji]
          IF KEYWORD_SET(MAIN) THEN BEGIN
            tdiff = ABS(tarr_raster_main - tval_sji_sel)
            tidx_main_sel = (WHERE(tdiff EQ MIN(tdiff, /NAN)))[0]
          ENDIF ELSE BEGIN
            tdiff = ABS(tarr_raster_ref - tval_sji_sel)
            tidx_ref_sel = (WHERE(tdiff EQ MIN(tdiff, /NAN)))[0]
          ENDELSE
        END
  ENDCASE
	LOADCT, (*(*info).overlayparams).maskct, /SILENT
  IF KEYWORD_SET(MAIN) THEN BEGIN
    xyout_low = CRISPEX_TRANSFORM_DATA2DEVICE(info, X_IN=tidx_main_sel, $
      Y_IN=(*(*info).zooming).ypos, /MAIN) 
    xyout_upp = CRISPEX_TRANSFORM_DATA2DEVICE(info, X_IN=tidx_main_sel, $
      Y_IN=(*(*info).zooming).ypos+(*(*info).dataparams).d_ny, /MAIN) 
  ENDIF ELSE IF KEYWORD_SET(REFERENCE) THEN BEGIN
    xyout_low = CRISPEX_TRANSFORM_DATA2DEVICE(info, X_IN=tidx_ref_sel, $
      Y_IN=(*(*info).zooming).yrefpos, /REF) 
    xyout_upp = CRISPEX_TRANSFORM_DATA2DEVICE(info, X_IN=tidx_ref_sel, $
      Y_IN=(*(*info).zooming).yrefpos+(*(*info).dataparams).d_refny, /REF) 
  ENDIF
  x0 = REPLICATE(xyout_low.x, 2)
  y0 = [xyout_low.y, xyout_upp.y]
  x1 = x0
  y1 = y0 + [20,-20]
  PLOTS,x0,[y0[0],y1[1]], COLOR=(*(*info).overlayparams).maskcolor, $
    LINE=1,/DEVICE
  FOR i=0,N_ELEMENTS(x0)-1 DO $
    ARROW, x0[i], y0[i], x1[i], y1[i], HSIZE=7, HTHICK=7, $
      COLOR=(*(*info).overlayparams).maskcolor, THICK=2, /SOLID, $
      /DEVICE
	LOADCT, 0, /SILENT
END

PRO CRISPEX_DRAW_GET_SPECTRAL_AXES, event, MAIN=main, REFERENCE=reference
; Handles determination of TICKINTERVAL of spectral axes
  ; should be called whenever changing the number of displayed diagnostics
  ; AND on startup
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  ; Write current variables to dummy variables depending on case
  IF KEYWORD_SET(MAIN) THEN BEGIN
    disp_diagnostics = (*(*info).intparams).disp_diagnostics
    ndisp_diagnostics = (*(*info).intparams).ndisp_diagnostics
    diag_width = (*(*info).intparams).diag_width
    diag_start = (*(*info).intparams).diag_start
    lps = (*(*info).dataparams).lps
    v_dop = (*(*info).plotaxes).v_dop
  ENDIF ELSE IF KEYWORD_SET(REFERENCE) THEN BEGIN
    disp_diagnostics = (*(*info).intparams).disp_refdiagnostics
    ndisp_diagnostics = (*(*info).intparams).ndisp_refdiagnostics
    diag_width = (*(*info).intparams).refdiag_width
    diag_start = (*(*info).intparams).refdiag_start
    lps = (*(*info).dataparams).reflps
    v_dop = (*(*info).plotaxes).v_dop_ref
  ENDIF
  ; Determine settings from displayed diagnostics
  ; disp_diagnostics will always have at least 1 element non-zero
  wheredisp = WHERE(disp_diagnostics EQ 1)
  diag_widths = diag_width[wheredisp]
  diag_starts = diag_start[wheredisp]
  diag_ratio = diag_widths / FLOAT(TOTAL(diag_widths))
  IF (ndisp_diagnostics GT 1) THEN BEGIN
    lambda_widths = FLTARR(ndisp_diagnostics)
    dop_widths = FLTARR(ndisp_diagnostics)
    FOR d=0,ndisp_diagnostics-1 DO BEGIN
      lambda_widths[d] = lps[diag_starts[d]+diag_widths[d]-1] - lps[diag_starts[d]]
      dop_widths[d] = (*v_dop[wheredisp[d]])[diag_widths[d]-1] - $
        (*v_dop[wheredisp[d]])[0]
    ENDFOR
    order = FLOOR(ALOG10(lambda_widths))
    int_widths = FLOOR(lambda_widths/10^FLOAT(order))*10^FLOAT(order)
    wheremin = WHERE(int_widths EQ MIN(int_widths, /NAN, MAX=int_widths_max))
    wheremax = WHERE(int_widths EQ int_widths_max)
    ; Have at least two major tickmarks per range for the smallest range
    xtickint_def = (int_widths[wheremin]/2.)[0]
    xtickinterval = [xtickint_def, (int_widths[wheremax])[0]]
    doporder = FLOOR(ALOG10(dop_widths))
    int_dopwidths = FLOOR(dop_widths/10^FLOAT(doporder))*10^FLOAT(doporder)
    wheredopmin = WHERE(int_dopwidths EQ MIN(int_dopwidths, /NAN, MAX=int_dopwidths_max))
    wheredopmax = WHERE(int_dopwidths EQ int_dopwidths_max)
    ; Have at least two major tickmarks per range for the smallest range
    xdoptickint_def = (int_dopwidths[wheredopmin]/2.)[0]
    xdoptickinterval = [xdoptickint_def, (int_dopwidths[wheredopmax])[0]]
    IF (ABS((xtickinterval[0]*2.)/xtickinterval[1]) GT 0.3) THEN BEGIN
      xtickinterval /= 2.
      xdoptickinterval[0] /= 2.
    ENDIF
    ; Convert xtickinterval[1] to number of tickmarks, instead of tick value difference
    xtickinterval[1] = ROUND(xtickinterval[1]/(xtickinterval[0] > 1.))
    xdoptickinterval[1] = ROUND(xdoptickinterval[1]/((2.*xdoptickinterval[0]) > 1.))
  ENDIF ELSE BEGIN
    xtickinterval = 0
    xdoptickinterval = 0
  ENDELSE
  ; Save results to appropriate variables
  IF KEYWORD_SET(MAIN) THEN BEGIN
    *(*(*info).plotaxes).xtickinterval = xtickinterval
    *(*(*info).plotaxes).xdoptickinterval = xdoptickinterval
    ; Determine proportional spectral window sizes
    *(*(*info).intparams).wheredispdiag = wheredisp
    *(*(*info).intparams).diag_widths = diag_widths
    *(*(*info).intparams).diag_starts = diag_starts 
    *(*(*info).plotaxes).diag_ratio = diag_ratio 
    IF (*(*info).winswitch).showsp THEN $
      *(*(*info).plotaxes).diag_range_sp = *(*(*info).plotaxes).diag_ratio * $
        (*(*info).plotpos).xplspw 
    IF (*(*info).winswitch).showphis THEN $
      *(*(*info).plotaxes).diag_range_phis = *(*(*info).plotaxes).diag_ratio * $
        (*(*info).plotpos).phisxplspw
    (*(*info).plotswitch).xtick_reset = 1
    (*(*info).plotswitch).xdoptick_reset = 1
  ENDIF ELSE IF KEYWORD_SET(REFERENCE) THEN BEGIN
    *(*(*info).plotaxes).xreftickinterval = xtickinterval
    *(*(*info).plotaxes).xrefdoptickinterval = xdoptickinterval
    ; Determine proportional spectral window sizes
    *(*(*info).intparams).wheredisprefdiag = wheredisp 
    *(*(*info).intparams).refdiag_widths = diag_widths
    *(*(*info).intparams).refdiag_starts = diag_starts 
    *(*(*info).plotaxes).refdiag_ratio = diag_ratio 
    IF (*(*info).winswitch).showrefsp THEN $
      *(*(*info).plotaxes).refdiag_range_sp = *(*(*info).plotaxes).refdiag_ratio * $
        (*(*info).plotpos).refxplspw 
    (*(*info).plotswitch).xreftick_reset = 1
    (*(*info).plotswitch).xrefdoptick_reset = 1
  ENDIF
END

PRO CRISPEX_DRAW, event, NO_MAIN=no_main, NO_REF=no_ref, NO_PHIS=no_phis
; Handles the actual drawing of the data into the respective open display windows
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF ((*(*info).curs).lockset AND ((*(*info).overlayswitch).loopslit NE 1) AND $
     ((*(*info).meas).spatial_measurement EQ 0)) THEN BEGIN
		(*(*info).curs).sx = (*(*info).curs).sxlock	
    (*(*info).curs).sy = (*(*info).curs).sylock
    IF ((*(*info).winids).reftlb NE 0) THEN BEGIN
      (*(*info).curs).sxref = (*(*info).curs).sxreflock
      (*(*info).curs).syref = (*(*info).curs).syreflock
    ENDIF
    IF ((*(*info).winids).sjitlb NE 0) THEN BEGIN
      (*(*info).curs).sxsji = (*(*info).curs).sxsjilock
      (*(*info).curs).sysji = (*(*info).curs).sysjilock
    ENDIF
	ENDIF 
	CRISPEX_DRAW_IMREF, event, NO_MAIN=no_main, NO_REF=no_ref
	IF ((*(*info).winswitch).showls OR (*(*info).winswitch).showsp OR $
    (*(*info).winswitch).showrefls OR (*(*info).winswitch).showrefsp) THEN $
      CRISPEX_DRAW_SPECTRAL, event, NO_MAIN=no_main, NO_REF=no_ref, NO_PHIS=no_phis
	IF ((*(*info).winswitch).showloop OR (*(*info).winswitch).showrefloop OR $
    (*(*info).winswitch).showrestloop OR (*(*info).winswitch).showretrdet) THEN $
      CRISPEX_DRAW_TIMESLICES, event
	IF (*(*info).winswitch).showint THEN CRISPEX_DRAW_INT, event
  CRISPEX_DRAW_FEEDBPARAMS, event
END

PRO CRISPEX_DRAW_FEEDBPARAMS, event
; Prints all feedback parameters to appropriate fields
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  ; Position parameters
  ; Main
  IF ((*(*info).dispswitch).xy_out_of_range EQ 0) THEN BEGIN
    xval = STRING(LONG((*(*info).dataparams).x), $
      FORMAT=(*(*info).paramparams).xcoord_format)
    yval = STRING(LONG((*(*info).dataparams).y), $
      FORMAT=(*(*info).paramparams).ycoord_format)
    IF (*(*info).dataswitch).wcs_set THEN BEGIN
      xy_real = CRISPEX_TRANSFORM_GET_WCS((*(*info).dataparams).x, $
        (*(*info).dataparams).y, (*(*info).dataparams).wcs_main, $
        /COORD, /NO_ROUND)
      xreal_val = xy_real.x
      yreal_val = xy_real.y
    ENDIF ELSE BEGIN
      xreal_val = FLOAT(xval*(*(*info).dataparams).dx)
      yreal_val = FLOAT(yval*(*(*info).dataparams).dy)
    ENDELSE
    xval_real = STRING(xreal_val, $
      FORMAT=(*(*info).paramparams).xcoord_real_format)
    yval_real = STRING(yreal_val, $
      FORMAT=(*(*info).paramparams).ycoord_real_format)
  ENDIF ELSE BEGIN
    xval = 'N/A'
    yval = xval
    xval_real = xval 
    yval_real = xval
  ENDELSE
  WIDGET_CONTROL, (*(*info).ctrlsparam).xycoord_val, $
    SET_VALUE='('+xval+','+yval+')'
  WIDGET_CONTROL, (*(*info).ctrlsparam).xycoord_real_val, $
    SET_VALUE='('+xval_real+','+yval_real+')'
  ; Reference
  IF (*(*info).winswitch).showref THEN BEGIN
    IF ((*(*info).dispswitch).xyref_out_of_range EQ 0) THEN BEGIN
      xrefval = STRING(LONG((*(*info).dataparams).xref), $
        FORMAT=(*(*info).paramparams).refxcoord_format)
      yrefval = STRING(LONG((*(*info).dataparams).yref), $
        FORMAT=(*(*info).paramparams).refycoord_format)
      IF (*(*info).dataswitch).ref_wcs_set THEN BEGIN
        xyref_real = CRISPEX_TRANSFORM_GET_WCS((*(*info).dataparams).xref, $
          (*(*info).dataparams).yref, (*(*info).dataparams).wcs_ref, $
          /COORD, /NO_ROUND)
        xreal_val = xyref_real.x
        yreal_val = xyref_real.y
      ENDIF ELSE BEGIN
        xreal_val = FLOAT(xrefval*(*(*info).dataparams).refdx)
        yreal_val = FLOAT(yrefval*(*(*info).dataparams).refdy)
      ENDELSE
      xrefval_real = STRING(xreal_val, $
        FORMAT=(*(*info).paramparams).refxcoord_real_format)
      yrefval_real = STRING(yreal_val, $
        FORMAT=(*(*info).paramparams).refycoord_real_format)
    ENDIF ELSE BEGIN
      xrefval = 'N/A'
      yrefval = xrefval
      xrefval_real = xrefval 
      yrefval_real = xrefval
    ENDELSE
    WIDGET_CONTROL, (*(*info).ctrlsparam).refxycoord_val, $
      SET_VALUE='('+xrefval+','+yrefval+')'
    WIDGET_CONTROL, (*(*info).ctrlsparam).refxycoord_real_val, $
      SET_VALUE='('+xrefval_real+','+yrefval_real+')'
  ENDIF
  ; SJI
  IF (*(*info).winswitch).showsji THEN BEGIN
    IF ((*(*info).dispswitch).xysji_out_of_range EQ 0) THEN BEGIN
      xsjival = STRING(LONG((*(*info).dataparams).xsji), $
        FORMAT=(*(*info).paramparams).sjixcoord_format)
      ysjival = STRING(LONG((*(*info).dataparams).ysji), $
        FORMAT=(*(*info).paramparams).sjiycoord_format)
      IF (*(*info).dataswitch).sji_wcs_set THEN BEGIN
        xysji_real = CRISPEX_TRANSFORM_GET_WCS((*(*info).dataparams).xsji, $
          (*(*info).dataparams).ysji, (*(*info).dataparams).wcs_sji, $
          /COORD, /NO_ROUND)
        xreal_val = xysji_real.x
        yreal_val = xysji_real.y
      ENDIF ELSE BEGIN
        xreal_val = FLOAT(xsjival*(*(*info).dataparams).sjidx)
        yreal_val = FLOAT(ysjival*(*(*info).dataparams).sjidy)
      ENDELSE
      xsjival_real = STRING(xreal_val, $
        FORMAT=(*(*info).paramparams).sjixcoord_real_format)
      ysjival_real = STRING(yreal_val, $
        FORMAT=(*(*info).paramparams).sjiycoord_real_format)
    ENDIF ELSE BEGIN
      xsjival = 'N/A'
      ysjival = xsjival
      xsjival_real = xsjival 
      ysjival_real = xsjival
    ENDELSE
    WIDGET_CONTROL, (*(*info).ctrlsparam).sjixycoord_val, $
      SET_VALUE='('+xsjival+','+ysjival+')'
    WIDGET_CONTROL, (*(*info).ctrlsparam).sjixycoord_real_val, $
      SET_VALUE='('+xsjival_real+','+ysjival_real+')'
  ENDIF

  ; Spectral parameters
  ; Main
  lp_idx_txt = STRING((*(*info).dataparams).lp, $
    FORMAT=(*(*info).paramparams).lp_idx_format)
  WIDGET_CONTROL, (*(*info).ctrlsparam).lp_idx_val, SET_VALUE=lp_idx_txt
  IF (*(*info).plotswitch).v_dop_set THEN BEGIN
    lp_real_txt = STRING((*(*info).dataparams).lps[(*(*info).dataparams).lp], $
      FORMAT=(*(*info).paramparams).lp_real_format)
    lp_vdop_txt = STRING((*(*(*info).plotaxes).v_dop[$
      (*(*info).intparams).lp_diag_all])[$
      (*(*info).dataparams).lp-(*(*info).intparams).diag_start[$
      (*(*info).intparams).lp_diag_all]], $
      FORMAT=(*(*info).paramparams).lp_vdop_format)
    WIDGET_CONTROL, (*(*info).ctrlsparam).lp_real_val, SET_VALUE=lp_real_txt
    WIDGET_CONTROL, (*(*info).ctrlsparam).lp_vdop_val, SET_VALUE=lp_vdop_txt
  ENDIF
  ; Reference
  IF ((*(*info).dataparams).refnlp GT 1) THEN BEGIN
    lp_ref_idx_txt = STRING((*(*info).dataparams).lp_ref, $
      FORMAT=(*(*info).paramparams).lp_ref_idx_format)
    WIDGET_CONTROL, (*(*info).ctrlsparam).lp_ref_idx_val, $
      SET_VALUE=lp_ref_idx_txt
    IF (*(*info).plotswitch).v_dop_set_ref THEN BEGIN
      lp_ref_real_txt = STRING((*(*info).dataparams).reflps[$
        (*(*info).dataparams).lp_ref], $
        FORMAT=(*(*info).paramparams).lp_ref_real_format)
      lp_ref_vdop_txt = STRING((*(*(*info).plotaxes).v_dop_ref[$
        (*(*info).intparams).lp_ref_diag_all])[(*(*info).dataparams).lp_ref-$
        (*(*info).intparams).refdiag_start[$
        (*(*info).intparams).lp_ref_diag_all]], $
        FORMAT=(*(*info).paramparams).lp_ref_vdop_format)
      WIDGET_CONTROL, (*(*info).ctrlsparam).lp_ref_real_val, $
        SET_VALUE=lp_ref_real_txt
      WIDGET_CONTROL, (*(*info).ctrlsparam).lp_ref_vdop_val, $
        SET_VALUE=lp_ref_vdop_txt
    ENDIF
  ENDIF

  ; Time parameters
  ; Main
  t_idx_txt = STRING(LONG((*(*info).dispparams).t_main),$
    FORMAT=(*(*info).paramparams).t_idx_format)
  WIDGET_CONTROL, (*(*info).ctrlsparam).t_idx_val, SET_VALUE=t_idx_txt
  IF ((*(*info).paramswitch).dt_set AND $
     ((*(*info).dataparams).mainnt GT 1)) THEN BEGIN
    t_real_txt = STRING((*(*(*info).dispparams).utc_main)[$
      (*(*info).dispparams).t],FORMAT=(*(*info).paramparams).t_real_format)
    WIDGET_CONTROL, (*(*info).ctrlsparam).t_real_val, SET_VALUE=t_real_txt
  ENDIF
  IF (*(*info).paramswitch).t_raster THEN BEGIN
    IF ((*(*info).dispswitch).xy_out_of_range EQ 0) THEN $
      t_raster_real_txt = STRING((*(*info).dataparams).utc_raster_main[$
        (*(*info).dataparams).x, (*(*info).dispparams).t_main], $
        FORMAT=(*(*info).paramparams).t_raster_real_format) $
    ELSE $
      t_raster_real_txt = 'N/A'
    WIDGET_CONTROL, (*(*info).ctrlsparam).t_raster_real_val, $
      SET_VALUE=t_raster_real_txt
  ENDIF
  ; Reference
  IF (*(*info).winswitch).showref THEN BEGIN
    t_ref_idx_txt = STRING(LONG((*(*info).dispparams).t_ref),$
      FORMAT=(*(*info).paramparams).t_ref_idx_format)
    WIDGET_CONTROL, (*(*info).ctrlsparam).t_ref_idx_val, $
      SET_VALUE=t_ref_idx_txt
    IF (*(*info).paramswitch).dt_set THEN BEGIN
      t_ref_real_txt = $
        STRING((*(*(*info).dispparams).utc_ref)[(*(*info).dispparams).t],$
        FORMAT=(*(*info).paramparams).t_ref_real_format)
      WIDGET_CONTROL, (*(*info).ctrlsparam).t_ref_real_val, $
        SET_VALUE=t_ref_real_txt
    ENDIF
    IF (*(*info).paramswitch).t_raster_ref THEN BEGIN
      IF ((*(*info).dispswitch).xyref_out_of_range EQ 0) THEN BEGIN
        IF ((*(*info).dataparams).refnt GT 1) THEN $
          t_raster_ref_real_txt = STRING((*(*info).dataparams).utc_raster_ref[$
            (*(*info).dataparams).xref,(*(*info).dispparams).t_ref], $
            FORMAT=(*(*info).paramparams).t_raster_ref_real_format) $
        ELSE $
          t_raster_ref_real_txt = STRING((*(*info).dataparams).utc_raster_ref[$
            (*(*info).dataparams).xref], $
            FORMAT=(*(*info).paramparams).t_raster_ref_real_format)
      ENDIF ELSE $
        t_raster_ref_real_txt = 'N/A'
      WIDGET_CONTROL, (*(*info).ctrlsparam).t_raster_ref_real_val, $
        SET_VALUE=t_raster_ref_real_txt
    ENDIF
  ENDIF
  ; SJI
  IF (*(*info).winswitch).showsji THEN BEGIN
    IF ((*(*info).dataparams).sjint GT 1) THEN BEGIN
      t_sji_idx_txt = STRING(LONG((*(*info).dispparams).t_sji), $
        FORMAT=(*(*info).paramparams).t_sji_idx_format)
      WIDGET_CONTROL, (*(*info).ctrlsparam).t_sji_idx_val, $
        SET_VALUE=t_sji_idx_txt
      IF (*(*info).paramswitch).dt_set THEN BEGIN
        t_sji_real_txt = $
          STRING((*(*(*info).dispparams).utc_sji)[(*(*info).dispparams).t],$
          FORMAT=(*(*info).paramparams).t_sji_real_format)
        WIDGET_CONTROL, (*(*info).ctrlsparam).t_sji_real_val, $
          SET_VALUE=t_sji_real_txt
      ENDIF
    ENDIF
  ENDIF
  
  ; Data values parameters
  ; Main
  IF ((*(*info).dispswitch).xy_out_of_range EQ 0) THEN BEGIN 
    datadims = SIZE(*(*(*info).data).xyslice,/N_DIMENSIONS)
    IF (datadims EQ 2) THEN $
      act_dataval = (*(*(*info).data).xyslice)[LONG((*(*info).dataparams).x), $
        LONG((*(*info).dataparams).y)] $
    ELSE $  ; Failsafe for IRIS sit-and-stare
      act_dataval = (*(*(*info).data).xyslice)[LONG((*(*info).dataparams).y)]
    IF ((FINITE(act_dataval) EQ 1) AND (act_dataval NE 0)) THEN $
      order = FLOOR(ALOG10(ABS(act_dataval))) $
    ELSE $
      order = 0
    IF ((order LE -2) OR (order GE 3)) THEN $
      format = '(E10.4)' $
    ELSE $
      format = '(F9.2)'
    dataval_real_txt = STRING(act_dataval, FORMAT=format) 
  ENDIF ELSE $
    dataval_real_txt = 'N/A'
  WIDGET_CONTROL, (*(*info).ctrlsparam).dataval_real_val, $
    SET_VALUE=dataval_real_txt
  ; Reference
  IF (*(*info).winswitch).showref THEN BEGIN
    IF ((*(*info).dispswitch).xyref_out_of_range EQ 0) THEN BEGIN
      datadims = SIZE(*(*(*info).data).refslice,/N_DIMENSIONS)
      IF (datadims EQ 2) THEN $
        act_ref_dataval = (*(*(*info).data).refslice)[$
          LONG((*(*info).dataparams).xref), LONG((*(*info).dataparams).yref)] $
      ELSE $  ; Failsafe for IRIS sit-and-stare
        act_ref_dataval = (*(*(*info).data).refslice)[$
          LONG((*(*info).dataparams).yref)]
      IF ((FINITE(act_ref_dataval) EQ 1) AND (act_ref_dataval NE 0)) THEN $
        order = FLOOR(ALOG10(ABS(act_ref_dataval))) $
      ELSE $
        order = 0
      IF ((order LE -2) OR (order GE 3)) THEN $
        format = '(E10.4)' $
      ELSE $
        format = '(F9.2)'
      dataval_ref_real_txt = STRING(act_ref_dataval, FORMAT=format)
    ENDIF ELSE $
      dataval_ref_real_txt = 'N/A'
    WIDGET_CONTROL, (*(*info).ctrlsparam).dataval_ref_real_val, $
      SET_VALUE=dataval_ref_real_txt
  ENDIF
  ; SJI
  IF (*(*info).winswitch).showsji THEN BEGIN
    IF ((*(*info).dispswitch).xysji_out_of_range EQ 0) THEN BEGIN
      act_sji_dataval = (*(*(*info).data).sjislice)[$
        LONG((*(*info).dataparams).xsji), LONG((*(*info).dataparams).ysji)]
      IF ((FINITE(act_sji_dataval) EQ 1) AND (act_sji_dataval NE 0)) THEN $
        order = FLOOR(ALOG10(ABS(act_sji_dataval))) $
      ELSE $
        order = 0
      IF ((order LE -2) OR (order GE 3)) THEN $
        format = '(E10.4)' $
      ELSE $
        format = '(F9.2)'
      dataval_sji_real_txt = STRING(act_sji_dataval, FORMAT=format)
    ENDIF ELSE $
      dataval_sji_real_txt = 'N/A'
    WIDGET_CONTROL, (*(*info).ctrlsparam).dataval_sji_real_val, $
      SET_VALUE=dataval_sji_real_txt
  ENDIF

  ; Zoom value
	WIDGET_CONTROL, (*(*info).ctrlsparam).zoom_val, $
    SET_VALUE = STRING((*(*info).zooming).factor*100.,FORMAT='(I4)')+'%'
END

PRO CRISPEX_DRAW_IMREF, event, NO_MAIN=no_main, NO_REF=no_ref
; (Re)draw main and reference image window procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF ~KEYWORD_SET(NO_MAIN) THEN CRISPEX_DRAW_XY, event
	IF (~KEYWORD_SET(NO_REF) AND (*(*info).winswitch).showref) THEN CRISPEX_DRAW_REF, event
	IF (*(*info).winswitch).showimref THEN CRISPEX_DRAW_IMREF_BLINK, event
	IF (*(*info).winswitch).showdop THEN CRISPEX_DRAW_DOPPLER, event
  IF (*(*info).winswitch).showsji THEN CRISPEX_DRAW_SJI, event
END

PRO CRISPEX_DRAW_SPECTRAL, event, NO_MAIN=no_main, NO_REF=no_ref, NO_PHIS=no_phis
; (Re)draw spectral windows procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  IF (~KEYWORD_SET(NO_MAIN) AND $
    ((*(*info).winswitch).showls OR (*(*info).winswitch).showsp)) THEN $
      CRISPEX_DRAW_SPECTRAL_MAIN, event
	IF (~KEYWORD_SET(NO_REF) AND $
    ((*(*info).winswitch).showrefls OR (*(*info).winswitch).showrefsp)) THEN $
      CRISPEX_DRAW_SPECTRAL_REF, event
	IF (~KEYWORD_SET(NO_PHIS) AND $
      ((*(*info).winswitch).showphis AND (((*(*info).pbparams).mode EQ 'PAUSE') OR $
      (*(*info).dispparams).phislice_update))) THEN CRISPEX_DRAW_PHIS, event		
END

PRO CRISPEX_DRAW_TIMESLICES, event
; (Re)draw timeslices procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (*(*info).winswitch).showloop THEN CRISPEX_DRAW_LOOPSLAB, event 
	IF (*(*info).winswitch).showrefloop THEN CRISPEX_DRAW_REFLOOPSLAB, event 
	IF (*(*info).winswitch).showrestloop THEN CRISPEX_DRAW_REST_LOOP, event
	IF (*(*info).winswitch).showretrdet THEN CRISPEX_DRAW_RETR_DET, event
END

PRO CRISPEX_DRAW_SUBCOLOR, event, imref, subcolor, minimum, maximum, $
  XYRANGE=xyrange, SJI=sji, REFERENCE=reference
; Determines the color beneath the cursor to get the cursor color
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (N_ELEMENTS(XYRANGE) EQ 0) THEN BEGIN
    IF KEYWORD_SET(SJI) THEN BEGIN
      xcurs = LONG((*(*info).dataparams).xsji)
      ycurs = LONG((*(*info).dataparams).ysji)
      xfirst= (*(*info).dispparams).xsji_first
      xlast = (*(*info).dispparams).xsji_last
      yfirst= (*(*info).dispparams).ysji_first
      ylast = (*(*info).dispparams).ysji_last
    ENDIF ELSE IF KEYWORD_SET(REFERENCE) THEN BEGIN
      xcurs = LONG((*(*info).dataparams).xref)
      ycurs = LONG((*(*info).dataparams).yref)
      xfirst= (*(*info).dispparams).xref_first
      xlast = (*(*info).dispparams).xref_last
      yfirst= (*(*info).dispparams).yref_first
      ylast = (*(*info).dispparams).yref_last
    ENDIF ELSE BEGIN
      xcurs = LONG((*(*info).dataparams).x)
      ycurs = LONG((*(*info).dataparams).y)
      xfirst= (*(*info).dispparams).x_first
      xlast = (*(*info).dispparams).x_last
      yfirst= (*(*info).dispparams).y_first
      ylast = (*(*info).dispparams).y_last
    ENDELSE
      x_upp = xcurs+5 > xfirst < xlast
      x_low = xcurs-5 > xfirst < xlast
      y_upp = ycurs+5 > yfirst < ylast
      y_low = ycurs-5 > yfirst < ylast
	ENDIF ELSE BEGIN
		x_low = xyrange[0]	&	x_upp = xyrange[1]
		y_low = xyrange[2]	&	y_upp = xyrange[3]
	ENDELSE
  scale_idx = $
    ((imref EQ 0) OR (imref EQ 2)) * (*(*info).intparams).lp_diag_all + $
    ((imref GT 0)+(imref GT 2)) * (*(*info).intparams).ndiagnostics + $
    (imref EQ 1) * (*(*info).intparams).lp_ref_diag_all + $
    (imref GT 1) * (*(*info).intparams).nrefdiagnostics ;+ $
;    (imref GT 2)
	IF (imref EQ 0) THEN $
		selected_data = (*(*(*info).data).imagedata)[$
      (*(*info).dispparams).t_main * (*(*info).dataparams).nlp * $
      (*(*info).dataparams).ns + (*(*info).dataparams).s * $
      (*(*info).dataparams).nlp + (*(*info).dataparams).lp]$
	ELSE IF (imref EQ 1) THEN BEGIN
		IF ((*(*info).dataparams).refnt GT 1) THEN $
      selected_data = (*(*(*info).data).refdata)[(*(*info).dispparams).t_ref *  $
        (*(*info).dataparams).refnlp + (*(*info).dataparams).lp_ref]$
    ELSE $
			selected_data = (*(*(*info).data).refdata)[(*(*info).dataparams).lp_ref]
	ENDIF ELSE IF (imref EQ 2) THEN	$
    selected_data = *(*(*info).data).dopslice $
  ELSE IF (imref EQ 3) THEN $
    selected_data = *(*(*info).data).sjislice 
  minimum = MIN(selected_data, MAX=maximum, /NAN)
  minmax = CRISPEX_SCALING_CONTRAST(minimum,maximum,$
    (*(*info).scaling).minimum[scale_idx],(*(*info).scaling).maximum[scale_idx])
	scaled_data = BYTSCL(selected_data[x_low:x_upp, y_low:y_upp], $
    MIN=minmax[0], MAX=minmax[1], /NAN)
	subcolor = MEAN(scaled_data, /NAN)
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [x_low,x_upp,y_low,y_upp,subcolor], $
      labels=['x_low','x_upp','y_low','y_upp','subcolor']
END

PRO CRISPEX_DRAW_SCALING, event, finalimage, minimum, maximum, $
  MAIN=main, DOPPLER=doppler, REFERENCE=reference, SJI=sji, $
  SELECTED_DATA=selected_data
; Determines the minimum and maximum value for the image scaling
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	x_low = (*(*info).zooming).xpos
	y_low = (*(*info).zooming).ypos
  x_upp = (*(*info).zooming).xpos + (*(*info).dataparams).d_nx
  y_upp = (*(*info).zooming).ypos + (*(*info).dataparams).d_ny
  IF (*(*info).dataswitch).sjifile THEN BEGIN
  	xsji_low = (*(*info).zooming).xsjipos
  	ysji_low = (*(*info).zooming).ysjipos
    xsji_upp = (*(*info).zooming).xsjipos + (*(*info).dataparams).d_sjinx
    ysji_upp = (*(*info).zooming).ysjipos + (*(*info).dataparams).d_sjiny
  ENDIF
  IF (*(*info).dataswitch).reffile THEN BEGIN
  	xref_low = (*(*info).zooming).xrefpos
  	yref_low = (*(*info).zooming).yrefpos
    xref_upp = (*(*info).zooming).xrefpos + (*(*info).dataparams).d_refnx
    yref_upp = (*(*info).zooming).yrefpos + (*(*info).dataparams).d_refny
  ENDIF
  ; sel = 0 -> main
  ; sel = 1 -> reference
  ; sel = 2 -> doppler
  ; sel = 3 -> sji
  ; imagescale = 0 -> based on first
  ; imagescale = 1 -> based on current
  ; imagescale = 2 -> per time step
  IF KEYWORD_SET(MAIN) THEN sel = 0 $
    ELSE IF KEYWORD_SET(REFERENCE) THEN sel = 1 $
    ELSE IF KEYWORD_SET(DOPPLER) THEN sel = 2 $
    ELSE IF KEYWORD_SET(SJI) THEN sel = 3
  scale_idx = ((sel EQ 0) OR (sel EQ 2)) * (*(*info).intparams).lp_diag_all + $
    ((sel GT 0) + (sel GT 2)) * (*(*info).intparams).ndiagnostics + $
    (sel EQ 1) * (*(*info).intparams).lp_ref_diag_all + $
    (sel GT 1) * (*(*info).intparams).nrefdiagnostics ;+ $
;    (sel GT 2)
  IF KEYWORD_SET(MAIN) THEN BEGIN
   ; sel = 0
    datadims = SIZE(*(*(*info).data).xyslice,/N_DIMENSIONS)
    IF (N_ELEMENTS(SELECTED_DATA) LT 1) THEN BEGIN
      IF (datadims EQ 2) THEN $
        selected_data = (*(*(*info).data).xyslice)[x_low:x_upp,y_low:y_upp] $
      ELSE $
        selected_data = (*(*(*info).data).xyslice)[y_low:y_upp]
    ENDIF
		IF ((*(*(*info).scaling).imagescale)[sel] EQ 0) THEN BEGIN
      minimum = (*(*info).scaling).imagemin
      maximum = (*(*info).scaling).imagemax
    ENDIF ELSE IF ((*(*(*info).scaling).imagescale)[sel] EQ 1) THEN BEGIN
      minimum = (*(*info).scaling).imagemin_curr
      maximum = (*(*info).scaling).imagemax_curr
    ENDIF
  ENDIF ELSE IF KEYWORD_SET(REFERENCE) THEN BEGIN
    ; sel = 1
    datadims = SIZE(*(*(*info).data).refslice,/N_DIMENSIONS)
    IF (N_ELEMENTS(SELECTED_DATA) LT 1) THEN BEGIN
      IF (datadims EQ 2) THEN $
        selected_data = (*(*(*info).data).refslice)[$
          xref_low:xref_upp,yref_low:yref_upp] $
      ELSE $
        selected_data = (*(*(*info).data).refslice)[yref_low:yref_upp]
    ENDIF
  	IF ((*(*(*info).scaling).imagescale)[sel] EQ 0) THEN BEGIN
      minimum = (*(*info).scaling).refmin
      maximum = (*(*info).scaling).refmax
    ENDIF ELSE IF ((*(*(*info).scaling).imagescale)[sel] EQ 1) THEN BEGIN
      minimum = (*(*info).scaling).refmin_curr
      maximum = (*(*info).scaling).refmax_curr
    ENDIF 
  ENDIF ELSE IF KEYWORD_SET(DOPPLER) THEN BEGIN
    ; sel = 2
    datadims = SIZE(*(*(*info).data).dopslice,/N_DIMENSIONS)
    IF (N_ELEMENTS(SELECTED_DATA) LT 1) THEN BEGIN
      IF (datadims EQ 2) THEN $
        selected_data = (*(*(*info).data).dopslice)[x_low:x_upp,y_low:y_upp] $
      ELSE $
        selected_data = (*(*(*info).data).dopslice)[y_low:y_upp]
    ENDIF
		IF ((*(*(*info).scaling).imagescale)[sel] EQ 0) THEN BEGIN
      minimum = (*(*info).scaling).dopmin
      maximum = (*(*info).scaling).dopmax
    ENDIF ELSE IF ((*(*(*info).scaling).imagescale)[sel] EQ 1) THEN BEGIN
      minimum = (*(*info).scaling).dopmin_curr
      maximum = (*(*info).scaling).dopmax_curr
    ENDIF
  ENDIF ELSE IF KEYWORD_SET(SJI) THEN BEGIN
   ; sel = 3
    IF (N_ELEMENTS(SELECTED_DATA) LT 1) THEN $
      selected_data = (*(*(*info).data).sjislice)[$
        xsji_low:xsji_upp,ysji_low:ysji_upp]
    IF ((*(*(*info).scaling).imagescale)[sel] EQ 0) THEN BEGIN
      minimum = (*(*info).scaling).sjimin
      maximum = (*(*info).scaling).sjimax
    ENDIF ELSE IF ((*(*(*info).scaling).imagescale)[sel] EQ 1) THEN BEGIN
      minimum = (*(*info).scaling).sjimin_curr
      maximum = (*(*info).scaling).sjimax_curr
    ENDIF
  ENDIF
  IF ((*(*info).scaling).gamma[scale_idx] NE 1.) THEN BEGIN
    wherelt0 = WHERE(selected_data LT 0, count)
    IF (count LE 0) THEN $
      selected_data = $
        (TEMPORARY(selected_data))^(*(*info).scaling).gamma[scale_idx] $
    ELSE BEGIN
      selected_data = $
        (TEMPORARY(ABS(selected_data)))^(*(*info).scaling).gamma[scale_idx]
      selected_data[wherelt0] *= -1
    ENDELSE
  ENDIF
  IF ((*(*(*info).scaling).imagescale)[sel] EQ 2) THEN BEGIN
    selected_data = IRIS_HISTO_OPT(TEMPORARY(selected_data), $
      (*(*info).scaling).histo_opt_val[scale_idx], MISSING=-32768, /SILENT)
    minimum = MIN(selected_data, MAX=maximum, /NAN)
  ENDIF
  minmax = CRISPEX_SCALING_CONTRAST(minimum,maximum,$
    (*(*info).scaling).minimum[scale_idx],(*(*info).scaling).maximum[scale_idx])
	finalimage = BYTSCL(selected_data, MIN = minmax[0], MAX = minmax[1], /NAN) 
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [minimum,maximum], labels=['minimum','maximum']
END

PRO CRISPEX_DRAW_XY, event, no_cursor=no_cursor, no_number=no_number, thick=thick, no_endpoints=no_endpoints, symsize=symsize, asecbar=asecbar
; (Re)draw main image procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WSET, (*(*info).winids).imwid
	CRISPEX_DRAW_SCALING, event, imdisp, minimum, maximum, /MAIN
  TV, CONGRID(imdisp,(*(*info).winsizes).xywinx, (*(*info).winsizes).xywiny)
	CRISPEX_DRAW_SUBCOLOR, event, 0, subcolor, minimum, maximum
	IF (subcolor GE 122) THEN curscolor = 0 ELSE curscolor = 255
	CRISPEX_DRAW_CURSCROSS_PLOT, event, curscolor, NO_CURSOR=no_cursor, NO_NUMBER=no_number, $
    THICK=thick, NO_ENDPOINTS=no_endpoints, SYMSIZE=symsize, $
		DRAW_MASK=((*(*info).overlayswitch).mask AND ((*(*info).overlayswitch).maskim)[0])
	IF KEYWORD_SET(ASECBAR) THEN BEGIN
		xlow = 25							& 	ylow = 25 
		xupp = xlow + (*(*info).savparams).overlays_asecbar_pix		
    yupp = ylow + 15 + (*(*info).savparams).overlays_thick
		asecbarcol = 255
		PLOTS, [xlow,xupp],[ylow,ylow], THICK=(*(*info).savparams).overlays_thick, COLOR=asecbarcol, $
      /DEVICE
		XYOUTS, (xupp-xlow)/2.+xlow, ylow+5, $
      STRTRIM((*(*info).savparams).overlays_asecbar_length,2)+'"', /DEVICE, COLOR=asecbarcol, $
      ALIGN=0.5,	CHARSIZE=(*(*info).savparams).overlays_symsize, $
      CHARTHICK=(*(*info).savparams).overlays_thick
	ENDIF
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).winids).imwid,curscolor], $
      labels=['Window ID for draw','Main curscolor']
END

PRO CRISPEX_DRAW_DOPPLER, event
; (Re)draw Doppler-image procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WSET, (*(*info).winids).dopwid
	IF (*(*info).dispswitch).drawdop THEN BEGIN
		CRISPEX_DRAW_SCALING, event, dopdisp, dopminimum, dopmaximum, /DOPPLER
    TV, CONGRID(dopdisp,(*(*info).winsizes).xywinx, (*(*info).winsizes).xywiny)
		CRISPEX_DRAW_SUBCOLOR, event, 2, dopsubcolor, dopminimum, dopmaximum
		IF (dopsubcolor GE 122) THEN $
      dopcurscolor = 0 $
    ELSE $
      dopcurscolor = 255
		CRISPEX_DRAW_CURSCROSS_PLOT, event, dopcurscolor, $
      DRAW_MASK=((*(*info).overlayswitch).mask AND ((*(*info).overlayswitch).maskim)[2])
	ENDIF ELSE BEGIN
		TV, CONGRID(*(*(*info).data).emptydopslice,(*(*info).winsizes).xywinx, (*(*info).winsizes).xywiny)
		IF ((*(*info).dataparams).lp GT (*(*info).dataparams).lp_dop) THEN BEGIN
			lp_blue = (*(*info).dataparams).lp_dop		&	lp_red = (*(*info).dataparams).lp
		ENDIF ELSE BEGIN
			lp_blue = (*(*info).dataparams).lp		&	lp_red = (*(*info).dataparams).lp_dop
		ENDELSE
		IF (lp_red EQ lp_blue) THEN $
      extramessage = 'Same spectral position' $
    ELSE $
      extramessage = 'Spectral position outside set spectral range'
		XYOUTS,(*(*info).winsizes).xywinx/2.,(*(*info).winsizes).xywiny/2.,$
      'Could not create Doppler image for selected spectral positions.!C'+extramessage+': (lp_blue,lp_red)=('+$
			STRTRIM(lp_blue,2)+','+STRTRIM(lp_red,2)+')', CHARSIZE = 1.2, COLOR = 255, ALIGNMENT = 0.5, /DEVICE
		dopcurscolor = 255
	ENDELSE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).winids).dopwid,(*(*info).dispswitch).drawdop,dopcurscolor], $
		labels=['Window ID for draw','Drawing Doppler image','Doppler curscolor']
END

PRO CRISPEX_DRAW_REF, event
; (Re)draw reference image procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	WSET, (*(*info).winids).refwid
	CRISPEX_DRAW_SCALING, event, refdisp, refmin, refmax, /REFERENCE
  TV, CONGRID(refdisp,(*(*info).winsizes).refwinx, (*(*info).winsizes).refwiny) 
	CRISPEX_DRAW_SUBCOLOR, event, 1, subcolor_ref, refmin, refmax, /REFERENCE
	IF (subcolor_ref GE 122) THEN curscolor_ref = 0 ELSE curscolor_ref = 255
	CRISPEX_DRAW_CURSCROSS_PLOT, event, curscolor_ref, $
    DRAW_MASK=((*(*info).overlayswitch).mask AND $
              ((*(*info).overlayswitch).maskim)[1]), /REFERENCE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).winids).refwid,curscolor_ref], $
      labels=['Window ID for draw','Reference curscolor']
END

PRO CRISPEX_DRAW_IMREF_BLINK, event
; Handles the blinking of the main and reference image
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WSET,(*(*info).winids).imrefwid
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).winids).imrefwid], labels=['Window ID for draw']
	IF (*(*info).winids).imrefdisp THEN BEGIN
		CRISPEX_DRAW_SCALING, event, refdisp, refmin, refmax, /REFERENCE
    refdisp_sel = refdisp[$
      (*(*info).dispparams).x_ref[0]:(*(*info).dispparams).x_ref[1], $
      (*(*info).dispparams).y_ref[0]:(*(*info).dispparams).y_ref[1]]
    TV, CONGRID(refdisp_sel,(*(*info).winsizes).imrefwinx, (*(*info).winsizes).imrefwiny) 
		CRISPEX_DRAW_SUBCOLOR, event, 1, subcolor_ref, refmin, refmax
		IF (subcolor_ref GE 122) THEN curscolor_ref = 0 ELSE curscolor_ref = 255
		CRISPEX_DRAW_CURSCROSS_PLOT, event, curscolor_ref, $
      DRAW_MASK=((*(*info).overlayswitch).mask AND ((*(*info).overlayswitch).maskim)[1])
		CRISPEX_DRAW_SUBCOLOR, event, 1, color_reftxt, refmin, refmax;, xyrange=[10,100,5,20]
		IF (color_reftxt GE 122) THEN reftxtcol = 0 ELSE reftxtcol = 255
    label = 'Reference'
    time_val = (*(*(*info).dispparams).tarr_ref)[(*(*info).dispparams).t]
	ENDIF ELSE BEGIN
		CRISPEX_DRAW_SCALING, event, imdisp, minimum, maximum, /MAIN
    imdisp_sel = imdisp[$
      (*(*info).dispparams).x_main[0]:(*(*info).dispparams).x_main[1], $
      (*(*info).dispparams).y_main[0]:(*(*info).dispparams).y_main[1]]
    TV, CONGRID(imdisp_sel,(*(*info).winsizes).imrefwinx, (*(*info).winsizes).imrefwiny) 
		CRISPEX_DRAW_SUBCOLOR, event, 0, subcolor, minimum, maximum
		IF (subcolor GE 122) THEN curscolor = 0 ELSE curscolor = 255
		CRISPEX_DRAW_CURSCROSS_PLOT, event, curscolor, $
      DRAW_MASK=((*(*info).overlayswitch).mask AND ((*(*info).overlayswitch).maskim)[0])
		CRISPEX_DRAW_SUBCOLOR, event, 0, color_txt, minimum, maximum;, xyrange=[10,70,5,20]
		IF (color_txt GE 122) THEN txtcol = 0 ELSE txtcol = 255
    label = 'Main'
    time_val = (*(*(*info).dispparams).tarr_main)[(*(*info).dispparams).t]
	ENDELSE
	IF (SIZE((*(*info).plotaxes).dt,/TYPE) NE 2) THEN BEGIN
    IF (time_val EQ 0.) THEN $
      ndigits = 4 $
    ELSE $
      ndigits = FLOOR(ALOG10(time_val))+4
    time = STRING(time_val, FORMAT='(F'+STRTRIM(ndigits,2)+'.2)')+' s'
  ENDIF ELSE $
    time = STRTRIM(time_val, 2)
  XYOUTS, 10, 10, label+' image, t='+time,/DEVICE, COLOR=txtcol
END

PRO CRISPEX_DRAW_SJI, event
; (Re)draw reference image procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WSET, (*(*info).winids).sjiwid
	CRISPEX_DRAW_SCALING, event, sjidisp, minimum, maximum, /SJI
  TV, CONGRID(sjidisp,(*(*info).winsizes).sjiwinx, (*(*info).winsizes).sjiwiny)
  ; Determine cursor colour and overplot cursors and masks
	CRISPEX_DRAW_SUBCOLOR, event, 3, subcolor_sji, sjimin, sjimax, /SJI
	IF (subcolor_sji GE 122) THEN curscolor_sji = 0 ELSE curscolor_sji = 255
	CRISPEX_DRAW_CURSCROSS_PLOT, event, curscolor_sji, $
    DRAW_MASK=((*(*info).overlayswitch).mask AND $
              ((*(*info).overlayswitch).maskim)[1]), /SJI
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).winids).sjiwid,curscolor_sji], $
                          labels=['Window ID for draw','Slit-jaw image curscolor']
END

PRO CRISPEX_DRAW_INT, event
; (Re)draw intensity versus time plot procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WSET, (*(*info).winids).intwid
	int_low_y = (*(*(*info).plotaxes).int_low_y)[(*(*info).dataparams).s] 
	int_upp_y = (*(*(*info).plotaxes).int_upp_y)[(*(*info).dataparams).s]
	condition = WHERE(*(*(*info).intparams).seldisp_diagnostics EQ 1, count)
  ; Create plot box axes
  PLOT, *(*(*info).dispparams).tarr_main, *(*(*info).dispparams).tarr_main, $
    /NODATA, /NORM, CHARSIZE=1, YR=[int_low_y, int_upp_y], $
    XR = [(*(*info).dispparams).t_low_main,(*(*info).dispparams).t_upp_main], /YS, /XS, $
    XTITLE = (*(*info).plottitles).spytitle, YTITLE = 'Counts/Mean Counts', $
    BACKGROUND = (*(*info).plotparams).bgplotcol, COLOR = (*(*info).plotparams).plotcol, $
    LINESTYLE = 0, $
    POSITION = [(*(*info).plotpos).intx0,(*(*info).plotpos).inty0,$
                (*(*info).plotpos).intx1,(*(*info).plotpos).inty1], $
    XTICKLEN = (*(*info).plotaxes).intxticklen, YTICKLEN = (*(*info).plotaxes).intyticklen
  IF (count GT 0) THEN BEGIN
		selcol = (*(*(*info).intparams).selcol_diagnostics)[condition]
    ; For each lightcurve to be plotted, get lightcurve
		FOR i=0,N_ELEMENTS(condition)-1 DO BEGIN
			IF (*(*info).dataswitch).spfile THEN BEGIN
				ssp = REFORM( ( ( *(*(*info).data).spdata)[ $
          FIX((*(*info).dataparams).y) * (*(*info).dataparams).nx * (*(*info).dataparams).ns + $
          FIX((*(*info).dataparams).x) * (*(*info).dataparams).ns + $
					(*(*info).dataparams).s ] )[$
          (*(*(*info).intparams).sellp_diagnostics)[condition[i]],*] )
			ENDIF ELSE BEGIN
				ssp = FLTARR((*(*info).dataparams).nt)
				FOR t=0,(*(*info).dataparams).nt-1 DO BEGIN
					ssp[t] = ((*(*(*info).data).imagedata)[$
            t * (*(*info).dataparams).nlp * (*(*info).dataparams).ns + $
            (*(*info).dataparams).s * (*(*info).dataparams).nlp + $
						(*(*(*info).intparams).sellp_diagnostics)[condition[i]]])[$
            (*(*info).dataparams).x,(*(*info).dataparams).y]
				ENDFOR
			ENDELSE
			avgdint = ssp / ABS(MEAN(ssp, /NAN))
			LOADCT, 12, /SILENT
			plotcol = ((*(*info).intparams).colors_diagnostics)[selcol[i]]
      ; Plot lightcurve
			OPLOT, *(*(*info).dispparams).tarr_main, avgdint, COLOR=plotcol, $
        LINESTYLE = (*(*(*info).intparams).sellines_diagnostics)[condition[i]]
			LOADCT, 0, /SILENT
		ENDFOR
	ENDIF
  IF (*(*info).plotswitch).multichannel THEN $
	  XYOUTS,0.1*( (*(*(*info).dispparams).tarr_main)[(*(*info).dispparams).t_upp] - $
      (*(*(*info).dispparams).tarr_main)[(*(*info).dispparams).t_low] + 1 ) + $
      (*(*(*info).dispparams).tarr_main)[(*(*info).dispparams).t_low], $
      (int_upp_y-int_low_y)*0.9+int_low_y, $
      'Stokes '+((*(*info).stokesparams).labels)[(*(*info).dataparams).s], $
      COLOR = (*(*info).plotparams).plotcol
  ; Overplot time indicator
	IF (((*(*info).dispparams).t GE (*(*info).dispparams).t_low) AND $
      ((*(*info).dispparams).t LE (*(*info).dispparams).t_upp)) THEN $
    PLOTS, [1,1] * (*(*(*info).dispparams).tarr_main)[(*(*info).dispparams).t], $
      [int_upp_y, int_low_y], COLOR = (*(*info).plotparams).plotcol
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).winids).intwid,int_low_y,int_upp_y], $
                          labels=['Window ID for draw','Lower y-value','Upper y-value']
END

PRO CRISPEX_DRAW_SPECTRAL_MAIN, event, LS_ONLY=ls_only, SP_ONLY=sp_only
; (Re)draw detailed spectrum procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  ; Determine current diagnostic window LP is in
  lp_diag = $
    TOTAL((*(*info).dataparams).lp GE *(*(*info).intparams).diag_starts)-1
 ; Loop over all selected Stokes parameters (will always be at least 1) for
 ; detailed spectrum plots
	FOR i=0,TOTAL((*(*info).stokesparams).select_sp)-1 DO BEGIN
    IF (~KEYWORD_SET(SP_ONLY) AND (*(*info).winswitch).showls) THEN BEGIN
   		s = (WHERE((*(*info).stokesparams).select_sp EQ 1))[i]
   		spec = ((*(*info).dataparams).spec)[*,s]
   		IF (*(*info).plotswitch).scalestokes THEN $
         ms = (*(*info).dataparams).ms $
       ELSE $
         ms = ((*(*info).dataparams).ms)[s]
   		ls_low_y = (*(*(*info).plotaxes).ls_low_y)[s] 
   		ls_upp_y = (*(*(*info).plotaxes).ls_upp_y)[s]
   		order_corr=0.
   		IF (*(*info).dispswitch).detspect_scale THEN $
         lsytitle = 'Scaled '+STRLOWCASE((*(*info).plottitles).lsytitle) $
      ELSE BEGIN
   			IF ((FLOOR(ALOG10(ABS(ls_low_y))) LE -2) OR $
          (FLOOR(ALOG10(ABS(ls_upp_y))) GE 3)) THEN BEGIN
   				order_corr = FLOOR(ALOG10(ABS(ls_upp_y)))
   				lsytitle = $
            (*(*info).plottitles).lsytitle+' (x10!U'+STRTRIM(order_corr,2)+'!N)'
   			ENDIF ELSE lsytitle = (*(*info).plottitles).lsytitle
   			ls_low_y /= (10.^(order_corr))
   			ls_upp_y /= (10.^(order_corr))
   		ENDELSE
   		IF ((*(*info).dispswitch).detspect_scale EQ 0) THEN BEGIN
   			spec *= ms * ((*(*info).paramparams).scale_cubes)[0] / (10.^(order_corr))
   			ms = 1
   		ENDIF
      ; Set x-axes parameters depending on # of diagnostics
      IF ((*(*info).intparams).ndisp_diagnostics GT 1) THEN BEGIN
        xtlen_basic_fac = 0.5
        xtlen_major_fac = 0.8
        xtickname = REPLICATE(' ',60)
      ENDIF ELSE BEGIN
        xtlen_basic_fac = 1.
        xtickname = ''
      ENDELSE
      xticklen = xtlen_basic_fac * (*(*info).plotaxes).lsxticklen
      IF (*(*info).plotswitch).v_dop_set THEN $
        topxtitle = 'Doppler velocity [km/s]'
      ; Get data for display
  		IF ((*(*info).dataswitch).spfile EQ 1) THEN $
        ssp = (*(*(*info).data).ssp_cur[i])[*,(*(*info).dispparams).t_main]/ms $
      ELSE $
        ssp = (*(*(*info).data).ssp_cur[i])/ms
      IF ((*(*info).dispswitch).detspect_scale EQ 0) THEN $
        ssp *= ((*(*info).paramparams).scale_cubes)[0] / (10.^(order_corr))
    ENDIF
    ; Determine proportional spectral window size for LS
    diag_range_ls = *(*(*info).plotaxes).diag_ratio * $
      (((*(*info).plotpos).lsx1)[i] - ((*(*info).plotpos).lsx0)[i])
    FOR d=0,(*(*info).intparams).ndisp_diagnostics-1 DO BEGIN
      IF (~KEYWORD_SET(SP_ONLY) AND (*(*info).winswitch).showls) THEN BEGIN
        WSET, (*(*info).winids).lswid
        ; Determine xrange to display and xticklen
        IF ((*(*info).intparams).ndiagnostics GT 1) THEN $
          xrange = (*(*info).dataparams).lps[[$
            (*(*info).intparams).diag_start[$
              (*(*(*info).intparams).wheredispdiag)[d]],$
            ((*(*info).intparams).diag_start[$
              (*(*(*info).intparams).wheredispdiag)[d]]+$
            (*(*info).intparams).diag_width[$
              (*(*(*info).intparams).wheredispdiag)[d]]-1)]] $
        ELSE $
          xrange = [(*(*info).dataparams).lps[(*(*info).dispparams).lp_low], $
            (*(*info).dataparams).lps[(*(*info).dispparams).lp_upp]]
        lp_lower = (*(*info).intparams).diag_start[$
          (*(*(*info).intparams).wheredispdiag)[d]]
        lp_upper = lp_lower+(*(*info).intparams).diag_width[$
          (*(*(*info).intparams).wheredispdiag)[d]]-1
        ; Set y-axes parameters based on diagnostic plot
        IF (d EQ 0) THEN BEGIN
          offset = 0 
          ytickname = '' 
          ytitle = lsytitle
        ENDIF ELSE BEGIN
          offset = TOTAL(diag_range_ls[0:(d-1)])
          ytickname = REPLICATE(' ',60)
          ytitle = ''
        ENDELSE
        ; Scaling of xticklen
        ; Determine lower left corner position of plot
        lsx0 = ((*(*info).plotpos).lsx0)[i] + offset
        lsx1 = diag_range_ls[d] + lsx0
        ; Plot basic window with average spectrum
     		PLOT, (*(*info).dataparams).lps[lp_lower:lp_upper], $
          spec[lp_lower:lp_upper]*(*(*info).scaling).mult_val[$
          (*(*(*info).intparams).wheredispdiag)[d]], $
          /NORM, CHARSIZE=1, YS=1, YR=[ls_low_y,ls_upp_y], $
          XR=xrange, YTICKNAME=ytickname, $
          XMINOR=(0-((*(*info).intparams).ndisp_diagnostics GT 1)), $
          XTICKINTERVAL=(*(*(*info).plotaxes).xtickinterval)[0], $
          XTICKNAME=xtickname, XTICK_GET=xtickvals, $
          XSTYLE = (*(*info).plotswitch).v_dop_set * 8 + 1, $
          BACKGROUND = (*(*info).plotparams).bgplotcol, $
          XTITLE = xtitle, YTITLE=ytitle, $
          POSITION = [lsx0,((*(*info).plotpos).lsy0)[i],lsx1,$
          ((*(*info).plotpos).lsy1)[i]], XTICKLEN = xticklen, $
          YTICKLEN = (*(*info).plotaxes).lsyticklen, $
          COLOR = (*(*info).plotparams).plotcol, LINE=3, $
          NOERASE=((((*(*info).intparams).ndiagnostics GT 1) AND (d GT 0)) OR $
          (i GT 0))
        IF ((*(*info).scaling).mult_val[$
          (*(*(*info).intparams).wheredispdiag)[d]] NE 1) THEN BEGIN
stop
          XYOUTS,0.1*(xrange[1]-xrange[0])+xrange[0], $
            0.9*(ls_upp_y-ls_low_y)+ls_low_y, $
            STRING((*(*info).scaling).mult_val[$
            (*(*(*info).intparams).wheredispdiag)[d]], FORMAT='(F'+$
            STRTRIM(FLOOR(ALOG10(ABS((*(*info).scaling).mult_val[$
            (*(*(*info).intparams).wheredispdiag)[d]])))+3+$
            ((*(*info).scaling).mult_val[$
            (*(*(*info).intparams).wheredispdiag)[d]] LT 0),2)+'.1)')+'x',$
            COLOR=(*(*info).plotparams).plotcol, /DATA
        ENDIF
        ; In case of multiple diagnostics
        IF ((*(*info).intparams).ndiagnostics GT 1) THEN BEGIN
          ; Draw x-title centered on plot box on first pass
          IF (d EQ 0) THEN $
            XYOUTS,((*(*info).plotpos).lsx1-(*(*info).plotpos).lsx0)/2.+$
              (*(*info).plotpos).lsx0, (*(*info).plotpos).lsy0/3., $
              (*(*info).plottitles).spxtitle,ALIGNMENT=0.5, $
              COLOR = (*(*info).plotparams).plotcol,/NORMAL
          ; Set range for Doppler axis
          vdop_xrange = (*(*(*info).plotaxes).v_dop[$
            (*(*(*info).intparams).wheredispdiag)[d]])[$
            [0,(*(*(*info).intparams).diag_widths)[d]-1]]
          IF ((*(*info).intparams).ndisp_diagnostics GT 1) THEN BEGIN
            ; Redraw x-axis with custom labelling
            IF (*(*info).plotswitch).xtick_reset THEN BEGIN
              (*(*info).plotaxes).xtickvals[d] = $
                PTR_NEW(CRISPEX_PLOTAXES_XTICKVALS_SELECT(xtickvals, $
                TICKSEP=(*(*(*info).plotaxes).xtickinterval)[1]))
              IF (d EQ ((*(*info).intparams).ndisp_diagnostics-1)) THEN $
                (*(*info).plotswitch).xtick_reset = 0
            ENDIF
            wherenonempty = $
              WHERE(*(*(*info).plotaxes).xtickvals[d] NE ' ', count)
            IF (count GT 0) THEN BEGIN
              FOR k=0,N_ELEMENTS(wherenonempty)-1 DO BEGIN
                PLOTS,[1.,1.]*FLOAT((*(*(*info).plotaxes).xtickvals[d])[$
                  wherenonempty[k]]), [ls_low_y,xtlen_major_fac*$
                  (ls_upp_y-ls_low_y)*(*(*info).plotaxes).lsxticklen+ls_low_y],$
                  COLOR=(*(*info).plotparams).plotcol
              ENDFOR
            ENDIF
            AXIS, XAXIS=0, XTICKLEN=1E-9, XRANGE=xrange, /XS, $
              XTICKNAME=*(*(*info).plotaxes).xtickvals[d], $
              COLOR=(*(*info).plotparams).plotcol, $
              XTICKINTERVAL=(*(*(*info).plotaxes).xtickinterval)[0]
          ENDIF
        ENDIF ELSE $
          vdop_xrange = (*(*(*info).plotaxes).v_dop[0])[$
            [(*(*info).dispparams).lp_low,(*(*info).dispparams).lp_upp]]
        ; Display Stokes label if Stokes data
        IF (*(*info).plotswitch).multichannel THEN $
    		  XYOUTS, ((*(*info).dataparams).lps[(*(*info).dispparams).lp_upp]-$
                   (*(*info).dataparams).lps[(*(*info).dispparams).lp_low])*0.1+$
                   (*(*info).dataparams).lps[(*(*info).dispparams).lp_low], $
    			        (ls_upp_y-ls_low_y)*0.9+ls_low_y, 'Stokes '+$
                  ((*(*info).stokesparams).labels)[s], $
                  COLOR = (*(*info).plotparams).plotcol
        ; Display Doppler velocities on top axis if info available
    	  IF ((*(*info).plotswitch).v_dop_set EQ 1) THEN BEGIN
          IF ((*(*info).intparams).ndiagnostics GT 1) THEN BEGIN
            XYOUTS,((*(*info).plotpos).lsx1-(*(*info).plotpos).lsx0)/2.+$
              (*(*info).plotpos).lsx0,(*(*info).plotpos).lsy0/5.*3+$
              (*(*info).plotpos).lsy1, topxtitle, ALIGNMENT=0.5, $
              COLOR = (*(*info).plotparams).plotcol,/NORMAL
            topxtitle = ''
          ENDIF 
          ; Draw top axis
          IF ((*(*info).intparams).ndisp_diagnostics GT 1) THEN BEGIN
            ; Plot the initial tick marks and get the tick vals
      	  	AXIS, XAXIS=1, XRANGE=vdop_xrange, $
              XSTYLE=1, XTITLE=topxtitle, COLOR=(*(*info).plotparams).plotcol,$
              XTICKINTERVAL=(*(*(*info).plotaxes).xdoptickinterval)[0], $
              XTICKNAME=REPLICATE(' ',60), XTICK_GET=xdoptickvals, $
              XTICKLEN=xtlen_basic_fac*(*(*info).plotaxes).lsxticklen, $
              XMINOR=-1
            ; Redraw x-axis with custom labelling
            IF (*(*info).plotswitch).xdoptick_reset THEN BEGIN
              (*(*info).plotaxes).xdoptickvals[d] = $
                PTR_NEW(CRISPEX_PLOTAXES_XTICKVALS_SELECT(xdoptickvals, $
                TICKSEP=(*(*(*info).plotaxes).xdoptickinterval)[1],$
                /DOPPLER))
              wherenonempty = WHERE(*(*(*info).plotaxes).xdoptickvals[d] NE ' ')
              ; Determine Doppler tick mark locations
              (*(*info).plotaxes).xdoptickloc[d] = $
                PTR_NEW(CRISPEX_PLOTAXES_XDOPTICKLOC(xdoptickvals, $
                wherenonempty, vdop_xrange, $
                [(*(*info).dataparams).lps[lp_lower], $
                (*(*info).dataparams).lps[lp_upper]]))
              IF (d EQ ((*(*info).intparams).ndisp_diagnostics-1)) THEN $
                (*(*info).plotswitch).xdoptick_reset = 0
            ENDIF
            wherenonempty = $
              WHERE(*(*(*info).plotaxes).xdoptickvals[d] NE ' ', count)
            IF (count GT 0) THEN BEGIN
              FOR k=0,N_ELEMENTS(wherenonempty)-1 DO BEGIN
                PLOTS,[1.,1.]*(*(*(*info).plotaxes).xdoptickloc[d])[k], $
                  [ls_upp_y,-xtlen_major_fac*(ls_upp_y-ls_low_y)*$
                  (*(*info).plotaxes).lsxticklen+ls_upp_y], $
                  COLOR=(*(*info).plotparams).plotcol
              ENDFOR
            ENDIF
            ; Add the labels
            AXIS, XAXIS=1, XTICKLEN=1E-9, XRANGE=vdop_xrange, /XS, $
              XTICKNAME=*(*(*info).plotaxes).xdoptickvals[d], $
              COLOR=(*(*info).plotparams).plotcol, $
              XTICKINTERVAL=(*(*(*info).plotaxes).xdoptickinterval)[0], XMINOR=-1
          ENDIF ELSE $
      	  	AXIS, XAXIS=1, XTICKLEN = (*(*info).plotaxes).lsxticklen, $
              XRANGE=vdop_xrange, XSTYLE=1, XTITLE=topxtitle, $
              COLOR=(*(*info).plotparams).plotcol;,$
        ENDIF 
        ; Draw line through y=0
    		IF ((ls_low_y LT 0.) AND (ls_upp_y GT 0.)) THEN $
          PLOTS, xrange, [0.,0.], COLOR = (*(*info).plotparams).plotcol
        ; Only overplot detailed spectrum if x/y is not out of range
        IF ((*(*info).dispswitch).xy_out_of_range EQ 0) THEN BEGIN
          ; Overplot detailed spectrum
      		OPLOT, (*(*info).dataparams).lps[lp_lower:lp_upper], $
            ssp[lp_lower:lp_upper]*(*(*info).scaling).mult_val[$
            (*(*(*info).intparams).wheredispdiag)[d]], $
            LINE=0, COLOR = (*(*info).plotparams).plotcol
          ; Overplot average minus detailed spectrum
      		IF (*(*info).plotswitch).subtract THEN $
      			OPLOT, (*(*info).dataparams).lps[lp_lower:lp_upper], $
              (spec[lp_lower:lp_upper]-ssp[lp_lower:lp_upper])*$
              (*(*info).scaling).mult_val[$
              (*(*(*info).intparams).wheredispdiag)[d]], $
              COLOR = (*(*info).plotparams).plotcol, LINE=2
          IF (d EQ lp_diag) THEN BEGIN
            ; Overplot spectral indicator
      		  PLOTS, [1,1] * (*(*info).dataparams).lps[(*(*info).dataparams).lp],$
              [ls_low_y,ls_upp_y], COLOR = (*(*info).plotparams).plotcol
            ; Overplot 2nd spectral indicator in case of Doppler image display
        		IF (*(*info).dispswitch).drawdop THEN $
              PLOTS, [1,1] * (*(*info).dataparams).lps[$
                (*(*info).dataparams).lp_dop],[ls_low_y,ls_upp_y], $
                COLOR=(*(*info).plotparams).plotcol
          ENDIF
          ; Overplot reference spectral indicator if same number of spectral 
          ; positions
      		IF ((*(*info).winswitch).showref AND $
             ((*(*info).ctrlsswitch).lp_ref_lock EQ 0) AND $
             ((*(*info).dataswitch).refspfile EQ 0) AND $
             ((*(*info).dataparams).refnlp GT 1)) THEN BEGIN
      			PLOTS, [1,1] * (*(*info).dataparams).reflps[$
              (*(*info).dataparams).lp_ref],[ls_low_y,ls_upp_y], $
              COLOR=(*(*info).plotparams).plotcol
      		ENDIF
        ENDIF 
      ENDIF
    ENDFOR
    IF (*(*info).dispswitch).xy_out_of_range THEN $
      XYOUTS, ((*(*info).plotpos).lsx1[i]-(*(*info).plotpos).lsx0[i])/2.+$
        (*(*info).plotpos).lsx0[i], ((*(*info).plotpos).lsy1[i]-$
        (*(*info).plotpos).lsy0[i])/2.+(*(*info).plotpos).lsy0[i], $
        'No data availabe for!Cselected pixel position', $
        COLOR=(*(*info).plotparams).plotcol, ALIGN=0.5, CHARSIZE=1.2, /NORMAL
  ENDFOR
  ; Pre-draw procedures for SP
  IF (~KEYWORD_SET(LS_ONLY) AND (*(*info).winswitch).showsp) THEN BEGIN
  	IF (*(*info).dispparams).slices_imscale THEN BEGIN
      CRISPEX_DRAW_SCALING,event,imdisp,minimum,maximum, /MAIN
      minmax = CRISPEX_SCALING_CONTRAST(minimum,maximum,$
        (*(*info).scaling).minimum[(*(*info).intparams).lp_diag_all],$
        (*(*info).scaling).maximum[(*(*info).intparams).lp_diag_all])
    ENDIF 
    WSET, (*(*info).winids).spwid
    TV, *(*(*info).data).spslice_congrid, (*(*info).plotpos).spx0, $
      (*(*info).plotpos).spy0, /NORM
    !X.WINDOW = [(*(*info).plotpos).spx0,(*(*info).plotpos).spx1]
    !Y.WINDOW = [(*(*info).plotpos).spy0,(*(*info).plotpos).spy1]
    ; In case of multiple diagnostics, overplot separator axes
    IF ((*(*info).intparams).ndiagnostics GT 1) THEN BEGIN
      ; Loop over all but the first diagnostic for plotting separators
      FOR d=1,(*(*info).intparams).ndisp_diagnostics-1 DO BEGIN
        AXIS,(d GE 1)*TOTAL((*(*(*info).plotaxes).diag_range_sp)[0:(d-1)])+$
          (*(*info).plotpos).spx0, YAXIS=0, $
          YTICKLEN=(*(*info).plotaxes).spyticklen, YTICKNAME=REPLICATE(' ',60), $
          COLOR=100,/NORMAL, $
          YRANGE=[(*(*info).dispparams).t_low_main, $
          (*(*info).dispparams).t_upp_main], YSTYLE=1, /NOERASE
        AXIS,(d GE 1)*TOTAL((*(*(*info).plotaxes).diag_range_sp)[0:(d-1)])+$
          (*(*info).plotpos).spx0, YAXIS=1, $
          YTICKLEN=(*(*info).plotaxes).spyticklen, YTICKNAME=REPLICATE(' ',60), $
          COLOR=100,/NORMAL,YRANGE=[(*(*info).dispparams).t_low_main, $
          (*(*info).dispparams).t_upp_main], YSTYLE=1, /NOERASE
      ENDFOR
    ENDIF
    IF ((*(*info).dispswitch).xy_out_of_range EQ 0) THEN BEGIN
      ; Overplot time indicator
      PLOTS, [(*(*info).plotpos).spx0,(*(*info).plotpos).spx1], $
              [1,1]*( ((*(*(*info).dispparams).tarr_main)[$
              (*(*info).dispparams).t]-(*(*info).dispparams).t_low_main) / $
              FLOAT((*(*info).dispparams).t_upp_main-$
              (*(*info).dispparams).t_low_main) * (*(*info).plotpos).yplspw + $
              (*(*info).plotpos).spy0), /NORMAL, COLOR = 100
      ; Overplot lp indicator
      IF ((*(*info).intparams).ndiagnostics GT 1) THEN BEGIN
        ; Determine in which diagnostic the current LP lies
        IF (lp_diag EQ 0) THEN $
          offset = 0 $
        ELSE $
          offset = TOTAL((*(*(*info).plotaxes).diag_range_sp)[0:(lp_diag-1)])
        spx0 = (*(*info).plotpos).spx0 + offset
        xplspw = (*(*(*info).plotaxes).diag_range_sp)[lp_diag]
        ; Get the corresponding lp_disprange
        lp_disprange = (*(*info).dataparams).lps[$
                        (*(*(*info).intparams).diag_starts)[lp_diag]+$
                        (*(*(*info).intparams).diag_widths)[lp_diag]-1] - $
                       (*(*info).dataparams).lps[$
                        (*(*(*info).intparams).diag_starts)[lp_diag]]
        lp_lower = $
          (*(*info).dataparams).lps[(*(*(*info).intparams).diag_starts)[lp_diag]]
      ENDIF ELSE BEGIN
        lp_disprange = ((*(*info).dataparams).lps[(*(*info).dispparams).lp_upp]-$
                        (*(*info).dataparams).lps[(*(*info).dispparams).lp_low])
        spx0 = (*(*info).plotpos).spx0
        xplspw = (*(*info).plotpos).xplspw 
        lp_lower = (*(*info).dataparams).lps[(*(*info).dispparams).lp_low]
      ENDELSE
      PLOTS, [1,1] * ( ((*(*info).dataparams).lps[(*(*info).dataparams).lp] - $
                        lp_lower) / lp_disprange * xplspw + spx0 ), $
      	[(*(*info).plotpos).spy0, (*(*info).plotpos).spy1], /NORMAL, COLOR=100
      ; If drawing Doppler, overplot lp_dop indicator
      IF (*(*info).dispswitch).drawdop THEN $         
        PLOTS, [1,1] * (((*(*info).dataparams).lps[$
                          (*(*info).dataparams).lp_dop]-$
                        (*(*info).dataparams).lps[$
                          (*(*(*info).intparams).diag_starts)[lp_diag]]) / $
                        lp_disprange * xplspw + spx0 ), $
      	  [(*(*info).plotpos).spy0, (*(*info).plotpos).spy1], /NORMAL, COLOR=100
      ; If drawing reference, and refnlp=nlp but lp_ref != lp, then overplot 
      ; lp_ref indicator
      IF ((*(*info).winswitch).showref AND $
         ((*(*info).ctrlsswitch).lp_ref_lock EQ 0) AND $
         ((*(*info).dataswitch).refspfile EQ 0) AND $
         ((*(*info).dataparams).refnlp GT 1)) THEN $
      	PLOTS, [1,1] * ( $
          ((*(*info).dataparams).reflps[(*(*info).dataparams).lp_ref] - $
           (*(*info).dataparams).reflps[(*(*info).dispparams).lp_ref_low]) / $
          ((*(*info).dataparams).reflps[(*(*info).dispparams).lp_ref_upp] - $
           (*(*info).dataparams).reflps[(*(*info).dispparams).lp_ref_low]) * $
          (*(*info).plotpos).xplspw + (*(*info).plotpos).spx0 ), $
      		[(*(*info).plotpos).spy0, (*(*info).plotpos).spy1], /NORMAL, COLOR=100
    ENDIF ELSE $
  		XYOUTS, (*(*info).plotpos).xplspw/2.+(*(*info).plotpos).spx0,$
              (*(*info).plotpos).yplspw/2.+(*(*info).plotpos).spy0,$
              'No data available for!Cselected pixel position', COLOR=255, $
              ALIGNMENT = 0.5, CHARSIZE=1.2, /NORMAL
  ENDIF
END

PRO CRISPEX_DRAW_SPECTRAL_REF, event, LS_ONLY=ls_only, SP_ONLY=sp_only
; (Re)draw detailed spectrum procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  ; Determine current diagnostic window LP_REF is in
  lp_ref_diag = $
    TOTAL((*(*info).dataparams).lp_ref GE *(*(*info).intparams).refdiag_starts)-1
  IF (~KEYWORD_SET(SP_ONLY) AND (*(*info).winswitch).showrefls) THEN BEGIN
    ; Pre-draw procedures: detailed spectrum (LS)
	  refspec = ((*(*info).dataparams).refspec)
	  refms = (*(*info).dataparams).refms
	  ls_low_y = (*(*info).plotaxes).ls_low_y_ref
	  ls_upp_y = (*(*info).plotaxes).ls_upp_y_ref
	  order_corr=0.
	  IF (*(*info).dispswitch).ref_detspect_scale THEN $
      reflsytitle = 'Scaled '+STRLOWCASE((*(*info).plottitles).reflsytitle) $
    ELSE BEGIN
	  	IF ((FLOOR(ALOG10(ABS(ls_low_y))) LE -2) OR $
          (FLOOR(ALOG10(ABS(ls_upp_y))) GE 3)) THEN BEGIN
	  		order_corr = FLOOR(ALOG10(ABS(ls_upp_y)))
	  		reflsytitle = $
          (*(*info).plottitles).reflsytitle+' (x10!U'+STRTRIM(order_corr,2)+'!N)'
	  	ENDIF ELSE reflsytitle = (*(*info).plottitles).reflsytitle
	  	ls_low_y /= (10.^(order_corr))
	  	ls_upp_y /= (10.^(order_corr))
	  ENDELSE
	  IF ((*(*info).dispswitch).ref_detspect_scale EQ 0) THEN BEGIN
	  	refspec *= refms * ((*(*info).paramparams).scale_cubes)[1] / $
        (10.^(order_corr))
	  	refms = 1
	  ENDIF
    ; Set x-axes parameters depending on # of diagnostics
    IF ((*(*info).intparams).ndisp_refdiagnostics GT 1) THEN BEGIN
      xtlen_basic_fac = 0.5
      xtlen_major_fac = 0.8
      xtickname = REPLICATE(' ',60)
    ENDIF ELSE BEGIN
      xtlen_basic_fac = 1.
      xtickname = ''
    ENDELSE
    xticklen = xtlen_basic_fac * (*(*info).plotaxes).reflsxticklen
    IF (*(*info).plotswitch).v_dop_set_ref THEN $
      topxtitle = 'Doppler velocity [km/s]'
    ; Get data for display
    IF ((*(*info).dataswitch).refspfile EQ 1) THEN $
      refssp = $
        ((*(*(*info).data).refssp_cur)[*,(*(*info).dispparams).t_ref])/refms $
    ELSE $
      refssp = (*(*(*info).data).refssp_cur)/refms
    IF ((*(*info).dispswitch).ref_detspect_scale EQ 0) THEN $
      refssp *= ((*(*info).paramparams).scale_cubes)[1] / (10.^(order_corr))
    ; Determine proportional spectral window size for LS
    diag_range_ls = *(*(*info).plotaxes).refdiag_ratio * $
      ((*(*info).plotpos).reflsx1 - (*(*info).plotpos).reflsx0)
    FOR d=0,(*(*info).intparams).ndisp_refdiagnostics-1 DO BEGIN
      mult_idx = (*(*info).intparams).ndiagnostics+$
        (*(*(*info).intparams).wheredisprefdiag)[d]
      ; Draw REFLS window
	    WSET, (*(*info).winids).reflswid
      ; Determine xrange to display
      IF ((*(*info).intparams).nrefdiagnostics GT 1) THEN $
        xrange = (*(*info).dataparams).reflps[[$
          (*(*info).intparams).refdiag_start[$
            (*(*(*info).intparams).wheredisprefdiag)[d]],$
          ((*(*info).intparams).refdiag_start[$
            (*(*(*info).intparams).wheredisprefdiag)[d]]+$
          (*(*info).intparams).refdiag_width[$
            (*(*(*info).intparams).wheredisprefdiag)[d]]-1)]] $
      ELSE $
        xrange = $
          [(*(*info).dataparams).reflps[(*(*info).dispparams).lp_ref_low], $
           (*(*info).dataparams).reflps[(*(*info).dispparams).lp_ref_upp]]
      lp_ref_lower = (*(*info).intparams).refdiag_start[$
        (*(*(*info).intparams).wheredisprefdiag)[d]]
      lp_ref_upper = lp_ref_lower+(*(*info).intparams).refdiag_width[$
        (*(*(*info).intparams).wheredisprefdiag)[d]]-1
      ; Set y-axes parameters based on diagnostic plot
      IF (d EQ 0) THEN BEGIN
        offset = 0 
        ytickname = '' 
        ytitle = reflsytitle
      ENDIF ELSE BEGIN
        offset = TOTAL(diag_range_ls[0:(d-1)])
        ytickname = REPLICATE(' ',60)
        ytitle = ''
      ENDELSE
      ; Determine lower left corner position of plot
      reflsx0 = (*(*info).plotpos).reflsx0 + offset
      reflsx1 = diag_range_ls[d] + reflsx0
      ; Plot basic window with average spectrum
      PLOT, (*(*info).dataparams).reflps[lp_ref_lower:lp_ref_upper],$
        refspec[lp_ref_lower:lp_ref_upper]*$
        (*(*info).scaling).mult_val[mult_idx], $
        /NORM, CHARSIZE=1, YS=1, YR=[ls_low_y,ls_upp_y], $
        XR=xrange, YTICKNAME=ytickname, $
        XMINOR=(0-((*(*info).intparams).ndisp_refdiagnostics GT 1)), $
        XTICKINTERVAL=(*(*(*info).plotaxes).xreftickinterval)[0], $
        XTICKNAME=xtickname, XSTYLE=(*(*info).plotswitch).v_dop_set_ref*8+1, $
        XTICK_GET=xtickvals, BACKGROUND=(*(*info).plotparams).bgplotcol, $
        XTITLE = xtitle, YTITLE=ytitle, $
        POSITION=[reflsx0,((*(*info).plotpos).reflsy0),$
        reflsx1,((*(*info).plotpos).reflsy1)], $
        XTICKLEN = xticklen, YTICKLEN = (*(*info).plotaxes).reflsyticklen, $
        COLOR = (*(*info).plotparams).plotcol, LINE=3, $
        NOERASE=(((*(*info).intparams).nrefdiagnostics GT 1) AND (d GT 0))
        IF ((*(*info).scaling).mult_val[mult_idx] NE 1) THEN BEGIN
          XYOUTS,0.1*(xrange[1]-xrange[0])+xrange[0], $
            0.9*(ls_upp_y-ls_low_y)+ls_low_y, $
            STRING((*(*info).scaling).mult_val[mult_idx], $
            FORMAT='(F'+STRTRIM(FLOOR(ALOG10(ABS((*(*info).scaling).mult_val[$
            mult_idx])))+3+((*(*info).scaling).mult_val[mult_idx] LT 0),2)+$
            '.1)')+'x',COLOR=(*(*info).plotparams).plotcol, /DATA
        ENDIF
      ; In case of multiple diagnostics
      IF ((*(*info).intparams).nrefdiagnostics GT 1) THEN BEGIN
        ; Draw x-title centered on plot box on first pass
        IF (d EQ 0) THEN $
          XYOUTS,((*(*info).plotpos).reflsx1-(*(*info).plotpos).reflsx0)/2.+$
            (*(*info).plotpos).reflsx0, (*(*info).plotpos).reflsy0/3.,$
            (*(*info).plottitles).refspxtitle,ALIGNMENT=0.5, $
            COLOR=(*(*info).plotparams).plotcol, /NORMAL
        ; Set range for Doppler axis
        vdop_xrange = (*(*(*info).plotaxes).v_dop_ref[$
          (*(*(*info).intparams).wheredisprefdiag)[d]])[$
          [0,(*(*(*info).intparams).refdiag_widths)[d]-1]]
        IF ((*(*info).intparams).ndisp_refdiagnostics GT 1) THEN BEGIN
          ; Redraw x-axis with custom labelling
          IF (*(*info).plotswitch).xreftick_reset THEN BEGIN
            (*(*info).plotaxes).xreftickvals[d] = $
              PTR_NEW(CRISPEX_PLOTAXES_XTICKVALS_SELECT(xtickvals, $
              TICKSEP=(*(*(*info).plotaxes).xreftickinterval)[1]))
            IF (d EQ ((*(*info).intparams).ndisp_refdiagnostics-1)) THEN $
              (*(*info).plotswitch).xreftick_reset = 0
          ENDIF
          wherenonempty = $
            WHERE(*(*(*info).plotaxes).xreftickvals[d] NE ' ', count)
          IF (count GT 0) THEN BEGIN
            FOR k=0,N_ELEMENTS(wherenonempty)-1 DO BEGIN
              PLOTS,[1.,1.]*FLOAT((*(*(*info).plotaxes).xreftickvals[d])[$
                wherenonempty[k]]), [ls_low_y,xtlen_major_fac*$
                (ls_upp_y-ls_low_y)*(*(*info).plotaxes).reflsxticklen+ls_low_y],$
                COLOR=(*(*info).plotparams).plotcol
            ENDFOR
          ENDIF
          AXIS, XAXIS=0, XTICKLEN=1E-9, XRANGE=xrange, /XS, $
            XTICKNAME=*(*(*info).plotaxes).xreftickvals[d], $
            COLOR=(*(*info).plotparams).plotcol, $
            XTICKINTERVAL=(*(*(*info).plotaxes).xreftickinterval)[0]
        ENDIF
      ENDIF ELSE $
        vdop_xrange = (*(*(*info).plotaxes).v_dop_ref[0])[$
          [(*(*info).dispparams).lp_ref_low,(*(*info).dispparams).lp_ref_upp]]
      ; Display Doppler velocities on top axis if info available
      IF ((*(*info).plotswitch).v_dop_set_ref EQ 1) THEN BEGIN
        IF ((*(*info).intparams).nrefdiagnostics GT 1) THEN BEGIN
          XYOUTS,((*(*info).plotpos).reflsx1-(*(*info).plotpos).reflsx0)/2.+$
            (*(*info).plotpos).reflsx0,(*(*info).plotpos).reflsy0/5.*3+$
            (*(*info).plotpos).reflsy1, topxtitle, ALIGNMENT=0.5, $
            COLOR = (*(*info).plotparams).plotcol,/NORMAL
          topxtitle = ''
        ENDIF 
        ; Draw top axis
        IF ((*(*info).intparams).ndisp_refdiagnostics GT 1) THEN BEGIN
          ; Plot the initial tick marks and get the tick vals
    	  	AXIS, XAXIS=1, XRANGE=vdop_xrange, $
            XSTYLE=1, XTITLE = topxtitle, COLOR = (*(*info).plotparams).plotcol,$
            XTICKINTERVAL=(*(*(*info).plotaxes).xrefdoptickinterval)[0], $
            XTICKNAME=REPLICATE(' ',60), XTICK_GET=xdoptickvals, $
            XTICKLEN=xtlen_basic_fac*(*(*info).plotaxes).reflsxticklen, $
            XMINOR=-1
          ; Redraw x-axis with custom labelling
          IF (*(*info).plotswitch).xrefdoptick_reset THEN BEGIN
            (*(*info).plotaxes).xrefdoptickvals[d] = $
              PTR_NEW(CRISPEX_PLOTAXES_XTICKVALS_SELECT(xdoptickvals, $
              TICKSEP=(*(*(*info).plotaxes).xrefdoptickinterval)[1],$
              /DOPPLER))
            wherenonempty = WHERE(*(*(*info).plotaxes).xrefdoptickvals[d] NE ' ')
            ; Determine Doppler tick mark locations
            (*(*info).plotaxes).xrefdoptickloc[d] = $
              PTR_NEW(CRISPEX_PLOTAXES_XDOPTICKLOC(xdoptickvals, wherenonempty, $
              vdop_xrange, [(*(*info).dataparams).reflps[lp_ref_lower], $
              (*(*info).dataparams).reflps[lp_ref_upper]]))
            IF (d EQ ((*(*info).intparams).ndisp_refdiagnostics-1)) THEN $
              (*(*info).plotswitch).xrefdoptick_reset = 0
          ENDIF
          wherenonempty = $
            WHERE(*(*(*info).plotaxes).xrefdoptickvals[d] NE ' ', count)
          IF (count GT 0) THEN BEGIN
            FOR k=0,N_ELEMENTS(wherenonempty)-1 DO BEGIN
              PLOTS,[1.,1.]*(*(*(*info).plotaxes).xrefdoptickloc[d])[k], $
                [ls_upp_y,-xtlen_major_fac*(ls_upp_y-ls_low_y)*$
                (*(*info).plotaxes).reflsxticklen+ls_upp_y], $
                COLOR=(*(*info).plotparams).plotcol
            ENDFOR
          ENDIF
          ; Add the labels
          AXIS, XAXIS=1, XTICKLEN=1E-9, XRANGE=vdop_xrange, /XS, $
            XTICKNAME=*(*(*info).plotaxes).xrefdoptickvals[d], $
            COLOR=(*(*info).plotparams).plotcol, XMINOR=-1, $
            XTICKINTERVAL=(*(*(*info).plotaxes).xrefdoptickinterval)[0]
        ENDIF ELSE $
      	  AXIS, XAXIS=1, XTICKLEN = (*(*info).plotaxes).lsxticklen, $
            XRANGE=vdop_xrange, XSTYLE=1, XTITLE = topxtitle, $
            COLOR = (*(*info).plotparams).plotcol;,$
      ENDIF 
      ; Draw line through y=0
    	IF ((ls_low_y LT 0.) AND (ls_upp_y GT 0.)) THEN $
        PLOTS, xrange, [0.,0.], COLOR = (*(*info).plotparams).plotcol
      ; Only overplot detailed spectrum if x/y is not out of range
      IF ((*(*info).dispswitch).xyref_out_of_range EQ 0) THEN BEGIN
        ; Overplot detailed spectrum
      	OPLOT, (*(*info).dataparams).reflps[lp_ref_lower:lp_ref_upper], $
          refssp[lp_ref_lower:lp_ref_upper]*(*(*info).scaling).mult_val[$
          mult_idx], LINE=0, COLOR = (*(*info).plotparams).plotcol
        ; Overplot average minus detailed spectrum
      	IF (*(*info).plotswitch).ref_subtract THEN $
      		OPLOT, (*(*info).dataparams).reflps[lp_ref_lower:lp_ref_upper], $
            (refspec[lp_ref_lower:lp_ref_upper]-refssp[$
            lp_ref_lower:lp_ref_upper])*(*(*info).scaling).mult_val[mult_idx], $
            COLOR=(*(*info).plotparams).plotcol, LINE=2
        IF (d EQ lp_ref_diag) THEN $
          ; Overplot spectral indicator
        	PLOTS, [1,1] * (*(*info).dataparams).reflps[$
            (*(*info).dataparams).lp_ref],[ls_low_y,ls_upp_y],$
            COLOR = (*(*info).plotparams).plotcol
      ENDIF 
    ENDFOR
    IF (*(*info).dispswitch).xyref_out_of_range THEN $
      XYOUTS, ((*(*info).plotpos).reflsx1-(*(*info).plotpos).reflsx0)/2.+$
        (*(*info).plotpos).reflsx0, ((*(*info).plotpos).reflsy1-$
        (*(*info).plotpos).reflsy0)/2.+(*(*info).plotpos).reflsy0, $
        'No data availabe for!Cselected pixel position', $
        COLOR=(*(*info).plotparams).plotcol, ALIGN=0.5, CHARSIZE=1.2, /NORMAL
  ENDIF
  ; Pre-draw procedures: spectrum-time diagram (SP)
  IF (~KEYWORD_SET(LS_ONLY) AND (*(*info).winswitch).showrefsp) THEN BEGIN
  	IF (*(*info).dispparams).slices_imscale THEN BEGIN
      sel_idx = (*(*info).intparams).lp_ref_diag_all+$
        (*(*info).intparams).ndiagnostics
      CRISPEX_DRAW_SCALING,event,refdisp,minimum,maximum, /REF
      refminmax = CRISPEX_SCALING_CONTRAST(minimum,maximum,$
        (*(*info).scaling).minimum[sel_idx], (*(*info).scaling).maximum[sel_idx])
    ENDIF
    WSET, (*(*info).winids).refspwid
    TV, *(*(*info).data).refspslice_congrid, (*(*info).plotpos).refspx0, $
      (*(*info).plotpos).refspy0, /NORM
    !X.WINDOW = [(*(*info).plotpos).refspx0,(*(*info).plotpos).refspx1]
    !Y.WINDOW = [(*(*info).plotpos).refspy0,(*(*info).plotpos).refspy1]
    ; In case of multiple diagnostics, overplot separator axes
    IF ((*(*info).intparams).nrefdiagnostics GT 1) THEN BEGIN
      ; Loop over all but the last diagnostic for plotting separators
      FOR d=1,(*(*info).intparams).ndisp_refdiagnostics-1 DO BEGIN
        AXIS,(d GE 1)*TOTAL((*(*(*info).plotaxes).refdiag_range_sp)[0:(d-1)])+$
          (*(*info).plotpos).refspx0, YAXIS=0, $
          YTICKLEN=(*(*info).plotaxes).refspyticklen, $
          YTICKNAME=REPLICATE(' ',60), COLOR=100,/NORMAL, $
          YRANGE=[(*(*info).dispparams).t_low_ref, $
          (*(*info).dispparams).t_upp_ref], YSTYLE=1, /NOERASE
        AXIS,(d GE 1)*TOTAL((*(*(*info).plotaxes).refdiag_range_sp)[0:(d-1)])+$
          (*(*info).plotpos).refspx0, YAXIS=1, $
          YTICKLEN=(*(*info).plotaxes).refspyticklen, $
          YTICKNAME=REPLICATE(' ',60), COLOR=100,/NORMAL,$
          YRANGE = [(*(*info).dispparams).t_low_ref, $
          (*(*info).dispparams).t_upp_ref], YSTYLE=1, /NOERASE
      ENDFOR
    ENDIF
    IF ((*(*info).dispswitch).xyref_out_of_range EQ 0) THEN BEGIN
      ; Overplot time indicator
    	PLOTS, [(*(*info).plotpos).refspx0,(*(*info).plotpos).refspx1], $
              [1,1]*( ((*(*(*info).dispparams).tarr_ref)[$
              (*(*info).dispparams).t]-(*(*info).dispparams).t_low_ref) / $
              FLOAT((*(*info).dispparams).t_upp_ref-$
              (*(*info).dispparams).t_low_ref) * (*(*info).plotpos).refyplspw +$
              (*(*info).plotpos).refspy0), /NORMAL, COLOR = 100
      ; Overplot lp indicator
      IF ((*(*info).intparams).nrefdiagnostics GT 1) THEN BEGIN
        ; Determine in which diagnostic the current LP lies
        IF (lp_ref_diag EQ 0) THEN $
          offset = 0 $
        ELSE $
          offset = $
            TOTAL((*(*(*info).plotaxes).refdiag_range_sp)[0:(lp_ref_diag-1)])
        refspx0 = (*(*info).plotpos).refspx0 + offset
        refxplspw = (*(*(*info).plotaxes).refdiag_range_sp)[lp_ref_diag]
        ; Get the corresponding lp_disprange
        lp_ref_disprange = (*(*info).dataparams).reflps[$
          (*(*(*info).intparams).refdiag_starts)[lp_ref_diag]+$
          (*(*(*info).intparams).refdiag_widths)[lp_ref_diag]-1]-$
          (*(*info).dataparams).reflps[$
          (*(*(*info).intparams).refdiag_starts)[lp_ref_diag]]
      ENDIF ELSE BEGIN
        lp_ref_disprange = ((*(*info).dataparams).reflps[$
          (*(*info).dispparams).lp_ref_upp] - $
          (*(*info).dataparams).reflps[(*(*info).dispparams).lp_ref_low])
        refspx0 = (*(*info).plotpos).refspx0
        refxplspw = (*(*info).plotpos).refxplspw 
      ENDELSE
    	PLOTS, [1,1] * ( $
        ((*(*info).dataparams).reflps[(*(*info).dataparams).lp_ref] - $
        (*(*info).dataparams).reflps[(*(*(*info).intparams).refdiag_starts)[$
        lp_ref_diag]])/lp_ref_disprange * refxplspw + refspx0 ), $
    		[(*(*info).plotpos).refspy0, (*(*info).plotpos).refspy1], /NORMAL, $
        COLOR = 100
    ENDIF ELSE $
  		XYOUTS, (*(*info).plotpos).refxplspw/2.+(*(*info).plotpos).refspx0,$
              (*(*info).plotpos).refyplspw/2.+(*(*info).plotpos).refspy0,$
              'No data available for!Cselected pixel position', COLOR=255, $
              ALIGNMENT = 0.5, CHARSIZE=1.2, /NORMAL
  ENDIF
END

PRO CRISPEX_DRAW_PHIS, event
; (Re)draw spectral slice along a slit procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WSET, (*(*info).winids).phiswid
  ; If 2D, then display
  IF ((SIZE(*(*(*info).data).phislice))[0] EQ 2) THEN BEGIN
    FOR d=0,(*(*info).intparams).ndisp_diagnostics-1 DO BEGIN
      ; Get spectrum-slit diagram by diagnostics
      IF ((*(*info).intparams).ndiagnostics GT 1) THEN BEGIN
        lp_lower = TOTAL((*(*(*info).intparams).diag_widths)[0:d]) - $
          (*(*(*info).intparams).diag_widths)[d]
        lp_upper = lp_lower+(*(*(*info).intparams).diag_widths)[d]-1
      ENDIF ELSE BEGIN
        lp_lower = 0
        lp_upper = (*(*info).dispparams).lp_upp-(*(*info).dispparams).lp_low
      ENDELSE
      ; Construct spectrum-slit diagram by diagnostic
      tmp_disp = BYTSCL( (*(*(*info).data).phislice)[lp_lower:lp_upper,*], $
        MIN=(*(*info).scaling).phislice_min[(*(*(*info).intparams).wheredispdiag)[d]],$ 
        MAX=(*(*info).scaling).phislice_max[(*(*(*info).intparams).wheredispdiag)[d]],$
        /NAN)
      IF (d EQ 0) THEN $
        final_disp = tmp_disp $
      ELSE $
        final_disp = [final_disp, tmp_disp]
    ENDFOR
    ; Display full spectrum-slit diagram at once
    TV,(CONGRID( final_disp, (*(*info).dispparams).phisnlpreb, $
      (*(*info).dispparams).nphireb, INTERP = (*(*info).dispparams).interpspslice, /CENTER) ), $
      (*(*info).plotpos).phisx0, (*(*info).plotpos).phisy0, /NORMAL
    !X.WINDOW = [(*(*info).plotpos).phisx0,(*(*info).plotpos).phisx1]
    !Y.WINDOW = [(*(*info).plotpos).phisy0,(*(*info).plotpos).phisy1]
    IF ((*(*info).intparams).ndiagnostics GT 1) THEN BEGIN
      ; Loop over all but the last diagnostic for plotting separators
      FOR d=1,(*(*info).intparams).ndisp_diagnostics-1 DO BEGIN
        AXIS,TOTAL((*(*(*info).plotaxes).diag_range_phis)[0:(d-1)])+(*(*info).plotpos).phisx0, YAXIS=0, $
          YTICKLEN=(*(*info).plotaxes).phisyticklen, YTICKNAME = REPLICATE(' ',60), COLOR=100,/NORMAL,$
          YRANGE = (*(*info).plotaxes).phis_yrange, /YSTYLE, /NOERASE
        AXIS,TOTAL((*(*(*info).plotaxes).diag_range_phis)[0:(d-1)])+(*(*info).plotpos).phisx0, YAXIS=1, $
          YTICKLEN=(*(*info).plotaxes).phisyticklen, YTICKNAME = REPLICATE(' ',60), COLOR=100,/NORMAL,$
          YRANGE = (*(*info).plotaxes).phis_yrange, /YSTYLE, /NOERASE
      ENDFOR
    ENDIF
    ; Overplot slit center indicator
  	PLOTS, [(*(*info).plotpos).phisx0, (*(*info).plotpos).phisx1], $
      [1,1] * ( (((*(*info).phiparams).nw_cur - (*(*info).phiparams).nphi)/2. + $
                  (*(*info).phiparams).sphi+0.5)/FLOAT((*(*info).phiparams).nw_cur)*$
                  (*(*info).plotpos).phisyplspw + (*(*info).plotpos).phisy0), /NORMAL, COLOR = 100
    ; Overplot lp indicator
    lp_diag = TOTAL((*(*info).dataparams).lp GE *(*(*info).intparams).diag_starts)-1
    IF ((*(*info).intparams).ndiagnostics GT 1) THEN BEGIN
      ; Determine in which diagnostic the current LP lies
      IF (lp_diag EQ 0) THEN $
        offset = 0 $
      ELSE $
        offset = TOTAL((*(*(*info).plotaxes).diag_range_phis)[0:(lp_diag-1)])
      phisx0 = (*(*info).plotpos).phisx0 + offset
      phisxplspw = (*(*(*info).plotaxes).diag_range_phis)[lp_diag]
      ; Get the corresponding lp_disprange
      lp_disprange = (*(*info).dataparams).lps[$
                      (*(*(*info).intparams).diag_starts)[lp_diag]+$
                      (*(*(*info).intparams).diag_widths)[lp_diag]-1] - $
                      (*(*info).dataparams).lps[$
                      (*(*(*info).intparams).diag_starts)[lp_diag]]
      lp_lower = (*(*info).dataparams).lps[(*(*(*info).intparams).diag_starts)[lp_diag]]
    ENDIF ELSE BEGIN
      lp_disprange = ((*(*info).dataparams).lps[(*(*info).dispparams).lp_upp] - $
                      (*(*info).dataparams).lps[(*(*info).dispparams).lp_low])
      phisx0 = (*(*info).plotpos).phisx0
      phisxplspw = (*(*info).plotpos).phisxplspw 
      lp_lower = (*(*info).dataparams).lps[(*(*info).dispparams).lp_low]
    ENDELSE
  	PLOTS, [1,1] * ( ((*(*info).dataparams).lps[(*(*info).dataparams).lp] - $
                      lp_lower) / lp_disprange * phisxplspw + phisx0 ), $
  		[(*(*info).plotpos).phisy0, (*(*info).plotpos).phisy1], /NORMAL, COLOR = 100
  ; If not 2D, then show black screen and "error" message
  ENDIF ELSE BEGIN
    TV, CONGRID(*(*(*info).data).emptydopslice,(*(*info).dispparams).phisnlpreb, $
      (*(*info).dispparams).nphireb), (*(*info).plotpos).phisx0, (*(*info).plotpos).phisy0, /NORMAL
		XYOUTS, (*(*info).plotpos).phisxplspw/2.+(*(*info).plotpos).phisx0,$
            (*(*info).plotpos).phisyplspw/2.+(*(*info).plotpos).phisy0,$
            'No Phi-slice availabe for !C selected pixel position', COLOR = 255, ALIGNMENT = 0.5, $
            CHARSIZE=1.2, /NORMAL
  ENDELSE
END

PRO CRISPEX_DRAW_LOOPSLAB, event
; (Re)draw loop timeslice procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	WSET, (*(*info).winids).loopwid
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).winids).loopwid], $
    labels=['Window ID for draw']
  IF ((*(*info).loopparams).nw_lpts NE 0) THEN BEGIN
  	dispslice = (*(*(*info).loopsdata).loopslice)[*,$
      (*(*(*info).dispparams).tsel_main)[(*(*info).dispparams).t_low]:$
      (*(*(*info).dispparams).tsel_main)[(*(*info).dispparams).t_upp]]
  	IF (*(*info).dispparams).slices_imscale THEN BEGIN
      CRISPEX_DRAW_SCALING,event,imdisp,minimum,maximum,/MAIN 
      minmax = CRISPEX_SCALING_CONTRAST(minimum,maximum,$
        (*(*info).scaling).minimum[(*(*info).intparams).lp_diag_all],$
        (*(*info).scaling).maximum[(*(*info).intparams).lp_diag_all])
    ENDIF ELSE BEGIN
      minimum = MIN(dispslice,MAX=maximum)
      minmax = [minimum, maximum]
    ENDELSE
    IF ((*(*info).loopparams).ngaps GE 1) THEN BEGIN
      dispslice_data = dispslice
      ; Arbitrary, but consistent, minimum value such that the gaps are really
      ; black compared to the data values
      min_dispslice_data = $
        -(1+(MIN(dispslice_data) LT 0)*2) * ABS(MIN(dispslice_data))
      IF ((*(*(*info).loopsdata).empty_slice)[0,0] NE min_dispslice_data) THEN $
        REPLICATE_INPLACE, *(*(*info).loopsdata).empty_slice, min_dispslice_data
      dispslice = (*(*(*info).loopsdata).empty_slice)[*, $
        (*(*(*info).dispparams).tsel_main)[(*(*info).dispparams).t_low]:$
        (*(*(*info).dispparams).tsel_main)[(*(*info).dispparams).t_upp]]
      idx_out = $
        (*(*(*info).loopparams).w_lpts)[*(*(*info).loopparams).databounds]
      FOR i=0,N_ELEMENTS(*(*(*info).loopparams).databounds)/2-1 DO $
        dispslice[idx_out[2*i]:idx_out[2*i+1], *] = $
          dispslice_data[$
            (*(*(*info).loopparams).databounds)[2*i]:$
            (*(*(*info).loopparams).databounds)[2*i+1],*]
    ENDIF
  ENDIF ELSE BEGIN
    REPLICATE_INPLACE, *(*(*info).loopsdata).empty_slice, 0
    dispslice = *(*(*info).loopsdata).empty_slice
    minmax = [0,1]
  ENDELSE
	TV, CONGRID( BYTSCL(dispslice, MIN=minmax[0], MAX=minmax[1], /NAN), $
    (*(*info).dispparams).loopnlxreb, (*(*info).dispparams).loopntreb, $
    /INTERP), (*(*info).plotpos).loopx0, (*(*info).plotpos).loopy0, /NORM
  IF ((*(*info).loopparams).nw_lpts NE 0) THEN BEGIN
    ; Overplot time indicator
  	PLOTS, [(*(*info).plotpos).loopx0,(*(*info).plotpos).loopx1], $
            [1,1]*( ((*(*(*info).dispparams).tarr_main)[(*(*info).dispparams).t]-$
            (*(*info).dispparams).t_low_main) / $
            FLOAT((*(*info).dispparams).t_upp_main-(*(*info).dispparams).t_low_main) * $
  	        (*(*info).plotpos).loopyplspw + (*(*info).plotpos).loopy0), /NORMAL, $
            COLOR = 100
    ; Overplot crossloc indicators
  	FOR i=0,(*(*info).loopparams).np-1 DO BEGIN
  		PLOTS, [1,1] * ( FLOAT((*(*(*info).loopsdata).crossloc)[i]) / $
        FLOAT((*(*info).loopsdata).loopsize-1) * (*(*info).plotpos).loopxplspw + $
        (*(*info).plotpos).loopx0 ), $
  			[(*(*info).plotpos).loopy0, (*(*info).plotpos).loopy1], /NORMAL, COLOR = 100
  		IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
        CRISPEX_VERBOSE_GET, event, (*(*(*info).loopsdata).crossloc)[i], $
          labels='crossloc['+STRTRIM(i,2)+']'
  	ENDFOR
  ENDIF ELSE $
		XYOUTS, (*(*info).plotpos).loopxplspw/2.+(*(*info).plotpos).loopx0,$
            (*(*info).plotpos).loopyplspw/2.+(*(*info).plotpos).loopy0,$
            'No space-time diagram availabe !C for current path', COLOR = 255, $
            ALIGNMENT = 0.5, CHARSIZE=1.2, /NORMAL
END

PRO CRISPEX_DRAW_REFLOOPSLAB, event
; (Re)draw reference loop timeslice procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	WSET, (*(*info).winids).refloopwid
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).winids).refloopwid], $
    labels=['Window ID for draw']
  IF ((*(*info).loopparams).nw_lpts_ref NE 0) THEN BEGIN
  	dispslice = (*(*(*info).loopsdata).refloopslice)[*,$
      (*(*(*info).dispparams).tsel_ref)[(*(*info).dispparams).t_low]:$
      (*(*(*info).dispparams).tsel_ref)[(*(*info).dispparams).t_upp]]
    sel_idx = (*(*info).intparams).lp_ref_diag_all+(*(*info).intparams).ndiagnostics
  	IF (*(*info).dispparams).slices_imscale THEN BEGIN
      CRISPEX_DRAW_SCALING,event,refdisp,minimum,maximum,/REFERENCE 
      minmax = CRISPEX_SCALING_CONTRAST(minimum,maximum,$
        (*(*info).scaling).minimum[sel_idx], (*(*info).scaling).maximum[sel_idx])
    ENDIF ELSE BEGIN
      minimum = MIN(dispslice,MAX=maximum)
      minmax = [minimum, maximum]
    ENDELSE
    IF ((*(*info).loopparams).ngaps_ref GE 1) THEN BEGIN
      dispslice_data = dispslice
      ; Arbitrary, but consistent, minimum value such that the gaps are really
      ; black compared to the data values
      min_dispslice_data = $
        -(1+(MIN(dispslice_data) LT 0)*2) * ABS(MIN(dispslice_data))
      IF ((*(*(*info).loopsdata).empty_slice)[0,0] NE min_dispslice_data) THEN $
        REPLICATE_INPLACE, *(*(*info).loopsdata).empty_slice, min_dispslice_data
      dispslice = (*(*(*info).loopsdata).empty_slice)[*, $
        (*(*(*info).dispparams).tsel_ref)[(*(*info).dispparams).t_low]:$
        (*(*(*info).dispparams).tsel_ref)[(*(*info).dispparams).t_upp]]
      idx_out = $
        (*(*(*info).loopparams).w_lpts_ref)[*(*(*info).loopparams).databounds_ref]
      FOR i=0,N_ELEMENTS(*(*(*info).loopparams).databounds_ref)/2-1 DO $
        dispslice[idx_out[2*i]:idx_out[2*i+1], *] = $
          dispslice_data[$
            (*(*(*info).loopparams).databounds_ref)[2*i]:$
            (*(*(*info).loopparams).databounds_ref)[2*i+1],*]
    ENDIF
  ENDIF ELSE BEGIN
    dispslice = *(*(*info).loopsdata).empty_slice
    minmax = [0,1]
  ENDELSE
	TV, CONGRID( BYTSCL(dispslice, MIN=minmax[0], MAX=minmax[1], /NAN), $
    (*(*info).dispparams).refloopnlxreb, $
    (*(*info).dispparams).refloopntreb, /INTERP), $
		(*(*info).plotpos).refloopx0, (*(*info).plotpos).refloopy0,/NORM
  IF ((*(*info).loopparams).nw_lpts_ref NE 0) THEN BEGIN
    ; Overplot time indicator
  	PLOTS, [(*(*info).plotpos).refloopx0,(*(*info).plotpos).refloopx1], $
            [1,1]*( ((*(*(*info).dispparams).tarr_ref)[(*(*info).dispparams).t]-$
            (*(*info).dispparams).t_low_ref) / $
            FLOAT((*(*info).dispparams).t_upp_ref-(*(*info).dispparams).t_low_ref) * $
  	        (*(*info).plotpos).refloopyplspw + (*(*info).plotpos).refloopy0), $
            /NORMAL, COLOR = 100
    ; Overplot crossloc indicators
  	FOR i=0,(*(*info).loopparams).np_ref-1 DO BEGIN
  		PLOTS, [1,1] * ( FLOAT((*(*(*info).loopsdata).refcrossloc)[i]) / $
        FLOAT((*(*info).loopsdata).refloopsize-1) * (*(*info).plotpos).refloopxplspw + $
        (*(*info).plotpos).refloopx0 ), $
  			[(*(*info).plotpos).refloopy0, (*(*info).plotpos).refloopy1], /NORMAL, $
        COLOR = 100
  		IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
        CRISPEX_VERBOSE_GET, event, (*(*(*info).loopsdata).refcrossloc)[i], $
          labels='crossloc['+STRTRIM(i,2)+']'
  	ENDFOR
  ENDIF ELSE $
		XYOUTS, (*(*info).plotpos).refloopxplspw/2.+(*(*info).plotpos).refloopx0,$
            (*(*info).plotpos).refloopyplspw/2.+(*(*info).plotpos).refloopy0,$
            'No space-time diagram availabe !C for current path', COLOR = 255, $
            ALIGNMENT = 0.5, CHARSIZE=1.2, /NORMAL
END

PRO CRISPEX_DRAW_REST_LOOP, event
; (Re)draw restored loop timeslice procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	FOR k=0,N_ELEMENTS(*(*(*info).winids).restlooptlb)-1 DO BEGIN
		WSET, (*(*(*info).winids).restloopwid)[k]
		IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
      CRISPEX_VERBOSE_GET, event, [(*(*(*info).winids).restloopwid)[k]], $
      labels=['Window ID for draw']
    IF (*(*(*info).restoreparams).disp_imref)[k] THEN BEGIN
      tsel = *(*(*info).dispparams).tsel_ref 
      tarr = *(*(*info).dispparams).tarr_ref 
    ENDIF ELSE BEGIN
      tsel = *(*(*info).dispparams).tsel_main
      tarr = *(*(*info).dispparams).tarr_main
    ENDELSE
		IF (*(*(*info).dispswitch).restricted_t_range)[k] THEN BEGIN
			lower_t = 0
			upper_t = tsel[(*(*info).dispparams).t_upp] - tsel[(*(*info).dispparams).t_low]
		ENDIF ELSE BEGIN
			lower_t = tsel[(*(*info).dispparams).t_low]
			upper_t = tsel[(*(*info).dispparams).t_upp]
		ENDELSE
    lower_t_val = tarr[(*(*info).dispparams).t_low]
    upper_t_val = tarr[(*(*info).dispparams).t_upp]
    ; Get dispslice
		dispslice = (*(*(*(*info).loopsdata).rest_loopslice[k]))[*,lower_t:upper_t]
		IF (*(*(*info).restoreparams).disp_imref)[k] THEN BEGIN
			IF (*(*info).dispparams).slices_imscale THEN $
        CRISPEX_DRAW_SCALING,event,refdisp,minimum,maximum, /REFERENCE $
      ELSE $
        minimum = MIN(dispslice,MAX=maximum, /NAN)
		ENDIF ELSE BEGIN
			IF (*(*info).dispparams).slices_imscale THEN $
        CRISPEX_DRAW_SCALING,event,imdisp,minimum,maximum,/MAIN $
      ELSE $
        minimum = MIN(dispslice,MAX=maximum, /NAN)
		ENDELSE
    sel_idx = (*(*(*info).restoreparams).disp_loopnr)[k]
    IF ((*(*(*info).restoreparams).ngaps)[sel_idx] GE 1) THEN BEGIN
      sel_databounds = $
        *(*(*(*info).restoreparams).databounds)[sel_idx]
      sel_wdatabounds = $
        *(*(*(*info).restoreparams).wdatabounds)[sel_idx]
      dispslice_data = dispslice
      ; Select subset of rest_empty_slice if necessary
      dispslice = (*(*(*(*info).loopsdata).rest_empty_slice)[sel_idx])[*,$
        lower_t:upper_t]
      ; Fill dispslice with empty and actual data
      FOR i=0,N_ELEMENTS(sel_databounds)/2-1 DO $
        dispslice[sel_wdatabounds[2*i]:sel_wdatabounds[2*i+1], *] = $
          dispslice_data[sel_databounds[2*i]:sel_databounds[2*i+1],*]
    ENDIF
    ; Display slice
		TV, CONGRID( BYTSCL(dispslice, MIN=minimum, MAX=maximum, /NAN), $
      (*(*info).dispparams).restloopnlxreb,$
      (*(*info).dispparams).restloopntreb, /INTERP), $
			(*(*info).plotpos).restloopx0, (*(*info).plotpos).restloopy0, /NORM
    ; Overplot time indicator
		PLOTS, [(*(*info).plotpos).restloopx0, (*(*info).plotpos).restloopx1], $
      ;[1,1] * ( ((*(*info).dispparams).t-(*(*info).dispparams).t_low) / $
      ;FLOAT((*(*info).dispparams).t_range-1) * $
      [1,1]*( (tarr[(*(*info).dispparams).t]-lower_t_val) / $
      FLOAT(upper_t_val-lower_t_val) * (*(*info).plotpos).restloopyplspw + $
      (*(*info).plotpos).restloopy0), /NORMAL, COLOR = 100
		FOR i=0,(SIZE(*(*(*(*info).loopsdata).rest_crossloc[k])))[1]-1 DO BEGIN
			PLOTS, [1,1] * ( FLOAT((*(*(*(*info).loopsdata).rest_crossloc[k]))[i]) /$
		    FLOAT(N_ELEMENTS(*(*(*(*info).restoreparams).xr)[sel_idx])-1) * $
;        FLOAT((*(*(*info).loopsdata).rest_loopsize)[k]-1) * $
        (*(*info).plotpos).restloopxplspw + (*(*info).plotpos).restloopx0 ),$
				[(*(*info).plotpos).restloopy0, (*(*info).plotpos).restloopy1], $
        /NORMAL, COLOR = 100
		ENDFOR
	ENDFOR
END

PRO CRISPEX_DRAW_RETR_DET, event
; (Re)draw restreived detection procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WSET, (*(*info).winids).retrdetwid
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).winids).retrdetwid], labels=['Window ID for draw']
  ; Get dispslice
 	dispslice = (*(*(*info).loopsdata).det_loopslice)[*,$
    (*(*info).dispparams).t_low_main:(*(*info).dispparams).t_upp_main]
	IF (*(*info).dispparams).slices_imscale THEN $
    CRISPEX_DRAW_SCALING,event,imdisp,minimum,maximum,/MAIN $
  ELSE $
    minimum = MIN(dispslice,MAX=maximum, /NAN)
  IF ((*(*info).detparams).ngaps GE 1) THEN BEGIN
    dispslice_data = dispslice
    ; Select subset of det_empty_slice if necessary
    dispslice = (*(*(*info).loopsdata).det_empty_slice)[*, $
      (*(*info).dispparams).t_low_main:(*(*info).dispparams).t_upp_main]
    ; Fill dispslice with empty and actual data
    FOR i=0,N_ELEMENTS(*(*(*info).detparams).databounds)/2-1 DO $
      dispslice[(*(*(*info).detparams).wdatabounds)[2*i]:$
                (*(*(*info).detparams).wdatabounds)[2*i+1],*] = $
        dispslice_data[(*(*(*info).detparams).databounds)[2*i]:$
                       (*(*(*info).detparams).databounds)[2*i+1],*]
  ENDIF
  ; Display slice
	TV, CONGRID( BYTSCL(dispslice, MIN=minimum, MAX=maximum, /NAN), $
    (*(*info).dispparams).retrdetnlxreb, (*(*info).dispparams).retrdetntreb, /INTERP), $
		(*(*info).plotpos).retrdetx0, (*(*info).plotpos).retrdety0, /NORM
  ; Overplot time indicator
	PLOTS, [(*(*info).plotpos).retrdetx0, (*(*info).plotpos).retrdetx1], $
    [1,1]*( ((*(*(*info).dispparams).tarr_main)[(*(*info).dispparams).t]-$
    (*(*info).dispparams).t_low_main) / $
    FLOAT((*(*info).dispparams).t_upp_main-(*(*info).dispparams).t_low_main) * $
    (*(*info).plotpos).retrdetyplspw + (*(*info).plotpos).retrdety0), /NORMAL, COLOR = 100
END

;================================================================================= ESTIMATE SAVING TIME PROCEDURES
PRO CRISPEX_ESTIMATE_TIME_WINDOW, event
; Opens the calculating saving time estimate window
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	base = WIDGET_BASE(TITLE = 'CRISPEX'+(*(*info).sesparams).instance_label+': CALCULATING...', GROUP_LEADER = (*(*info).winids).root, TLB_FRAME_ATTR = 1, /TLB_KILL_REQUEST_EVENTS)
	disp = WIDGET_BASE(base, /COLUMN)
	message_base = WIDGET_BASE(disp, /COLUMN)
	(*(*info).ctrlsfeedb).estimate_label = WIDGET_LABEL(message_base, VALUE = 'Calculating time required for save procedure. Please wait...', /ALIGN_LEFT)
	label2	= WIDGET_LABEL(message_base, VALUE = ' ')
	WIDGET_CONTROL, base, /REALIZE, TLB_SET_XOFFSET = 500, TLB_SET_YOFFSET = 500
	WIDGET_CONTROL, base, SET_UVALUE = info
	XMANAGER, 'CRISPEX', base, /NO_BLOCK
	(*(*info).winids).estimatetlb = base
	(*(*info).winswitch).estimate_win = 1
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).winids).estimatetlb], labels=['estimatetlb']
END

PRO CRISPEX_ESTIMATE_TIME_CALCULATION, event
; Performs the actual saving time estimate calculation
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (*(*info).loopswitch).retrieve_loops THEN BEGIN
		RESTORE,(*(*(*info).retrparams).retrieve_files)[0]
		*(*(*info).loopparams).xr = x_loop_pts		&	*(*(*info).loopparams).yr = y_loop_pts
		*(*(*info).loopparams).w_lpts = w_loop_pts	&	(*(*info).dataparams).lp = spect_pos
	ENDIF 
	IF ((*(*info).dataparams).nt LT 100) THEN BEGIN
		endt = (*(*info).dataparams).nt & modulus = FIX((*(*info).dataparams).nt/3.) & result2 = FIX((*(*info).dataparams).nt/9.) & result3 = FIX((*(*info).dataparams).nt/9.*2.)
	ENDIF ELSE BEGIN
		endt = 100 & modulus = 30 & result2 = 10 & result3 = 20
	ENDELSE
	t_0 = SYSTIME(/SECONDS)
	FOR t=0,endt-1 DO BEGIN
			IF (t EQ 0) THEN tmp = INTERPOLATE( (*(*(*info).data).imagedata)[t*(*(*info).dataparams).nlp + (*(*info).dataparams).lp], (*(*(*info).loopparams).xr)[*(*(*info).loopparams).w_lpts],$
				(*(*(*info).loopparams).yr)[*(*(*info).loopparams).w_lpts]) $
			ELSE tmp = [[tmp], [INTERPOLATE( (*(*(*info).data).imagedata)[t*(*(*info).dataparams).nlp + (*(*info).dataparams).lp], (*(*(*info).loopparams).xr)[*(*(*info).loopparams).w_lpts],$
				(*(*(*info).loopparams).yr)[*(*(*info).loopparams).w_lpts])]]
		IF (t mod modulus EQ 0) THEN WIDGET_CONTROL, (*(*info).ctrlsfeedb).estimate_label, SET_VALUE = 'Calculating time required for save procedure. Please wait.'
		IF (t mod modulus EQ result2) THEN WIDGET_CONTROL, (*(*info).ctrlsfeedb).estimate_label, SET_VALUE = 'Calculating time required for save procedure. Please wait..'
		IF (t mod modulus EQ result3) THEN WIDGET_CONTROL, (*(*info).ctrlsfeedb).estimate_label, SET_VALUE = 'Calculating time required for save procedure. Please wait...'
	ENDFOR
	(*(*info).feedbparams).estimate_lx = N_ELEMENTS(*(*(*info).loopparams).w_lpts)
	(*(*info).feedbparams).estimate_time = (SYSTIME(/SECONDS) - t_0) / FLOAT(endt)
	(*(*info).feedbparams).estimate_run = 1
	WIDGET_CONTROL, (*(*info).ctrlscp).clear_current_estimate, /SENSITIVE
	IF (*(*info).loopswitch).retrieve_loops THEN BEGIN
		*(*(*info).loopparams).xr = 0	&	*(*(*info).loopparams).yr = 0	&	*(*(*info).loopparams).w_lpts = 0
	ENDIF
END

PRO CRISPEX_ESTIMATE_FULL_TIME, time, denom, units
; Gets the units and denominator for the saving time estimate calculation
	IF (time LT 60) THEN BEGIN
		units = ' seconds'
		denom = 1. 
	ENDIF ELSE IF (time LT 3600) THEN BEGIN
		units = ' minutes' 
		denom = 60. 
	ENDIF ELSE IF (time LT 86400) THEN BEGIN
		units = ' hours' 
		denom = 3600.
	ENDIF ELSE BEGIN
		units = ' days'
		denom = 86400.
	ENDELSE
END

PRO CRISPEX_ESTIMATE_FULL_TIME_RUNNING, pass, totalpasses, t0, t1, denom, units, accumsectime, totalsectime
; Gets the units and denominator for the saving time running estimate
	accumsectime = t1-t0
	totalsectime = accumsectime/pass*totalpasses
	IF (totalsectime GT 60) THEN BEGIN
		IF (totalsectime GT 3600) THEN BEGIN
			IF (totalsectime GT 86400) THEN BEGIN
				units = ' days.'
				denom = 86400.
			ENDIF ELSE BEGIN
				units = ' hours.'
				denom = 3600.
			ENDELSE
		ENDIF ELSE BEGIN
			units = ' minutes.'
			denom = 60.
		ENDELSE
	ENDIF ELSE BEGIN
		units = ' seconds.'
		denom = 1.
	ENDELSE
END

;================================================================================= TAB EVENT PROCEDURE
PRO CRISPEX_EVENT, event
; Handles tab events
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event, /IGNORE_LAST
END

;================================================================================= FIND CRISPEX OUTPUT FILE PROCEDURES
PRO CRISPEX_FIND_CLSAV, event
; Finds CLSAV output files (i.e. saved loop points files)
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	imagefilename = STRMID((*(*info).dataparams).imfilename,STRPOS((*(*info).dataparams).imfilename,PATH_SEP(),/REVERSE_SEARCH)+1,STRLEN((*(*info).dataparams).imfilename))
	firstsplit = STRMID(imagefilename,0,STRPOS(imagefilename,'.',/REVERSE_SEARCH))
	fstr = STRSPLIT(firstsplit[0],'_',/EXTRACT)
	IF (N_ELEMENTS(fstr) GE 2) THEN filename = fstr[0]+'_'+fstr[1] ELSE filename = fstr[0]
	clfiles = FILE_SEARCH((*(*info).paths).ipath+filename+"*clsav", COUNT = clfilecount)
	*(*(*info).retrparams).clfiles  = clfiles
	(*(*info).retrparams).clfilecount = clfilecount
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [imagefilename, filename, STRTRIM((*(*info).retrparams).clfilecount,2)], labels=['filename','basename','clfilecount']
END

PRO CRISPEX_FIND_CSAV, event, ALLOW_SELECT_DIR=allow_select_dir
; Finds CSAV output files (i.e. saved loopslice/slab files)
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  refcfilecount = 0
	imagefilename = FILE_BASENAME((*(*info).dataparams).imfilename)
	firstsplit = STRMID(imagefilename,0,STRPOS(imagefilename,'.',/REVERSE_SEARCH))
  ; Do initial search
	cfiles = FILE_SEARCH((*(*info).paths).ipath+firstsplit+"*csav", $
    COUNT = cfilecount)
	IF (*(*info).dataswitch).reffile THEN BEGIN
    refimfilename = FILE_BASENAME((*(*info).dataparams).refimfilename)
		reffirstsplit = STRMID(refimfilename,0,STRPOS(refimfilename,'.',$
      /REVERSE_SEARCH))
		refcfiles = FILE_SEARCH((*(*info).paths).ipath+reffirstsplit+"*csav", $
      COUNT = refcfilecount)
  ENDIF
  ; If no *csav files found, allow selection of new path and redo the search
  IF ((cfilecount EQ 0) AND (refcfilecount EQ 0) AND $
    KEYWORD_SET(ALLOW_SELECT_DIR)) THEN BEGIN
		CRISPEX_WINDOW_OK, event,'ERROR!',$
      'No saved time slice (*csav) files found corresponding '+$
      'to the current data file. Please select an alternative input path.',$
			OK_EVENT='CRISPEX_CLOSE_EVENT_WINDOW', BASE=tlb, /BLOCK
		(*(*info).winids).errtlb = tlb
    newpath = DIALOG_PICKFILE(TITLE='CRISPEX'+(*(*info).sesparams).instance_label+$
      ': Select input path', /DIRECTORY, $
      PATH=(*(*info).paths).ipath,/MUST_EXIST)
    ; Redo the search at the new path
  	cfiles = FILE_SEARCH(newpath+firstsplit+"*csav", $
      COUNT = cfilecount)
  	IF (*(*info).dataswitch).reffile THEN $
  		refcfiles = FILE_SEARCH(newpath+reffirstsplit+"*csav", $
        COUNT = refcfilecount)
  ENDIF
  ; Save variables
	IF (*(*info).dataswitch).reffile THEN BEGIN
		*(*(*info).restoreparams).cfiles  = [cfiles,refcfiles]
		(*(*info).restoreparams).cfilecount = cfilecount+refcfilecount
	ENDIF ELSE BEGIN
		*(*(*info).restoreparams).cfiles  = cfiles
		(*(*info).restoreparams).cfilecount = cfilecount
	ENDELSE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [imagefilename, filename, $
      STRTRIM((*(*info).restoreparams).cfilecount,2)], $
      labels=['filename','basename','cfilecount']
END

;================================================================================= HELP PROCEDURE
PRO CRISPEX_HELP, event
; Opens the CRISPEX Reference Pages
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	tempfile = FILEPATH('temp_crispex_redirect.html', /TMP)
	OPENW, lun, tempfile, /GET_LUN
	PRINTF, lun, '<HTML><HEADER><TITLE>CRISPEX help pages</TITLE><META HTTP-EQUIV="REFRESH" CONTENT="0;URL=http://folk.uio.no/gregal/crispex">'+$
		'</HEADER><BODY></BODY></HTML>'
	FREE_LUN, lun
	ONLINE_HELP, BOOK=tempfile
	WAIT, 10.0
	FILE_DELETE, tempfile
END

PRO CRISPEX_HELP_MAIL_BUG, event
; Opens a new message for bug reporting
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	tempfile = FILEPATH('temp_crispex_report_bug.html', /TMP)
	subject = 'CRISPEX:%20Reporting%20bug%20in%20v'+(*(*info).versioninfo).version_number+'%20(rev%20'+(*(*info).versioninfo).revision_number+')'
	OPENW, lun, tempfile, /GET_LUN
	PRINTF, lun, '<HTML><HEADER><TITLE>CRISPEX: Report a bug</TITLE><META HTTP-EQUIV="REFRESH" CONTENT="0;URL=mailto:g.j.m.vissers@astro.uio.no?SUBJECT='+subject+'">'+$
		'</HEADER><BODY>If your e-mail client does not automatically open up a new message window, you may also send your bug report manually to: g.j.m.vissers@astro.uio.no, '+$
		'preferrably with <i>"CRISPEX: Reporting bug in v'+(*(*info).versioninfo).version_number+' (rev '+(*(*info).versioninfo).revision_number+')"</i> as subject heading.</BODY></HTML>'
	FREE_LUN, lun
	ONLINE_HELP, BOOK=tempfile
	WAIT, 10.0
	FILE_DELETE, tempfile
END

PRO CRISPEX_HELP_MAIL_SUGGESTION, event
; Opens a new message for suggestion reporting
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	tempfile = FILEPATH('temp_crispex_report_suggestion.html', /TMP)
	subject = 'CRISPEX:%20Suggestion%20after%20v'+(*(*info).versioninfo).version_number+'%20(rev%20'+(*(*info).versioninfo).revision_number+')'
	OPENW, lun, tempfile, /GET_LUN
	PRINTF, lun, '<HTML><HEADER><TITLE>CRISPEX: Send a suggestion</TITLE><META HTTP-EQUIV="REFRESH" CONTENT="0;URL=mailto:g.j.m.vissers@astro.uio.no?SUBJECT='+subject+'">'+$
		'</HEADER><BODY>If your e-mail client does not automatically open up a new message window, you may also send your suggestion manually to: g.j.m.vissers@astro.uio.no, '+$
		'preferrably with <i>"CRISPEX: Suggestion after v'+(*(*info).versioninfo).version_number+' (rev '+(*(*info).versioninfo).revision_number+')"</i> as subject heading.</BODY></HTML>'
	FREE_LUN, lun
	ONLINE_HELP, BOOK=tempfile
	WAIT, 10.0
	FILE_DELETE, tempfile
END

PRO CRISPEX_HELP_SHORTCUTS, event
; Opens a window with an overview over the shortcuts
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  ; Populate shortcut elements
  kb_shortcuts = [{sh:'Ctrl+Shift+I', label:'Zoom in'}, $
                  {sh:'Ctrl+Shift+O', label:'Zoom out'}, $
                  {sh:'Shift+B', label:'Step to previous frame'}, $
                  {sh:'Shift+Backspace', label:'Play backwards'}, $
                  {sh:'Shift+Spacebar', label:'Pause'}, $
                  {sh:'Shift+Tab', label:'Play forwards'}, $
                  {sh:'Shift+F', label:'Step to next frame'}, $
                  {sh:'Shift+A', label:'Decrease main '+$
                    STRLOWCASE((*(*info).paramparams).sp_h[(*(*info).plotswitch).heightset])+$
                    ' position'}, $
                  {sh:'Shift+S', label:'Increase main '+$
                    STRLOWCASE((*(*info).paramparams).sp_h[(*(*info).plotswitch).heightset])+$
                    ' position'}, $
                  {sh:'Ctrl+A', label:'Decrease reference '+$
                    STRLOWCASE((*(*info).paramparams).sp_h[(*(*info).plotswitch).refheightset])+$
                    ' position'}, $
                  {sh:'Ctrl+S', label:'Increase reference '+$
                    STRLOWCASE((*(*info).paramparams).sp_h[(*(*info).plotswitch).refheightset])+$
                    ' position'} ]
  ms_shortcuts = [{sh:'Left click', label:'Lock cursor to current position /'}, $
                  {sh:' ', label:'Add current position to path'}, $
                  {sh:'Middle click', label:'Fix cursor position for measurement'}, $
                  {sh:'Right click', label:'Unlock cursor'} ]
	title = 'CRISPEX'+(*(*info).sesparams).instance_label+': Shortcuts'
  base  = WIDGET_BASE(TITLE=title, GROUP_LEADER=(*(*info).winids).root, $
            /TLB_FRAME_ATTR, /TLB_KILL_REQUEST_EVENTS)
  disp  = WIDGET_BASE(base, /COLUMN)
  cols  = WIDGET_BASE(disp, /GRID_LAYOUT, COLUMN=2)
  col1  = WIDGET_BASE(cols, /COLUMN);, /FRAME)
  kb_lab= WIDGET_LABEL(col1, VALUE='Keyboard shortcuts:', /ALIGN_LEFT)
  bases1 = WIDGET_BASE(col1, /ROW)
  sh_base1 = WIDGET_BASE(bases1, /COLUMN)
  lb_base1 = WIDGET_BASE(bases1, /COLUMN)
  FOR i=0,N_ELEMENTS(kb_shortcuts.sh)-1 DO BEGIN
    kb_label= WIDGET_LABEL(sh_base1, VALUE=(kb_shortcuts.sh)[i], /ALIGN_LEFT)
    lb_label= WIDGET_LABEL(lb_base1, VALUE=(kb_shortcuts.label)[i], /ALIGN_LEFT)
  ENDFOR
  col2  = WIDGET_BASE(cols, /COLUMN);, /FRAME)
  ms_lab= WIDGET_LABEL(col2, VALUE='Mouse shortcuts:', /ALIGN_LEFT)
  bases2 = WIDGET_BASE(col2, /ROW)
  sh_base2 = WIDGET_BASE(bases2, /COLUMN)
  lb_base2 = WIDGET_BASE(bases2, /COLUMN)
  FOR i=0,N_ELEMENTS(ms_shortcuts.sh)-1 DO BEGIN
    ms_label= WIDGET_LABEL(sh_base2, VALUE=(ms_shortcuts.sh)[i], /ALIGN_LEFT)
    lb_label= WIDGET_LABEL(lb_base2, VALUE=(ms_shortcuts.label)[i], /ALIGN_LEFT)
  ENDFOR
  close_base = WIDGET_BASE(disp, /ALIGN_CENTER)
  close_button = WIDGET_BUTTON(close_base, VALUE='Close', EVENT_PRO='CRISPEX_CLOSE_EVENT_WINDOW')
  WIDGET_CONTROL, base, /REALIZE, TLB_SET_XOFFSET=(*(*info).winsizes).aboutxoffset, $
    TLB_SET_YOFFSET=(*(*info).winsizes).aboutyoffset
  (*(*info).winids).shorttlb = base
  WIDGET_CONTROL, base, SET_UVALUE=info
  XMANAGER, 'CRISPEX', base, /NO_BLOCK
END

;==================== LIGHTCURVE SAVE PROCEDURES
PRO CRISPEX_INT_SAVE, event
; Handles the actual saving of the lightcurve plots
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	CRISPEX_SAVE_CHECK_PATH_WRITE, event
	CRISPEX_SAVE_DETERMINE_FILENAME, event, outfilename=intfilename, /tlab, ext='cint'
	condition = WHERE(*(*(*info).intparams).seldisp_diagnostics EQ 1, count)
  IF (count GT 0) THEN BEGIN
  	lightcurve = FLTARR((*(*info).dispparams).t_range,N_ELEMENTS(condition))
  	avg_intensity = FLTARR(N_ELEMENTS(condition))
  	FOR i=0,N_ELEMENTS(condition)-1 DO BEGIN
  		lightcurve[0,i] = REFORM( ( ( *(*(*info).data).spdata)[ $
        FIX((*(*info).dataparams).y) * (*(*info).dataparams).nx * (*(*info).dataparams).ns + $
        FIX((*(*info).dataparams).x) * (*(*info).dataparams).ns + $
  			(*(*info).dataparams).s ] )[$
        (*(*(*info).intparams).sellp_diagnostics)[condition[i]],$
          (*(*info).dispparams).t_low:(*(*info).dispparams).t_upp] )
  		avg_intensity[i] = MEAN(lightcurve[*,i], /NAN)
  	ENDFOR
    diagnostics = (*(*info).intparams).diagnostics[(*(*(*info).intparams).sel_diagnostics)[condition]]
  	x = (*(*info).dataparams).x		                &	y = (*(*info).dataparams).y
  	nt = (*(*info).dispparams).t_range	          & dt = (*(*info).plotaxes).dt
  	t_low_idx = (*(*info).dispparams).t_low	      &	t_upp_idx = (*(*info).dispparams).t_upp
    t_array_full = *(*(*info).dispparams).tarr_main
  	t_saved_idx = (*(*info).dispparams).t	  
    crispex_version = [(*(*info).versioninfo).version_number, (*(*info).versioninfo).revision_number]
  	SAVE, crispex_version, lightcurve, avg_intensity, diagnostics, nt, dt, $
      t_low_idx, t_upp_idx, t_array_full, t_saved_idx, x, y, $
      FILENAME=(*(*info).paths).opath+intfilename
  	PRINT, 'Written: '+(*(*info).paths).opath+intfilename
  ENDIF
END

;================================================================================= INTERRUPT PROCEDURE
PRO CRISPEX_INTERRUPT, event
; Handles interrupting at runtime
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event, /IGNORE_LAST
	PRINT,'Interrupted CRISPEX at runtime. Type [.c] to continue...'
	STOP
END

;========================= INPUT/OUTPUT PROCEDURES
PRO CRISPEX_IO_FAILSAFES_MAIN, imcube, spcube, input_single_cube, $
                               HDR_IN=hdr_in, HDR_OUT=hdr_out, $
                               STARTUPTLB=startuptlb, $
                               IO_FAILSAFE_ERROR=io_failsafe_error
  hdr_out = hdr_in
  io_failsafe_error = 0
  ; If SPCUBE has been supplied, check IMCUBE and SPCUBE compatibility
	IF hdr_out.spfile THEN BEGIN         
    ; Check whether SPCUBE and IMCUBE are actually the same
		IF ((spcube EQ imcube) OR ((hdr_in.nlp EQ hdr_in.nx) AND (hdr_in.mainnt EQ hdr_in.ny) AND $
       (hdr_in.spnt EQ hdr_in.imnt))) THEN BEGIN
      CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'IMCUBE and SPCUBE must be different. Please check '+$
        'input (you seem to have provided the same file twice).',/ERROR,/NO_ROUTINE
			IF (N_ELEMENTS(STARTUPTLB) EQ 1) THEN WIDGET_CONTROL, startuptlb, /DESTROY
      io_failsafe_error = 1
			RETURN
		ENDIF
    ; Check whether condensed third dimensions of SPCUBE and IMCUBE are incompatible
		IF ((hdr_in.nx*hdr_in.ny*hdr_in.ns NE hdr_in.spnt) OR $
       (hdr_in.mainnt*hdr_in.nlp*hdr_in.ns NE hdr_in.imnt)) THEN BEGIN							
      CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'IMCUBE and SPCUBE have incompatible dimensions and '+$
        'seem to belong to different datasets. Please check whether the input is correct (you '+$
        'provided IMCUBE='+STRTRIM(imcube,2)+' and SPCUBE='+STRTRIM(spcube,2)+').',/ERROR,$
        /NO_ROUTINE
			IF (N_ELEMENTS(STARTUPTLB) EQ 1) THEN WIDGET_CONTROL, startuptlb, /DESTROY
      io_failsafe_error = 1
			RETURN
		ENDIF
    ; Check, for multichannel cube, whether channels are incompatible
		IF hdr_out.multichannel THEN BEGIN
			IF ((hdr_in.spstokes NE hdr_in.imstokes) OR (hdr_in.spns NE hdr_in.imns)) THEN BEGIN
        CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'IMCUBE and SPCUBE have incompatible number of '+$
          'channels and seem to belong to different datasets. Please check whether the input is '+$
          'correct (you provided IMCUBE='+STRTRIM(imcube,2)+' and SPCUBE='+STRTRIM(spcube,2)+').',$
          /ERROR,/NO_ROUTINE
				IF (N_ELEMENTS(STARTUPTLB) EQ 1) THEN WIDGET_CONTROL, startuptlb, /DESTROY
        io_failsafe_error = 1
				RETURN
			ENDIF ELSE $
        hdr_out.ns = hdr_in.imns  ; If they are compatible, set general number of channels
		ENDIF ELSE hdr_out.ns = 1L       ; If not multiple channels, set general number channels to 1
    ; Check whether SINGLE_CUBE keyword has been set in combination with provided SPCUBE
		IF (N_ELEMENTS(INPUT_SINGLE_CUBE) GT 0) THEN BEGIN
      CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'Calling CRISPEX with SINGLE_CUBE, while SPCUBE is '+$
        'provided, is not allowed. SINGLE_CUBE keyword will be ignored.', /WARNING, /NO_ROUTINE
      io_failsafe_error = 2
			hdr_out.onecube = 0
		ENDIF
		hdr_out.single_cube[0] = 0
	ENDIF 
END

PRO CRISPEX_IO_FAILSAFES_MAIN_REF, HDR_IN=hdr_in, HDR_OUT=hdr_out, $
                                   STARTUPTLB=startuptlb, $
                                   IO_FAILSAFE_ERROR=io_failsafe_error
  hdr_out = hdr_in    
  ; Check dimensions of main and reference cubes
  ; Same nx, ny, dx, dy, crpix, crval -> must be same data, no mapping functions
  nxypix_eq = ((hdr_out.refnx EQ hdr_out.nx) AND (hdr_out.refny EQ hdr_out.ny))
  dxypix_eq = ((hdr_out.refdx EQ hdr_out.dx) AND (hdr_out.refdy EQ hdr_out.dy))
  refpix_eq = ((hdr_out.xpix_ref EQ hdr_out.xpix) AND $
    (hdr_out.ypix_ref EQ hdr_out.ypix))
  refval_eq = ((hdr_out.xval_ref EQ hdr_out.xval) AND $
    (hdr_out.yval_ref EQ hdr_out.yval)) 
  hdr_out.main2ref_no_map = (nxypix_eq AND dxypix_eq AND refpix_eq AND refval_eq)

  ; If mapping is necessary, check whether there is overlap at all
  IF (hdr_out.main2ref_no_map EQ 0) THEN BEGIN
    xref_low_main = hdr_out.xval_ref-hdr_out.xval
    yref_low_main = hdr_out.yval_ref-hdr_out.yval
    xref_upp_main = (hdr_out.refnx-1)*hdr_out.refdx/hdr_out.dx + $
                    (hdr_out.xval_ref-hdr_out.xval)
    yref_upp_main = (hdr_out.refny-1)*hdr_out.refdy/hdr_out.dy + $
                    (hdr_out.yval_ref-hdr_out.yval) 
    IF (((xref_upp_main LT 0) AND (yref_upp_main LT 0)) OR $
        ((xref_low_main GT (hdr_out.nx-1)) AND $
         (yref_low_main GT (hdr_out.ny-1)))) THEN BEGIN
      CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
        'The fields of view of the main and reference data do not seem to '+$
        'overlap. Please check that you have provided compatible data sets '+$
        'and that their headers are correct.', /ERROR, /NO_ROUTINE, /NEWLINE
  		IF (N_ELEMENTS(STARTUPTLB) EQ 1) THEN WIDGET_CONTROL, startuptlb, /DESTROY
      io_failsafe_error = 1
  		RETURN
    ENDIF 
  ENDIF
END

PRO CRISPEX_IO_FAILSAFES_REF, refcube, input_single_cube, HDR_IN=hdr_in, HDR_OUT=hdr_out, $
                              STARTUPTLB=startuptlb, $
                              IO_FAILSAFE_ERROR=io_failsafe_error
; Handles failsafes against wrongly supplied reference image and spectral cubes
  hdr_out = hdr_in
  io_failsafe_error = 0
  IF (N_ELEMENTS(REFCUBE) EQ 2) THEN BEGIN
    ; Failsafe against providing the same file as REFIMCUBE and REFSPCUBE
  	IF ((refcube[1] EQ refcube[0]) OR $         ; Check whether input cube names are the same, or
      (hdr_out.refnlp EQ hdr_out.refspnx) AND $         ; the cubes have same first dimensions
      (hdr_out.refnt EQ hdr_out.refspny) AND $          ; the cubes have same second dimenions
      (hdr_out.refspnt EQ hdr_out.refimnt)) THEN BEGIN  ; the cubes have same third dimensions
      CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'The reference image and spectral cubes must be '+$
        'different. Please check input (you seem to have provided the same file twice).', /ERROR, $
        /NO_ROUTINE, /NEWLINE
  		IF (N_ELEMENTS(STARTUPTLB) EQ 1) THEN WIDGET_CONTROL, startuptlb, /DESTROY
      io_failsafe_error = 1
  		RETURN
  	ENDIF
    ; Failsafe against providing incompatible REFIMCUBE and REFSPCUBE
  	IF ((hdr_out.refnx*hdr_out.refny NE hdr_out.refspnt) OR $
        (hdr_out.refnt*hdr_out.refnlp NE hdr_out.refimnt)) THEN BEGIN							
      CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'The reference image and spectral cubes have '+$
        'incompatible dimensions and seem to belong to different datasets. Please check whether '+$
        'the input is correct (you provided REFCUBE[0]='+STRTRIM(refcube[0],2)+' and REFCUBE[1]='+$
        STRTRIM(refcube[1],2)+').', /ERROR, /NO_ROUTINE, /NEWLINE
  	  IF (N_ELEMENTS(STARTUPTLB) EQ 1) THEN WIDGET_CONTROL, startuptlb, /DESTROY
      io_failsafe_error = 1
  		RETURN
  	ENDIF
    ; Check whether SINGLE_CUBE keyword has been set in combination with provided SPCUBE
		IF (N_ELEMENTS(INPUT_SINGLE_CUBE) GT 0) THEN BEGIN
      CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'Calling CRISPEX with SINGLE_CUBE with a 2-element '+$
        'array, while a reference SPCUBE is provided, is not allowed. SINGLE_CUBE keyword will '+$
        'be ignored.', /WARNING, /NO_ROUTINE
      io_failsafe_error = 2
		ENDIF
		hdr_out.single_cube[1] = 0
	ENDIF 
END

PRO CRISPEX_IO_FAILSAFES_MASK, maskcube, HDR=hdr, STARTUPTLB=startuptlb, $
                              IO_FAILSAFE_ERROR=io_failsafe_error
; Handles failsafes against wrongly supplied mask cube
  IF ((hdr.masknx EQ hdr.nx) AND (hdr.maskny EQ hdr.ny) AND $ ; Require same xy-dimensions as main
    ((hdr.masknt EQ hdr.mainnt) OR (hdr.masknt EQ 1))) THEN BEGIN ; Require same as main or 1 timestep
    io_failsafe_error = 0
	ENDIF ELSE BEGIN
	  IF ((hdr.masknx NE hdr.nx) OR (hdr.maskny NE hdr.ny)) THEN BEGIN
      CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'Dimensions of the mask cube (['+$
        STRTRIM(hdr.masknx,2)+','+STRTRIM(hdr.maskny,2)+','+STRTRIM(hdr.masknt,2)+']) are not '+$
        'compatible with those of the main image cube (['+STRTRIM(hdr.nx,2)+','+STRTRIM(hdr.ny,2)+$
        ','+STRTRIM(hdr.mainnt,2)+'])! Number of pixels in the x- and y-dimension must be equal to '+$
        'those of the main image cube.', /ERROR, /NO_ROUTINE, /NEWLINE
	  ENDIF ELSE IF ((hdr.masknt NE hdr.mainnt) AND (hdr.masknt NE 1)) THEN BEGIN
      CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'Dimensions of the mask cube (['+$
        STRTRIM(hdr.masknx,2)+','+STRTRIM(hdr.maskny,2)+','+STRTRIM(hdr.masknt,2)+']) are not '+$
        'compatible with those of the main image cube (['+STRTRIM(hdr.nx,2)+','+STRTRIM(hdr.ny,2)+$
        ','+STRTRIM(hdr.mainnt,2)+'])! Number of timesteps must be either equal to that of the main '+$
        'image cube ('+STRTRIM(hdr.mainnt,2)+') or to 1.', /ERROR, /NO_ROUTINE, /NEWLINE
	  ENDIF
    IF (N_ELEMENTS(STARTUPTLB) EQ 1) THEN WIDGET_CONTROL, startuptlb, /DESTROY
    io_failsafe_error = 1
		RETURN
  ENDELSE
END

PRO CRISPEX_IO_FAILSAFES_MNSPEC, mnspec, hdr, STARTUPTLB=startuptlb, $
                                 IO_FAILSAFE_ERROR=io_failsafe_error
; Handles failsafes against wrongly supplied MNSPEC values                                 
  extra_text = ''
  cumulative_error = (mnspec[0] LT 0)                               ; Check whether lower value >= 0
  cumulative_error += (mnspec[(N_ELEMENTS(MNSPEC) EQ 2)] GE hdr.mainnt) ; Check whether upper value < nt
  IF (N_ELEMENTS(MNSPEC) EQ 2) THEN BEGIN
    feedback_text = 's (['+STRTRIM(mnspec[0],2)+','+STRTRIM(mnspec[1],2)+'])'
    IF (mnspec[0] GT mnspec[1]) THEN $                     ; Check whether upper value > lower value
      extra_text = ' and be ordered from lower to higher value'
  ENDIF ELSE feedback_text = ' ('+STRTRIM(mnspec[0],2)+')' 
  io_failsafe_error = (TOTAL(cumulative_error) NE 0)
  IF io_failsafe_error THEN BEGIN
    CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'MNSPEC value'+feedback_text+' must fall within '+$
      'allowed range [0,'+STRTRIM(LONG(hdr.mainnt-1),2)+']'+extra_text+'!',/ERROR,/NO_ROUTINE,/NEWLINE
	  IF (N_ELEMENTS(STARTUPTLB) EQ 1) THEN WIDGET_CONTROL, startuptlb, /DESTROY
	  RETURN
  ENDIF
END

PRO CRISPEX_IO_FAILSAFES_LINE_CENTER, line_center, hdr, NFILES=nfiles, STARTUPTLB=startuptlb, $
                                      SPECTFILE_SET=spectfile_set, $
                                      REFSPECTFILE_SET=refspectfile_set, $
                                      IO_FAILSAFE_ERROR=io_failsafe_error
; Handles failsafes against wrongly supplied LINE_CENTER values or formatting
  ndims = SIZE(LINE_CENTER,/N_DIMENSIONS) > 1
  nelem = N_ELEMENTS(LINE_CENTER)
  lcase = nelem / ndims
  nlp_select = [hdr.nlp,hdr.refnlp] & feedback_text = ['Main','Reference']
  io_failsafe_error = 0
  ; Check whether conflicting with SPECTFILE
  IF ((spectfile_set AND (ndims GE 1)) OR (refspectfile_set AND (ndims EQ 2))) THEN BEGIN
    idx = (refspectfile_set AND (ndims EQ 2))
    CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'Detailed '+STRLOWCASE(feedback_text[idx])+$
      ' information may not be specified in both SPECTFILE and LINE_CENTER! Settings from '+$
      'LINE_CENTER will be ignored.',/WARNING,/NO_ROUTINE
    io_failsafe_error = 2
		RETURN
  ENDIF
  ; Check proper setting of LINE_CENTER
  IF (((lcase EQ 1) OR (lcase EQ 3)) AND (ndims LE nfiles)) THEN BEGIN
  ; lcase of 1: LINE_CENTER = lc or [[lc],[lc]]
  ; lcase of 3: LINE_CENTER = [lc,cwav,dwav] or [[lc,cwav,dwav],[lc,cwav,dwav]]
    FOR d=0,ndims-1 DO BEGIN
      IF ((line_center[0,d] GE nlp_select[d]) OR (line_center[0,d] LT 0)) THEN BEGIN
        CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, feedback_text[d]+' linecentre index value '+$
          STRTRIM(line_center[0,d],2)+' falls outside of allowed range [0,'+$
          STRTRIM(nlp_select[d]-1,2)+']!',/ERROR,/NO_ROUTINE,NEWLINE=(io_failsafe_error EQ 2)
        IF (N_ELEMENTS(STARTUPTLB) EQ 1) THEN WIDGET_CONTROL, startuptlb, /DESTROY
        io_failsafe_error = 1
        RETURN
      ENDIF
    ENDFOR
  ENDIF ELSE IF (lcase NE 2) THEN BEGIN
  ; lcase of 2: LINE_CENTER = [cwav,dwav] or [[cwav,dwav],[cwav,dwav]]
    CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'LINE_CENTER keyword contains too many elements for '+$
      'the number of cubes provided!', /ERROR, /NO_ROUTINE, NEWLINE=(io_failsafe_error EQ 2)
    IF (N_ELEMENTS(STARTUPTLB) EQ 1) THEN WIDGET_CONTROL, startuptlb, /DESTROY
    io_failsafe_error = 1
    RETURN
  ENDIF
END

PRO CRISPEX_IO_MULTICHANNEL, CUBE_COMPATIBILITY=cube_compatibility, CHANNELS_LABELS=channels_labels
; Handles setting of parameters in case of multichannel input
  IF KEYWORD_SET(CUBE_COMPATIBILITY) THEN BEGIN
  ENDIF
END

PRO CRISPEX_IO_FEEDBACK, verbosity, hdr, IMCUBE=imcube, SPCUBE=spcube, REFIMCUBE=refimcube, $
                         REFSPCUBE=refspcube, MASKCUBE=maskcube, SJICUBE=sjicube
	multichannel = (hdr.ns GE 2)
	IF (TOTAL(verbosity[0:1]) GE 1) THEN BEGIN
    IF (N_ELEMENTS(IMCUBE) EQ 1) THEN BEGIN
      IF ((SIZE(IMCUBE,/TYPE) NE 0) AND (STRCOMPRESS(IMCUBE) NE '')) THEN BEGIN
		    IF multichannel THEN $
          CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'Read Stokes image cube: '+imcube+$
            '. Dimensions: (nx,ny,nt*nlp*ns) = ('+STRTRIM(hdr.nx,2)+','+STRTRIM(hdr.ny,2)+','+$
            STRTRIM(hdr.imnt,2)+').' $
        ELSE $
          CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'Read image cube: '+imcube+$
            '. Dimensions: (nx,ny,nt*nlp*ns) = ('+STRTRIM(hdr.nx,2)+','+STRTRIM(hdr.ny,2)+','+$
            STRTRIM(hdr.imnt,2)+').'
		    IF (verbosity[1] EQ 1) THEN $
          CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'Main cube(s) dimensions: (nx,ny,nt,nlp,ns) = ('+$
            STRTRIM(hdr.nx,2)+','+STRTRIM(hdr.ny,2)+','+STRTRIM(hdr.mainnt,2)+','+STRTRIM(hdr.nlp,2)+$
            ','+STRTRIM(hdr.ns,2)+')'
	    ENDIF ELSE CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'No main image cube supplied.'
    ENDIF ELSE IF (N_ELEMENTS(SPCUBE) EQ 1) THEN BEGIN
      IF ((SIZE(SPCUBE,/TYPE) NE 0) AND (STRCOMPRESS(SPCUBE) NE '')) THEN $
        CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'Read main spectral cube: '+spcube+$
              '. Dimensions: (nlp,nt,nx*ny*ns) = ('+STRTRIM(hdr.nlp,2)+','+STRTRIM(hdr.mainnt,2)+$
              ','+STRTRIM(hdr.spnt,2)+').' $
      ELSE CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'No main spectral cube supplied.'
    ENDIF ELSE IF (N_ELEMENTS(REFIMCUBE) EQ 1) THEN BEGIN
      IF ((SIZE(REFIMCUBE,/TYPE) NE 0) AND (STRCOMPRESS(REFIMCUBE) NE '')) THEN BEGIN
        CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'Read reference image cube: '+refimcube+$
              '. Dimensions: (nx,ny,nt*nlp*ns) = ('+STRTRIM(hdr.refnx,2)+','+STRTRIM(hdr.refny,2)+$
              ','+STRTRIM(hdr.refnt*hdr.refnlp*hdr.refns,2)+').'  
			  IF (verbosity[1] EQ 1) THEN $
          CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'Reference cubes dimensions: (nx,ny,nt,nlp,ns) = ('+$
                STRTRIM(hdr.refnx,2)+','+STRTRIM(hdr.refny,2)+','+STRTRIM(hdr.refnt,2)+','+$
                STRTRIM(hdr.refnlp,2)+','+STRTRIM(hdr.refns,2)+')'
      ENDIF ELSE CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'No reference image cube supplied.'
    ENDIF ELSE IF (N_ELEMENTS(REFSPCUBE) EQ 1) THEN BEGIN
      IF ((SIZE(REFSPCUBE,/TYPE) NE 0) AND (STRCOMPRESS(REFSPCUBE) NE '')) THEN $
        CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'Read reference spectral cube: '+refspcube+$
              '. Dimensions: (nlp,nt,nx*ny) = ('+STRTRIM(hdr.refnlp,2)+','+STRTRIM(hdr.refnt,2)+$
              ','+STRTRIM(hdr.refspnt,2)+').' $
      ELSE CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'No reference spectral cube supplied.'
    ENDIF ELSE IF (N_ELEMENTS(MASKCUBE) EQ 1) THEN BEGIN
      IF ((SIZE(MASKCUBE,/TYPE) NE 0) AND (STRCOMPRESS(MASKCUBE) NE '')) THEN $
        CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'Read mask cube: '+maskcube+$
          '. Dimensions: (nx,ny,nt) = ('+STRTRIM(hdr.masknx,2)+','+STRTRIM(hdr.maskny,2)+','+$
          STRTRIM(hdr.masknt,2)+').' $
      ELSE CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'No mask cube supplied.'
    ENDIF ELSE IF (N_ELEMENTS(SJICUBE) EQ 1) THEN BEGIN
      IF ((SIZE(SJICUBE,/TYPE) NE 0) AND (STRCOMPRESS(SJICUBE) NE '')) THEN $
        CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'Read slit-jaw image cube: '+sjicube+$
          '. Dimensions: (nx,ny,nt) = ('+STRTRIM(hdr.sjinx,2)+','+STRTRIM(hdr.sjiny,2)+','+$
          STRTRIM(hdr.sjint,2)+').' $
      ELSE CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'No slit-jaw image cube supplied.'
    ENDIF
  ENDIF
END

PRO CRISPEX_IO_OPEN_MAINCUBE, IMCUBE=imcube, SPCUBE=spcube, SINGLE_CUBE=single_cube, $
                              HDR_IN=hdr_in, HDR_OUT=hdr_out, STARTUPTLB=startuptlb, $
                              IO_FAILSAFE_MAIN_ERROR=io_failsafe_main_error
  hdr_out = hdr_in
  ipath = hdr_out.ipath
  instance_label = hdr_out.instance_label
  hdr_out.imfilename = imcube
  ; Check existence of file, else throw error message
  IF (FILE_TEST(hdr_out.imfilename) EQ 0) THEN BEGIN
    CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'The main image file "'+hdr_out.imfilename+$
      '" does not exist. Please check your input.', /ERROR,/NO_ROUTINE
    io_failsafe_main_error = 1
    RETURN
  ENDIF
  ; Determine cube compatibility mode for inputfiles (0: running FITS cubes, 1: running old cubes)
	imext = STRMID(hdr_out.imfilename,STRPOS(hdr_out.imfilename,'.',/REVERSE_SEARCH)+1,$
                  STRLEN(hdr_out.imfilename))  ; Process extension
	hdr_out.imcube_compatibility = ABS(STRMATCH(imext,'fits',/FOLD_CASE)-1)             ; Determine comp mode
  IF (N_ELEMENTS(SPCUBE) EQ 1) THEN BEGIN
    hdr_out.spfilename = spcube
    ; Check existence of file, else throw error message
    IF (FILE_TEST(hdr_out.spfilename) EQ 0) THEN BEGIN
      CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'The main spectral file "'+hdr_out.spfilename+$
        '" does not exist. Please check your input.', /ERROR,/NO_ROUTINE
      io_failsafe_main_error = 1
      RETURN
    ENDIF
    spext = STRMID(hdr_out.spfilename,STRPOS(hdr_out.spfilename,'.',/REVERSE_SEARCH)+1,$
                    STRLEN(hdr_out.spfilename))
    hdr_out.spcube_compatibility = ABS(STRMATCH(spext,'fits',/FOLD_CASE)-1)
    hdr_out.spfile = 1
;  ENDIF 
;  IF N_ELEMENTS(SPCUBE) EQ 1 THEN BEGIN
    CRISPEX_IO_PARSE_HEADER, hdr_out.spfilename, HDR_IN=hdr_out, HDR_OUT=hdr_out, $
                            CUBE_COMPATIBILITY=hdr_out.spcube_compatibility, EXTEN_NO=0, /SPCUBE
	ENDIF ELSE hdr_out.onecube = 1                       ; onecube switch if no SPCUBE has been provided
  ; If single_cube value has been set from single FITS cube, use that
  IF ((hdr_out.imcube_compatibility EQ 0) AND (N_ELEMENTS(SPCUBE) NE 1)) THEN $
    main_single_cube = hdr_out.single_cube[0] $
  ELSE IF (N_ELEMENTS(SINGLE_CUBE) GE 1) THEN $
    main_single_cube = single_cube[0]
  CRISPEX_IO_PARSE_HEADER, hdr_out.imfilename, HDR_IN=hdr_out, HDR_OUT=hdr_out, $
                            CUBE_COMPATIBILITY=hdr_out.imcube_compatibility, EXTEN_NO=0, /IMCUBE, $
                            SINGLE_CUBE=main_single_cube
	hdr_out.multichannel = (hdr_out.ns GE 2)
  CRISPEX_IO_FAILSAFES_MAIN, hdr_out.imfilename, hdr_out.spfilename, main_single_cube, $
                             HDR_IN=hdr_out, HDR_OUT=hdr_out, $
                             STARTUPTLB=startuptlb, $
                             IO_FAILSAFE_ERROR=io_failsafe_main_error
  IF (io_failsafe_main_error EQ 1) THEN RETURN
  ; Define axes titles based on IMCUBE and SPCUBE headers
  IF (STRCOMPRESS(hdr_out.bunit,/REMOVE_ALL) NE '') THEN $
    ytitle_unit = ' ['+hdr_out.bunit+']' ELSE ytitle_unit = ''
  IF (STRCOMPRESS(hdr_out.lpunit,/REMOVE_ALL) NE '') THEN $
    xtitle_unit = ' ['+hdr_out.lpunit+']' ELSE xtitle_unit = ''
  IF (STRCOMPRESS(hdr_out.tunit,/REMOVE_ALL) NE '') THEN $
    spytitle_unit = ' ['+hdr_out.tunit+']' ELSE spytitle_unit = ''
  hdr_out.ytitle[0] = hdr_out.blabel+ytitle_unit
  hdr_out.xtitle[0] = hdr_out.lplabel+xtitle_unit
  hdr_out.spytitle = hdr_out.tlabel+spytitle_unit
  ; Handle Stokes 
  IF hdr_out.multichannel THEN BEGIN
    stokes_labels = STRSPLIT(STRMID(hdr_out.imstokes,1,STRLEN(hdr_out.imstokes)-2),',',/EXTRACT)
		IF (N_ELEMENTS(stokes_labels) NE hdr_out.imns) THEN BEGIN
			PRINT,'ERROR: The number of Stokes components ('+STRTRIM(hdr_out.imns,2)+') does not '+$
            'correspond to the number of Stokes labels ('+STRTRIM(N_ELEMENTS(stokes_labels),2)+').'
			PRINT,'       Please check whether the Stokes cube production has proceded correctly.'
			WIDGET_CONTROL, startuptlb, /DESTROY
      io_failsafe_main_error = 1
			RETURN
		ENDIF ELSE BEGIN
			stokes_select_sp = INTARR(hdr_out.ns)
      wherestokesi = WHERE(stokes_labels EQ 'I', icount)
      wherestokesq = WHERE(stokes_labels EQ 'Q', qcount)
      wherestokesu = WHERE(stokes_labels EQ 'U', ucount)
      wherestokesv = WHERE(stokes_labels EQ 'V', vcount)
      IF (icount GT 0) THEN BEGIN
				hdr_out.stokes_enabled[0] = 1 
				stokes_select_sp[wherestokesi] = 1
			ENDIF
      IF (qcount GT 0) THEN BEGIN
				hdr_out.stokes_enabled[1] = 1 
				stokes_select_sp[wherestokesq] = 1
			ENDIF 
      IF (ucount GT 0) THEN BEGIN
				hdr_out.stokes_enabled[2] = 1 
				stokes_select_sp[wherestokesu] = 1
			ENDIF 
      IF (vcount GT 0) THEN BEGIN
				hdr_out.stokes_enabled[3] = 1 
				stokes_select_sp[wherestokesv] = 1
			ENDIF
		ENDELSE
	ENDIF ELSE BEGIN
    stokes_labels = ['I']
    stokes_select_sp = 1
  ENDELSE
	hdr_out.scalestokes_max = (TOTAL(hdr_out.stokes_enabled[1:3]) GE 1)
  hdr_out = CREATE_STRUCT(hdr_out, 'stokes_labels', stokes_labels, 'stokes_select_sp', $
                          stokes_select_sp)
	IF (hdr_out.verbosity[1] EQ 1) THEN $
    CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'Stokes parameters: '+STRJOIN(hdr_out.stokes_labels,' ')
  ; Handle diagnostics
  IF (WHERE(TAG_NAMES(hdr_out) EQ 'DIAG_START') EQ -1) THEN BEGIN
    wstart = 0
    wwidth = hdr_out.nlp
    hdr_out = CREATE_STRUCT(hdr_out, 'diag_start', wstart, 'diag_width', wwidth)
  ENDIF
  sel_diagnostics = INDGEN(1)
  sellines_diagnostics = INDGEN(1)
  selcol_diagnostics = INDGEN(1)
  sellp_diagnostics = LINDGEN(1)
  tsel_main = LINDGEN(hdr_out.mainnt)
  hdr_out = CREATE_STRUCT(hdr_out, 'sel_diagnostics', sel_diagnostics, $
    'sellines_diagnostics', sellines_diagnostics, $
    'selcol_diagnostics', selcol_diagnostics, $
    'sellp_diagnostics', sellp_diagnostics, $
    'tsel_main', tsel_main)
  CRISPEX_IO_OPEN_MAINCUBE_READ, HDR_IN=hdr_out, HDR_OUT=hdr_out
END

PRO CRISPEX_IO_OPEN_MAINCUBE_READ, HDR_IN=hdr_in, HDR_OUT=hdr_out
  hdr_out = hdr_in
  ; Actual read-in of the data cubes  
  ; Read in main image cube 
	OPENR, lunim, hdr_out.imfilename, /get_lun, $
         SWAP_ENDIAN = ((hdr_out.imtype GT 1) AND (hdr_out.endian NE hdr_out.imendian))									
	imagefile = ASSOC(lunim,MAKE_ARRAY(hdr_out.nx,hdr_out.ny, $
                TYPE=hdr_out.imtype,/NOZERO),hdr_out.imoffset)
  ; Re-read in of the image cube for slices
	scanfile  = ASSOC(lunim,MAKE_ARRAY(hdr_out.nx,hdr_out.ny,hdr_out.nlp*hdr_out.ns, $
                      TYPE=hdr_out.imtype,/NOZERO),hdr_out.imoffset)			
	hdr_out.imdata	= PTR_NEW(imagefile, /NO_COPY)
	hdr_out.scan	= PTR_NEW(scanfile, /NO_COPY)
  hdr_out.lunim = lunim
  hdr_out.dx_fixed = ABS(KEYWORD_SET(hdr_out.imcube_compatibility)-1)
  CRISPEX_IO_FEEDBACK, hdr_out.verbosity, hdr_out, IMCUBE=hdr_out.imfilename
  ; Read in main spectral cube 
  IF hdr_out.spfile THEN BEGIN
    OPENR, lunsp, hdr_out.spfilename, /get_lun, $
           SWAP_ENDIAN = ((hdr_out.sptype GT 1) AND (hdr_out.endian NE hdr_out.spendian))
    spectra = ASSOC(lunsp,MAKE_ARRAY(hdr_out.nlp,hdr_out.mainnt,$
                TYPE=hdr_out.sptype,/NOZERO),hdr_out.spoffset)
    hdr_out.lunsp = lunsp
	  hdr_out.spdata = PTR_NEW(spectra, /NO_COPY) 
  ENDIF
  CRISPEX_IO_FEEDBACK, hdr_out.verbosity, hdr_out, SPCUBE=hdr_out.spfilename
END

PRO CRISPEX_IO_OPEN_REFCUBE, REFCUBE=refcube, HDR_IN=hdr_in, HDR_OUT=hdr_out, $
                              SINGLE_CUBE=single_cube, $
                              CUBE_COMPATIBILITY=cube_compatibility, $
                              IO_FAILSAFE_REF_ERROR=io_failsafe_ref_error, $
                              IO_FAILSAFE_MAIN_REF_ERROR=io_failsafe_main_ref_error
  io_failsafe_ref_error = 0
  io_failsafe_main_ref_error = 0
;  IF (N_ELEMENTS(event) EQ 1) THEN BEGIN
;    WIDGET_CONTROL, event.TOP, GET_UVALUE = info
;    ipath = (*(*info).paths).ipath
;    instance_label = (*(*info).sesparams).instance_label
;    hdr_out = (*(*info).ioparams).hdr
;  ENDIF ELSE BEGIN
    hdr_out = hdr_in
    ipath = hdr_out.ipath
    instance_label = hdr_out.instance_label
;  ENDELSE
;  IF ((N_ELEMENTS(event) EQ 1) AND (N_ELEMENTS(REFCUBE) LT 1)) THEN BEGIN
;    refcube = STRARR(2)
;	  refcube[0] = DIALOG_PICKFILE(/READ,/MUST_EXIST, PATH = ipath, TITLE='CRISPEX'+instance_label+$
;                                ': Select reference image cube', FILTER=['*cube','*fits'])
;	  refcube[1] = DIALOG_PICKFILE(/READ,/MUST_EXIST, PATH = ipath, TITLE='CRISPEX'+instance_label+$
;                                ': Select reference spectral cube', FILTER=['*cube','*fits'])
;  ENDIF
	IF ((N_ELEMENTS(REFCUBE) GE 1) AND (SIZE(REFCUBE,/TYPE) EQ 7)) THEN BEGIN					
    hdr_out.refimfilename = refcube[0]
    ; Check existence of file, else throw error message
    IF (FILE_TEST(hdr_out.refimfilename) EQ 0) THEN BEGIN
      CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'The reference image file "'+hdr_out.refimfilename+$
        '" does not exist. Please check your input.', /ERROR,/NO_ROUTINE
      io_failsafe_ref_error = 1
      RETURN
    ENDIF
  	refimext = STRMID(hdr_out.refimfilename,STRPOS(hdr_out.refimfilename,'.',/REVERSE_SEARCH)+1,$
                      STRLEN(hdr_out.refimfilename))
  	hdr_out.refimcube_compatibility = ABS(STRMATCH(refimext,'fits',/FOLD_CASE)-1)
    ; If single_cube value has been set from single FITS cube, use that
    IF ((hdr_out.refimcube_compatibility EQ 0) AND (N_ELEMENTS(REFCUBE) NE 2)) THEN $
      ref_single_cube = hdr_out.single_cube[1] $
    ELSE IF (N_ELEMENTS(SINGLE_CUBE) EQ 2) THEN $
      ref_single_cube = single_cube[1]
  ; Handle reference image cube first, only after that check for reference spectral cube
    CRISPEX_IO_PARSE_HEADER, hdr_out.refimfilename, HDR_IN=hdr_out, HDR_OUT=hdr_out, $
                           CUBE_COMPATIBILITY=hdr_out.refimcube_compatibility, EXTEN_NO=0, /REFIMCUBE
    IF (N_ELEMENTS(REFCUBE) EQ 2) THEN BEGIN
      hdr_out.refspfilename = refcube[1]
      ; Check existence of file, else throw error message
      IF (FILE_TEST(hdr_out.refspfilename) EQ 0) THEN BEGIN
        CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'The reference spectral file "'+hdr_out.refspfilename+$
          '" does not exist. Please check your input.', /ERROR,/NO_ROUTINE
        io_failsafe_ref_error = 1
        RETURN
      ENDIF
     	refspext = STRMID(hdr_out.refspfilename,STRPOS(hdr_out.refspfilename,'.',/REVERSE_SEARCH)+1,$
                        STRLEN(hdr_out.refspfilename))
    	hdr_out.refspcube_compatibility = ABS(STRMATCH(refspext,'fits',/FOLD_CASE)-1)
      CRISPEX_IO_PARSE_HEADER, hdr_out.refspfilename, HDR_IN=hdr_out, HDR_OUT=hdr_out, $
                             CUBE_COMPATIBILITY=hdr_out.refspcube_compatibility, EXTEN_NO=0, /REFSPCUBE
    ENDIF 
    CRISPEX_IO_FAILSAFES_REF, refcube, ref_single_cube, HDR_IN=hdr_out, HDR_OUT=hdr_out, $
                            STARTUPTLB=startuptlb, IO_FAILSAFE_ERROR=io_failsafe_ref_error
    IF (io_failsafe_ref_error EQ 1) THEN RETURN
    CRISPEX_IO_FAILSAFES_MAIN_REF, HDR_IN=hdr_out, HDR_OUT=hdr_out, $
                            STARTUPTLB=startuptlb, $
                            IO_FAILSAFE_ERROR=io_failsafe_main_ref_error
    IF (io_failsafe_main_ref_error EQ 1) THEN RETURN
    ; Add reference axes titles based on REFIMCUBE and REFSPCUBE headers
    IF (STRCOMPRESS(hdr_out.refbunit,/REMOVE_ALL) NE '') THEN $
      refytitle_unit = ' ['+hdr_out.refbunit+']' ELSE refytitle_unit = ''
    IF (STRCOMPRESS(hdr_out.reflpunit,/REMOVE_ALL) NE '') THEN $
      refxtitle_unit = ' ['+hdr_out.reflpunit+']' ELSE refxtitle_unit = ''
    hdr_out.ytitle[1] = hdr_out.refblabel+refytitle_unit
    hdr_out.xtitle[1] = hdr_out.reflplabel+refxtitle_unit
  ENDIF
;  IF (N_ELEMENTS(event) EQ 1) THEN BEGIN
;    (*(*info).ioparams).hdr = hdr_out
;    CRISPEX_IO_OPEN_REFCUBE_READ, event, REFCUBE=refcube
;    CRISPEX_IO_HANDLE_HDR, event, hdr_out, /REFERENCE
;  ENDIF ELSE 
  IF (hdr_out.refnt GT 1) THEN BEGIN
    tsel_ref = LONARR(hdr_out.mainnt)
    FOR tt=0,hdr_out.mainnt-1 DO BEGIN
      tdiff = ABS(hdr_out.tarr_ref - hdr_out.tarr_main[tt])
      tsel_ref[tt] = (WHERE(tdiff EQ MIN(tdiff, /NAN)))[0]
    ENDFOR
    hdr_out = CREATE_STRUCT(hdr_out, 'tsel_ref', tsel_ref)
  ENDIF ELSE $
    hdr_out = CREATE_STRUCT(hdr_out, 'tsel_ref', 0)
  CRISPEX_IO_OPEN_REFCUBE_READ, REFCUBE=refcube, HDR_IN=hdr_out, HDR_OUT=hdr_out
END

PRO CRISPEX_IO_OPEN_REFCUBE_READ, event, REFCUBE=refcube, HDR_IN=hdr_in, HDR_OUT=hdr_out
  IF (N_ELEMENTS(event) EQ 1) THEN BEGIN
    WIDGET_CONTROL, event.TOP, GET_UVALUE = info
    hdr_out = (*(*info).ioparams).hdr
  ENDIF ELSE hdr_out = hdr_in
  ; Read in reference image cube
	IF ((N_ELEMENTS(REFCUBE) GE 1) AND (SIZE(REFCUBE,/TYPE) EQ 7)) THEN BEGIN	; REFIMCUBE as filename
		OPENR, lunrefim, refcube[0], /get_lun, $
           SWAP_ENDIAN = ((hdr_out.refimtype GT 1) AND (hdr_out.endian NE hdr_out.refimendian))
    referencefile = ASSOC(lunrefim,MAKE_ARRAY(hdr_out.refnx,hdr_out.refny,$
                      TYPE=hdr_out.refimtype,/NOZERO),hdr_out.refimoffset)
		hdr_out.showref = 1
    IF ((hdr_out.refnlp GT 1) AND (N_ELEMENTS(REFCUBE) NE 2)) THEN BEGIN
      refscanfile = ASSOC(lunrefim,MAKE_ARRAY(hdr_out.refnx,hdr_out.refny,$
                      hdr_out.refnlp*hdr_out.refns, TYPE=hdr_out.refimtype,$
                      /NOZERO),hdr_out.refimoffset)
    ENDIF 
    hdr_out.lunrefim = lunrefim
    CRISPEX_IO_FEEDBACK, hdr_out.verbosity, hdr_out, REFIMCUBE=hdr_out.refimfilename
    ; Read in reference spectral cube if so provided
    IF (N_ELEMENTS(REFCUBE) EQ 2) THEN BEGIN                                ; REFSPCUBE as filename
			OPENR, lunrefsp, refcube[1], /get_lun, $
             SWAP_ENDIAN = ((hdr_out.refsptype GT 1) AND (hdr_out.endian NE hdr_out.refspendian))						
      referencespectra = ASSOC(lunrefsp,MAKE_ARRAY(hdr_out.refnlp,hdr_out.refnt, $
                            TYPE=hdr_out.refsptype,/NOZERO),hdr_out.refspoffset)
			hdr_out.refspfile = 1	
      hdr_out.lunrefsp = lunrefsp
      CRISPEX_IO_FEEDBACK, hdr_out.verbosity, hdr_out, REFSPCUBE=hdr_out.refspfilename
    ENDIF 
	ENDIF ELSE BEGIN
    IF (N_ELEMENTS(REFCUBE) GT 1) THEN BEGIN								                ; REFCUBE as image array
		  hdr_out.refnx = LONG((SIZE(refcube))[1])
		  hdr_out.refny = LONG((SIZE(refcube))[2])
		  IF (SIZE(REFCUBE,/N_DIMENSIONS) EQ 3) THEN $
        hdr_out.refnt = LONG((SIZE(refcube))[3]) $
      ELSE $
        hdr_out.refnt = 1L
		  IF (hdr_out.refnx EQ hdr_out.nx) AND (hdr_out.refny EQ hdr_out.ny) THEN BEGIN
			  referencefile = refcube
			  hdr_out.showref = 1
			  hdr_out.refnlp = 1
			  hdr_out.refns = 1
		  ENDIF ELSE BEGIN
        CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'Dimensions of the reference cube (['+$
          STRTRIM(hdr_out.refnx,2)+','+STRTRIM(hdr_out.refny,2)+','+STRTRIM(hdr_out.refnt,2)+']) are not '+$
          'compatible with those of the main image cube (['+STRTRIM(hdr_out.nx,2)+','+$
          STRTRIM(hdr_out.ny,2)+','+STRTRIM(hdr_out.mainnt,2)+'])! Number of pixels in the x- and '+$
          'y-direction must be the same for both.', /ERROR, /NO_ROUTINE, /NEWLINE
			WIDGET_CONTROL, startuptlb, /DESTROY
			RETURN
		  ENDELSE
	  ENDIF 
	ENDELSE
  ; Create pointers to data
	IF (hdr_out.showref EQ 1) THEN BEGIN
		hdr_out.refdata	= PTR_NEW(referencefile, /NO_COPY)
		hdr_out.refslice= PTR_NEW(BYTARR(hdr_out.nx,hdr_out.ny))
		IF ((hdr_out.refnlp GT 1) AND (hdr_out.refspfile EQ 0)) THEN BEGIN
			hdr_out.refscan = PTR_NEW(refscanfile, /NO_COPY)
      hdr_out.refsspscan = PTR_NEW(MAKE_ARRAY(hdr_out.nx,hdr_out.ny,hdr_out.refnlp*hdr_out.refns, $
                            TYPE=hdr_out.refimtype))
		ENDIF 
	  IF (hdr_out.refspfile EQ 1) THEN hdr_out.refspdata = PTR_NEW(referencespectra, /NO_COPY) 
	ENDIF 
END

PRO CRISPEX_IO_OPEN_SJICUBE, SJICUBE=sjicube, HDR_IN=hdr_in, HDR_OUT=hdr_out, $
                              STARTUPTLB=startuptlb, $
                              IO_FAILSAFE_SJI_ERROR=io_failsafe_sji_error
  io_failsafe_sji_error = 0
  io_failsafe_main_ref_error = 0
  hdr_out = hdr_in
	IF ((N_ELEMENTS(SJICUBE) GE 1) AND (SIZE(SJICUBE,/TYPE) EQ 7)) THEN BEGIN					
    hdr_out.sjifilename = sjicube[0]
    ; Check existence of file, else throw error message
    IF (FILE_TEST(hdr_out.sjifilename) EQ 0) THEN BEGIN
      CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'The slit-jaw image file "'+hdr_out.sjifilename+$
        '" does not exist. Please check your input.', /ERROR,/NO_ROUTINE
      io_failsafe_sji_error = 1
      RETURN
    ENDIF
  	sjiext = STRMID(hdr_out.sjifilename,STRPOS(hdr_out.sjifilename,'.',/REVERSE_SEARCH)+1,$
                      STRLEN(hdr_out.sjifilename))
  	sjicube_compatibility = ABS(STRMATCH(sjiext,'fits',/FOLD_CASE)-1)
    IF sjicube_compatibility THEN BEGIN
      CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'The slit-jaw image cube must be in FITS format.', $
        /ERROR, /NO_ROUTINE, /NEWLINE
  		IF (N_ELEMENTS(STARTUPTLB) EQ 1) THEN WIDGET_CONTROL, startuptlb, /DESTROY
      io_failsafe_sji_error = 1
    ENDIF ELSE $
      ; Parse the SJICUBE header
      CRISPEX_IO_PARSE_HEADER, hdr_out.sjifilename, HDR_IN=hdr_out, HDR_OUT=hdr_out, $
                             CUBE_COMPATIBILITY=sjicube_compatibility, EXTEN_NO=0, /SJICUBE
    IF (hdr_out.sjint GT 1) THEN BEGIN
      tsel_sji = LONARR(hdr_out.mainnt)
      FOR tt=0,hdr_out.mainnt-1 DO BEGIN
        tdiff = ABS(hdr_out.tarr_sji - hdr_out.tarr_main[tt])
        tsel_sji[tt] = (WHERE(tdiff EQ MIN(tdiff, /NAN)))[0]
      ENDFOR
      hdr_out = CREATE_STRUCT(hdr_out, 'tsel_sji', tsel_sji)
    ENDIF ELSE $
      hdr_out = CREATE_STRUCT(hdr_out, 'tsel_sji', 0)
    CRISPEX_IO_OPEN_SJICUBE_READ, HDR_IN=hdr_out, HDR_OUT=hdr_out
  ENDIF
END

PRO CRISPEX_IO_OPEN_SJICUBE_READ, HDR_IN=hdr_in, HDR_OUT=hdr_out
  hdr_out = hdr_in
		OPENR, lunsji, hdr_out.sjifilename, /get_lun, $
           SWAP_ENDIAN = ((hdr_out.sjitype GT 1) AND (hdr_out.endian NE hdr_out.sjiendian))
    sji = ASSOC(lunsji,MAKE_ARRAY(hdr_out.sjinx,hdr_out.sjiny, $
            TYPE=hdr_out.sjitype,/NOZERO),hdr_out.sjioffset)
		hdr_out.sjifile = 1	
	  hdr_out.sjidata = PTR_NEW(sji, /NO_COPY)
    hdr_out.lunsji = lunsji
	  hdr_out.sjislice	= PTR_NEW(BYTARR(hdr_out.sjinx,hdr_out.sjiny))
    CRISPEX_IO_FEEDBACK, hdr_out.verbosity, hdr_out, SJICUBE=hdr_out.sjifilename
END

PRO CRISPEX_IO_OPEN_MASKCUBE, MASKCUBE=maskcube, HDR_IN=hdr_in, HDR_OUT=hdr_out, $
                              STARTUPTLB=startuptlb, IO_FAILSAFE_MASK_ERROR=io_failsafe_mask_error
  io_failsafe_mask_error = 0
  hdr_out = hdr_in
  IF (N_ELEMENTS(MASKCUBE) GE 1) THEN BEGIN
    hdr_out.maskfilename = maskcube[0]
    ; Check existence of file, else throw error message
    IF (FILE_TEST(hdr_out.maskfilename) EQ 0) THEN BEGIN
      CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'The mask file "'+hdr_out.maskfilename+$
        '" does not exist. Please check your input.', /ERROR,/NO_ROUTINE
      io_failsafe_mask_error = 1
      RETURN
    ENDIF
  	maskext = STRMID(hdr_out.maskfilename,STRPOS(hdr_out.maskfilename,'.',/REVERSE_SEARCH)+1,$
                      STRLEN(hdr_out.maskfilename))
  	hdr_out.maskcube_compatibility = ABS(STRMATCH(maskext,'fits',/FOLD_CASE)-1)
    CRISPEX_IO_PARSE_HEADER, hdr_out.maskfilename, HDR_IN=hdr_out, HDR_OUT=hdr_out, $
                            CUBE_COMPATIBILITY=hdr_out.maskcube_compatibility, EXTEN_NO=0, /MASKCUBE
    CRISPEX_IO_FAILSAFES_MASK, HDR=hdr_out, STARTUPTLB=startuptlb, $
                                IO_FAILSAFE_ERROR=io_failsafe_mask_error
    IF (io_failsafe_mask_error EQ 1) THEN RETURN
    CRISPEX_IO_OPEN_MASKCUBE_READ, HDR_IN=hdr_out, HDR_OUT=hdr_out
  ENDIF 
END

PRO CRISPEX_IO_OPEN_MASKCUBE_READ, HDR_IN=hdr_in, HDR_OUT=hdr_out
  hdr_out = hdr_in
		OPENR, lunmask, hdr_out.maskfilename, /get_lun, $
           SWAP_ENDIAN = ((hdr_out.masktype GT 1) AND (hdr_out.endian NE hdr_out.maskendian))
    mask = ASSOC(lunmask,MAKE_ARRAY(hdr_out.masknx,hdr_out.maskny, $
              TYPE=hdr_out.masktype,/NOZERO),hdr_out.maskoffset)
		hdr_out.maskfile = 1	
	  hdr_out.maskdata = PTR_NEW(mask, /NO_COPY)
    hdr_out.lunmask = lunmask
    CRISPEX_IO_FEEDBACK, hdr_out.verbosity, hdr_out, MASKCUBE=hdr_out.maskfilename
END

PRO CRISPEX_IO_HANDLE_HDR, event, hdr, MAIN=main, REFERENCE=reference, MASK=mask
  WIDGET_CONTROL, event.TOP, GET_UVALUE = info
  IF KEYWORD_SET(REFERENCE) THEN BEGIN
    (*(*info).data).refdata = hdr.refdata
    (*(*info).data).refslice = hdr.refslice
    (*(*info).data).refspdata = hdr.refspdata
    (*(*info).data).refscan = hdr.refscan
    (*(*info).data).refsspscan = hdr.refsspscan
    (*(*info).data).lunrefim = hdr.lunrefim
    (*(*info).data).lunrefsp = hdr.lunrefsp
  
;   (*(*info).dataparams).refimfilename = hdr.refcube
;   (*(*info).dataparams).refspfilename = hdr.refspcube
    (*(*info).dataparams).refnlp = hdr.refnlp
    (*(*info).dataparams).reflps = hdr.reflps
    (*(*info).dataparams).refms = hdr.refms
    (*(*info).dataparams).refspec = hdr.refspect
    (*(*info).dataparams).refnt = hdr.refnt
    (*(*info).dataparams).bunit[1] = hdr.refbunit
    (*(*info).dataparams).lpunit[1] = hdr.reflpunit
    
    (*(*info).dataswitch).reffile = hdr.showref
    (*(*info).dataswitch).refspfile = hdr.refspfile
    
    (*(*info).dispparams).lp_ref_upp = hdr.refnlp-1
    (*(*info).dispparams).lp_ref_range = hdr.refnlp
  
    (*(*info).overlayswitch).maskim[1] = hdr.showref
  
    (*(*info).plotaxes).v_dop_ref = hdr.v_dop_ref
  
    (*(*info).winswitch).showrefsp = hdr.refspfile
    (*(*info).winswitch).showref = hdr.showref
  ENDIF
END

PRO CRISPEX_IO_SETTINGS_SPECTRAL, event, HDR_IN=hdr_in, HDR_OUT=hdr_out, MNSPEC=mnspec, $
                                  SPECTFILE=spectfile, LINE_CENTER=line_center, NO_WARP=no_warp, $
                                  STARTUPTLB=startuptlb, $
                                  IO_FAILSAFE_MNSPEC_ERROR=io_failsafe_mnspec_error, $
                                  IO_FAILSAFE_IMSPECTFILE_ERROR=io_failsafe_imspectfile_error,$
                                  IO_FAILSAFE_REFSPECTFILE_ERROR=io_failsafe_refspectfile_error, $
                                  IO_FAILSAFE_LINE_CENTER_ERROR=io_failsafe_line_center_error
  ; Handles spectral settings on loading cubes
  IF (N_ELEMENTS(event) EQ 1) THEN $
    WIDGET_CONTROL, event.TOP, GET_UVALUE = info $
  ELSE $
    hdr_out = hdr_in
  
  io_failsafe_mnspec_error = 0
  io_failsafe_imspectfile_error = 0
  io_failsafe_refspectfile_error = 0
  io_failsafe_line_center_error = 0

  ; Check for correct MNSPEC setting
  IF (N_ELEMENTS(MNSPEC) NE 0) THEN BEGIN
    CRISPEX_IO_FAILSAFES_MNSPEC, mnspec, hdr_out, STARTUPTLB=startuptlb, $
                                 IO_FAILSAFE_ERROR=io_failsafe_mnspec_error
    IF io_failsafe_mnspec_error THEN RETURN
  ENDIF 

  ; Handle SPECTFILE input; will only be done when cube is read in compatibility mode (i.e., for
  ; non-FITS cubes). Check whether SPECTFILE has been provided with save files
  IF ((N_ELEMENTS(SPECTFILE) GE 1) AND (SIZE(SPECTFILE,/TYPE) EQ 7)) THEN $
    spectfile_set = (spectfile[0] NE '') ELSE BEGIN
    spectfile_set = 0
  ENDELSE
  IF spectfile_set THEN BEGIN
    ; Check existence of file, else throw error message
    IF (FILE_TEST(spectfile[0]) EQ 0) THEN BEGIN
      CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'The main spectral save file "'+spectfile[0]+$
        '" does not exist. Please check your input.', /ERROR,/NO_ROUTINE
      io_failsafe_imspectfile_error = 1
      RETURN
    ENDIF
  ENDIF
  CRISPEX_IO_PARSE_SPECTFILE, spectfile, *hdr_out.imdata, hdr_out.verbosity, $
    SCANFILE=(*hdr_out.scan)[hdr_out.tsel_main[0]], $
    HDR_IN=hdr_out, HDR_OUT=hdr_out, MNSPEC=mnspec, /IMCUBE, $
    CUBE_COMPATIBILITY=hdr_out.imcube_compatibility, $
    STARTUPTLB=startuptlb, IO_FAILSAFE_ERROR=io_failsafe_imspectfile_error
  IF (io_failsafe_imspectfile_error EQ 1) THEN RETURN 
  refspectfile_set = ((N_ELEMENTS(SPECTFILE) EQ 2) AND (SIZE(SPECTFILE,/TYPE) EQ 7)) 
  IF refspectfile_set THEN BEGIN
    ; Check existence of file, else throw error message
    IF (FILE_TEST(spectfile[1]) EQ 0) THEN BEGIN
      CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'The reference spectral save file "'+spectfile[1]+$
        '" does not exist. Please check your input.', /ERROR,/NO_ROUTINE
      io_failsafe_refspectfile_error = 1
      RETURN
    ENDIF
  ENDIF
  IF (STRCOMPRESS(hdr_out.refimfilename) NE '') THEN BEGIN
    IF ((N_ELEMENTS(SPECTFILE) EQ 1) AND (refspectfile_set EQ 0)) THEN spectfile = [spectfile, '']
    CRISPEX_IO_PARSE_SPECTFILE, spectfile, *hdr_out.refdata, hdr_out.verbosity, HDR_IN=hdr_out, $
                                HDR_OUT=hdr_out, $
                                MNSPEC=mnspec, /REFCUBE, STARTUPTLB=startuptlb, $
                                CUBE_COMPATIBILITY=hdr_out.refimcube_compatibility, $
                                IO_FAILSAFE_ERROR=io_failsafe_refspectfile_error
    IF io_failsafe_refspectfile_error THEN RETURN
  ENDIF ELSE hdr_out = CREATE_STRUCT(hdr_out, 'refspec', 0, 'refms', 0, 'reflps', 0)

  ; Handle LINE_CENTER input
  IF (N_ELEMENTS(LINE_CENTER) NE 0) THEN BEGIN
    CRISPEX_IO_FAILSAFES_LINE_CENTER, line_center, hdr_out, NFILES=(hdr_out.showref+1), $
                                      STARTUPTLB=startuptlb, SPECTFILE_SET=spectfile_set, $
                                      REFSPECTFILE_SET=refspectfile_set,$
                                      IO_FAILSAFE_ERROR=io_failsafe_line_center_error
  ENDIF ;ELSE io_failsafe_line_center_error = 0
  cube_compatibility = [hdr_out.imcube_compatibility,hdr_out.refimcube_compatibility]
  IF (io_failsafe_line_center_error EQ 1) THEN RETURN ELSE $
    CRISPEX_IO_PARSE_LINE_CENTER, line_center, NFILES=(hdr_out.refnlp GT 1)+1, HDR_IN=hdr_out, $
                                  HDR_OUT=hdr_out,$
                                  SPECTFILE_SET=spectfile_set, REFSPECTFILE_SET=refspectfile_set,$
                                  CUBE_COMPATIBILITY=cube_compatibility, DLAMBDA_VAL=dlambda, $
                                  DLAMBDA_SET=dlambda_set, V_DOP_SET=v_dop_set, $
                                  IO_FAILSAFE_ERROR=io_failsafe_line_center_error
  hdr_out = CREATE_STRUCT(hdr_out, 'dlambda', dlambda, 'dlambda_set', dlambda_set, $
                          'v_dop_set', v_dop_set)
  ; Process settings from LINE_CENTER parsing 
  IF (hdr_out.refnlp GT 1) THEN BEGIN
    IF hdr_out.refimcube_compatibility THEN $
      hdr_out.refspxtitle = (['Spectral position','Wavelength'])[hdr_out.v_dop_set[1]] $
    ELSE $
      hdr_out.refspxtitle = hdr_out.xtitle[1]
  ENDIF ELSE BEGIN
    wheretag = WHERE(TAG_NAMES(hdr_out) EQ 'REFLC', count)
    IF (count EQ 0) THEN $
      hdr_out = CREATE_STRUCT(hdr_out, 'reflc', 0L)
    hdr_out = CREATE_STRUCT(hdr_out, 'v_dop_ref', 0)
  ENDELSE
  IF hdr_out.imcube_compatibility THEN $
    hdr_out.spxtitle = (['Spectral position','Wavelength'])[hdr_out.v_dop_set[0]] $
  ELSE $
    hdr_out.spxtitle = hdr_out.xtitle[0]
  
  ; Process settings based on LPS variable and NO_WARP keyword to (not) warp of spectral slices
  IF (hdr_out.ndiagnostics GT 1) THEN BEGIN
    idx = LINDGEN(hdr_out.nlp)
    FOR d=0,hdr_out.ndiagnostics-1 DO BEGIN
      IF (d EQ 0) THEN $
        idx_select = idx[hdr_out.diag_start[d]:(hdr_out.diag_start[d]+hdr_out.diag_width[d]-2)] $
      ELSE $
        idx_select = [idx_select,idx[hdr_out.diag_start[d]:(hdr_out.diag_start[d]+$
          hdr_out.diag_width[d]-2)]]
    ENDFOR
    idx_select = [idx_select,idx(hdr_out.diag_start[d-1]+hdr_out.diag_width[d-1]-1)]
  ENDIF
  IF ~KEYWORD_SET(NO_WARP) THEN no_warp = (hdr_out.ndiagnostics GT 1)
  CRISPEX_IO_PARSE_WARPSLICE, hdr_out.lps, hdr_out.nlp, hdr_out.mainnt, hdr_out.dlambda[0], $
                              hdr_out.dlambda_set[0], hdr_out.verbosity, NO_WARP=no_warp, $
                              WARPSPSLICE=warpspslice, XO=xo, XI=xi, YO=yo, YI=yi, $
                              IDX_SELECT=idx_select
  IF (hdr_out.nrefdiagnostics GT 1) THEN BEGIN
    refidx = LINDGEN(hdr_out.refnlp)
    FOR d=0,hdr_out.nrefdiagnostics-1 DO BEGIN
      IF (d EQ 0) THEN $
        refidx_select = refidx[hdr_out.refdiag_start[d]:(hdr_out.refdiag_start[d]+hdr_out.refdiag_width[d]-2)] $
      ELSE $
        refidx_select = [refidx_select,refidx[hdr_out.refdiag_start[d]:(hdr_out.refdiag_start[d]+$
          hdr_out.refdiag_width[d]-2)]]
    ENDFOR
    refidx_select = [refidx_select,refidx(hdr_out.refdiag_start[d-1]+hdr_out.refdiag_width[d-1]-1)]
  ENDIF
  IF ~KEYWORD_SET(NO_WARP) THEN no_warp = (hdr_out.nrefdiagnostics GT 1)
  CRISPEX_IO_PARSE_WARPSLICE, hdr_out.reflps, hdr_out.refnlp, hdr_out.refnt, hdr_out.dlambda[1], $   
                              hdr_out.dlambda_set[1], hdr_out.verbosity, NO_WARP=no_warp, $
                              WARPSPSLICE=warprefspslice, XO=xo_ref, XI=xi_ref, YO=yo_ref, $
                              YI=yi_ref, IDX_SELECT=refidx_select, /REFERENCE
  hdr_out = CREATE_STRUCT(hdr_out, 'xo', xo, 'xi', xi, 'yo', yo, 'yi', yi, 'xo_ref', xo_ref, $
                                    'xi_ref', xi_ref, 'yo_ref', yo_ref, 'yi_ref', yi_ref, $
                                    'warpspslice', warpspslice, 'warprefspslice', warprefspslice)
END

PRO CRISPEX_IO_PARSE_LINE_CENTER, line_center, NFILES=nfiles, HDR_IN=hdr_in, HDR_OUT=hdr_out, $
                                  SPECTFILE_SET=spectfile_set, REFSPECTFILE_SET=refspectfile_set, $
                                  CUBE_COMPATIBILITY=cube_compatibility, DLAMBDA_VAL=dlambda_val, $
                                  DLAMBDA_SET=dlambda_set, V_DOP_SET=v_dop_set, $
                                  IO_FAILSAFE_ERROR=io_failsafe_error
; Handles parsing of LINE_CENTER keyword
  ; lcase of 0: LINE_CENTER = <Undefined>
  ; lcase of 1: LINE_CENTER = lc or [[lc],[lc]]
  ; lcase of 2: LINE_CENTER = [cwav,dwav] or [[cwav,dwav],[cwav,dwav]]
  ; lcase of 3: LINE_CENTER = [lc,cwav,dwav] or [[lc,cwav,dwav],[lc,cwav,dwav]]
  hdr_out = hdr_in	
  IF (N_ELEMENTS(LINE_CENTER) GT 0) THEN BEGIN
    ndims = SIZE(LINE_CENTER,/N_DIMENSIONS) > 1
    nelem = N_ELEMENTS(LINE_CENTER)
    IF (io_failsafe_error NE 2) THEN lcase = nelem / ndims ELSE lcase = 0
  ENDIF ELSE BEGIN
    ndims = 1
    lcase = 0
  ENDELSE
  c_speed	= 2.99792458D5													; Speed of light in km/s
;  lc = LONARR(nfiles)   &  
  dlambda_val = FLTARR(2)  &  lambda_c = FLTARR(2)
	v_dop_set = BYTARR(2) &  dlambda_set = BYTARR(2)
  nlp_select = [hdr_out.nlp,hdr_out.refnlp]
  spectfile_set = [spectfile_set,refspectfile_set]
 
  FOR d=0,nfiles-1 DO BEGIN
    IF (d EQ 0) THEN tag2 = 'lc' ELSE tag2 = 'reflc'
    IF ((cube_compatibility[d] NE 1) AND (N_ELEMENTS(LINE_CENTER) GT 0) AND (d NE ndims-1)) THEN BEGIN
      CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'Calling CRISPEX with LINE_CENTER, while FITS cubes '+$
        'are provided, is not allowed. Settings from LINE_CENTER will be ignored.', /WARNING, $
        /NO_ROUTINE
        lcase = 0
    ENDIF 
    IF (d EQ 0) THEN BEGIN
      lps_select = hdr_out.lps    &   spec_select = hdr_out.spectrum 
    ENDIF ELSE BEGIN
      IF ((nfiles EQ 2) AND (ndims NE 2)) THEN lcase = 0
      lps_select = hdr_out.reflps &   spec_select = hdr_out.refspec
    ENDELSE
    IF ((lcase EQ 1) OR (lcase EQ 3)) THEN $            ; First read parameters from LINE_CENTER
      lc = line_center[0,d] $
    ELSE BEGIN              ; Or determine from mean spectrum if line centre position is not supplied
      wheretag2 = WHERE(TAG_NAMES(hdr_out) EQ STRUPCASE(tag2), count)
      IF (count LE 0) THEN $    ; Check whether tag2 exists, if non-existent
        lc = ( WHERE( spec_select EQ MIN(spec_select, /NAN) ) )[0] $
      ELSE BEGIN
        IF (d EQ 0) THEN lc = hdr_out.lc ELSE lc = hdr_out.reflc
      ENDELSE
    ENDELSE
    IF (lcase GE 2) THEN BEGIN
      lambda_c[d]    = line_center[(lcase EQ 3),d]
      dlambda_val[d] = line_center[1+(lcase EQ 3),d]
      dlambda_set[d] = 1
    ENDIF 
    ; Next determine whether LPS needs to be recalculated, only when in compatibility mode
    IF cube_compatibility[d] THEN BEGIN
      v_dop_set[d] = ((spectfile_set[d] EQ 1) OR (lcase GT 2))
      IF (v_dop_set[d] EQ 0) THEN lps_select -= lps_select[LONG(lc)]
      IF (lcase GE 2) THEN lps_select = lps_select*dlambda_val[d] + lambda_c[d]
      ndiagnostics = 1
      diag_width = nlp_select[d]
      diag_start = 0
    ENDIF ELSE BEGIN
      IF (d EQ 0) THEN BEGIN
        ndiagnostics = hdr_out.ndiagnostics 
        twave = hdr_out.twave
        diag_start = hdr_out.diag_start
        diag_width = hdr_out.diag_width
      ENDIF ELSE BEGIN
        ndiagnostics = hdr_out.nrefdiagnostics
        twave = hdr_out.twave_ref
        diag_start = hdr_out.refdiag_start
        diag_width = hdr_out.refdiag_width
      ENDELSE
      v_dop_set[d] = (lps_select[LONG(lc)] NE 0)
    ENDELSE
    v_dop = PTRARR(ndiagnostics)
    FOR dd=0,ndiagnostics-1 DO BEGIN
  	  IF v_dop_set[d] THEN BEGIN
        lps_select_loc = lps_select[diag_start[dd]:(diag_start[dd]+(diag_width[dd]-1))]
        IF cube_compatibility[d] THEN $
          v_dop_loc = c_speed*(lps_select_loc/lps_select_loc[LONG(lc)]-1) $
        ELSE BEGIN
          lc = twave[dd]
          v_dop_loc = c_speed*(lps_select_loc/FLOAT(lc)-1)
        ENDELSE
      ENDIF ELSE BEGIN
        nlp_select_loc = diag_width[dd]
        v_dop_loc = FLTARR(nlp_select_loc)					; array with Doppler velocities in km/s
      ENDELSE
      v_dop[dd] = PTR_NEW(v_dop_loc)
    ENDFOR
    IF (d EQ 0) THEN BEGIN      ; Fill hdr tags with main results
      hdr_out.lps = lps_select
      tag = 'v_dop'
    ENDIF ELSE BEGIN            ; Fill hdr tags with reference results
      hdr_out.reflps = lps_select   
      tag = 'v_dop_ref'
    ENDELSE
    wheretag2 = WHERE(TAG_NAMES(hdr_out) EQ STRUPCASE(tag2), count)
    IF (count LE 0) THEN BEGIN
      lc_sel = lc
      hdr_out = CREATE_STRUCT(hdr_out, tag, v_dop, tag2, lc_sel)
    ENDIF ELSE hdr_out = CREATE_STRUCT(hdr_out, tag, v_dop)
  ENDFOR
END

PRO CRISPEX_IO_PARSE_SINGLE_CUBE, input_single_cube, HDR_IN=hdr_in, HDR_OUT=hdr_out, $
  MAIN=main, REFERENCE=reference
  hdr_out = hdr_in
  ; Check setting of SINGLE_CUBE keyword
  IF KEYWORD_SET(MAIN) THEN BEGIN
  	IF (N_ELEMENTS(INPUT_SINGLE_CUBE) EQ 1) THEN BEGIN  ; If SINGLE_CUBE properly set, set nlp and nt
  		hdr_out.nlp = LONG(INPUT_SINGLE_CUBE)
  		hdr_out.onecube = 1
      hdr_out.single_cube[0] = hdr_out.nlp
  		hdr_out.mainnt = hdr_in.imnt / hdr_in.nlp / hdr_in.ns
  	ENDIF ELSE IF (hdr_out.spfile EQ 0) THEN BEGIN  
      ; If no SPCUBE or SINGLE_CUBE are set, we are dealing with a snapshot
  		hdr_out.nlp = hdr_in.imnt / hdr_in.ns
  		hdr_out.single_cube[0] = 0
    ENDIF
  ENDIF ELSE IF KEYWORD_SET(REFERENCE) THEN BEGIN
		IF (N_ELEMENTS(INPUT_SINGLE_CUBE) EQ 1) THEN BEGIN  ; If SINGLE_CUBE properly set, set refnlp 
			hdr_out.refnlp = LONG(INPUT_SINGLE_CUBE)
			hdr_out.onecube = 1
      hdr_out.single_cube[1] = hdr_out.refnlp
		ENDIF 
  ENDIF
END

PRO CRISPEX_IO_PARSE_SPECTFILE, spectfile, datafile, verbosity, SCANFILE=scanfile, $
                                HDR_IN=hdr_in, HDR_OUT=hdr_out, $
                                MNSPEC=mnspec, IMCUBE=imcube, REFCUBE=refcube, $
                                CUBE_COMPATIBILITY=cube_compatibility, STARTUPTLB=startuptlb, $
                                IO_FAILSAFE_ERROR=io_failsafe_error
; Handles parsing the spectral save files into the appropriate variables
  hdr_out = hdr_in
  io_failsafe_error = 0 &  calc_from_cubes = 0
  spectfile_set = 0     &  refspectfile_set = 0
  IF KEYWORD_SET(IMCUBE) THEN BEGIN
    nlp_select = hdr_out.nlp
    ns_select = hdr_out.ns
    feedback_text = 'main '
  ENDIF 
  IF KEYWORD_SET(REFCUBE) THEN BEGIN
    nlp_select = hdr_out.refnlp
    ns_select = hdr_out.refns
    feedback_text = 'reference '
  ENDIF
  IF (N_ELEMENTS(SPECTFILE) NE 0) THEN BEGIN
    IF KEYWORD_SET(CUBE_COMPATIBILITY) THEN BEGIN
      spectfile_set = KEYWORD_SET(IMCUBE)
      refspectfile_set = KEYWORD_SET(REFCUBE)
      IF (spectfile[refspectfile_set] NE '') THEN BEGIN ; Check whether SPECTFILE even has been given
  		  IF (N_ELEMENTS(MNSPEC) GT 0) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
          'WARNING: Calling CRISPEX with MNSPEC, while SPECTFILE is provided, is not allowed.'+$
          ' Using SPECTFILE for mean spectrum determination.', /NO_ROUTINE
          io_failsafe_error = 2
        RESTORE, spectfile[refspectfile_set];,VERBOSE=(TOTAL(verbosity[0:1]) GE 1) 
  			IF (verbosity[1] EQ 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'Restored '+feedback_text+$
                                           'spectral file: '+spectfile[refspectfile_set]+'.'
        IF (N_ELEMENTS(norm_factor) LT 1) THEN BEGIN   ; Failsafe against old spectfiles; convert vars
          spect_pos = ll
          norm_factor = 1/mn
          norm_spect = spec
  				CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'WARNING: The restored '+feedback_text+$
            'spectral file ('+spectfile[refspectfile_set]+$
            ') has a format pre-dating CRISPEX v1.6. If possible, please update the '+$
            feedback_text+'spectral file to the newest format. Reading spectral file in '+$
            'compatibility mode.', /NO_ROUTINE, NEWLINE=(io_failsafe_error NE 2)
          io_failsafe_error = 2
        ENDIF ELSE BEGIN                       ; Else, dealing with new spectfile, check title labels
  				IF (N_ELEMENTS(xtitle_label) EQ 1) THEN BEGIN                     ; If xtitle_label exists
  					IF ((STRCOMPRESS(xtitle_label) NE '') AND $                     ; and it's non-zero
                (STRCOMPRESS(hdr_out.xtitle[refspectfile_set]) EQ '')) THEN $ ; and hdr.xtitle empty 
              hdr_out.xtitle[refspectfile_set] = xtitle_label
  				ENDIF
  				IF (N_ELEMENTS(ytitle_label) EQ 1) THEN BEGIN                     ; If ytitle_label exists
  					IF ((STRCOMPRESS(ytitle_label) NE '') AND $                     ; and it's non-zero
                (STRCOMPRESS(hdr_out.ytitle[refspectfile_set]) EQ '')) THEN $ ; and hdr.ytitle empty
              hdr_out.ytitle[refspectfile_set] = ytitle_label
  				ENDIF
        ENDELSE
        ; Failsafe against data-incompatible SPECTFILE
        IF (N_ELEMENTS(spect_pos[*,0]) NE nlp_select) THEN BEGIN  
          CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'ERROR: Number of spectral positions in '+$
            feedback_text+'SPECTFILE (nlp='+STRTRIM(N_ELEMENTS(spect_pos[*,0]),2)+$
            ') is incompatible with that in the '+feedback_text+'datacubes (nlp='+$
            STRTRIM(nlp_select,2)+'). Please load the correct '+feedback_text+'spectral file.', $
            /NO_ROUTINE, NEWLINE=(io_failsafe_error NE 2)
  					IF (N_ELEMENTS(STARTUPTLB) EQ 1) THEN WIDGET_CONTROL, startuptlb, /DESTROY
            io_failsafe_error = 1
  					RETURN
        ENDIF
        IF KEYWORD_SET(IMCUBE) THEN tag = 'lps'
        IF KEYWORD_SET(REFCUBE) THEN tag = 'reflps'
        hdr_out = CREATE_STRUCT(hdr_out, tag, spect_pos)
      ENDIF ELSE calc_from_cubes = 1
    ENDIF ELSE BEGIN
      IF ((KEYWORD_SET(IMCUBE) AND (N_ELEMENTS(SPECTFILE) EQ 1)) OR $
          (KEYWORD_SET(REFCUBE) AND (N_ELEMENTS(SPECTFILE) EQ 2))) THEN $
          CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'WARNING: Calling CRISPEX with SPECTFILE, while'+$
            ' FITS cubes are provided, is not allowed. Settings from SPECTFILE will be ignored.', $
            /NO_ROUTINE, NEWLINE=(io_failsafe_error NE 2)
        io_failsafe_error = 2
      calc_from_cubes = 1
    ENDELSE
  ENDIF ELSE calc_from_cubes = 1
  IF calc_from_cubes THEN BEGIN
    IF (N_ELEMENTS(MNSPEC) GE 1) THEN BEGIN                       ; If MNSPEC set
      t_lower = mnspec[0]                                         ; Set lower t-value to mnspec[0]
      IF (N_ELEMENTS(MNSPEC) EQ 1) THEN t_upper = mnspec[0] ELSE t_upper = mnspec[1]
    ENDIF ELSE BEGIN                                              ; If not MNSPEC set, default to 0
      t_lower = 0 & t_upper = 0
    ENDELSE
    spectrum = DBLARR(nlp_select,ns_select)
    norm_spect = DBLARR(nlp_select,ns_select)
    IF ((ns_select GT 1) AND (N_ELEMENTS(scale_stokes) EQ 1)) THEN $  ; If ns>1 and scale_stokes set
      norm_factor = REPLICATE(scale_stokes,ns_select) $               ; fill norm_factor with those
    ELSE $
      norm_factor = FLTARR(ns_select)
    FOR s=0,ns_select-1 DO BEGIN        ; Loop over all "Stokes" positions
      FOR lp=0,nlp_select-1 DO BEGIN    ; Loop over all "spectral" positions
        FOR t=t_lower,t_upper DO $      ; Loop over all time steps
          spectrum[lp,s] += MEAN(datafile[t*nlp_select*ns_select + s*nlp_select + lp], /NAN)
      ENDFOR
      spectrum[*,s] /= FLOAT(t_upper - t_lower + 1)
      IF (ns_select GT 1) THEN BEGIN                                  
        IF (N_ELEMENTS(scale_stokes) NE 1) THEN BEGIN ; If ns>1 & not scale_stokes, find norm_factor
          min_spectrum = MIN(spectrum[*,s], MAX=max_spectrum, /NAN)
          norm_factor[s] = (ABS([min_spectrum,max_spectrum]))[ABS(max_spectrum) GE ABS(min_spectrum)]
        ENDIF
        norm_spect[*,s] = spectrum[*,s] / norm_factor[s]              ; Determine norm_spect
      ENDIF 
    ENDFOR
    IF (ns_select EQ 1) THEN BEGIN      ; If ns=1, norm_factor and norm_spect follow easily
      norm_factor = MAX(spectrum, /NAN)
      norm_spect = spectrum / FLOAT(norm_factor)
    ENDIF
  ENDIF
  IF KEYWORD_SET(IMCUBE) THEN BEGIN     ; Fill the related IMCUBE variables with results
    reform_norm_spect = REFORM(norm_spect[*,0])
    hdr_out = CREATE_STRUCT(hdr_out, 'mainspec', norm_spect, 'spectrum', reform_norm_spect, $
                                     'ms', norm_factor)
    wherelps = WHERE(TAG_NAMES(hdr_out) EQ 'LPS', count)
    IF (count GT 0) THEN BEGIN
      IF (TOTAL(hdr_out.lps) EQ 0) THEN hdr_out.lps = FINDGEN(hdr_out.nlp)
    ENDIF ELSE hdr_out = CREATE_STRUCT(hdr_out, 'lps', FINDGEN(hdr_out.nlp))
  ENDIF
  IF KEYWORD_SET(REFCUBE) THEN BEGIN    ; Fill the related REFCUBE variables with results
    hdr_out = CREATE_STRUCT(hdr_out, 'refspec', norm_spect, 'refms', norm_factor)
    wherereflps = WHERE(TAG_NAMES(hdr_out) EQ 'REFLPS', count) 
    IF (count GT 0) THEN BEGIN
      IF (TOTAL(hdr_out.reflps) EQ 0) THEN hdr_out.reflps = FINDGEN(hdr_out.refnlp)
    ENDIF ELSE hdr_out = CREATE_STRUCT(hdr_out, 'reflps', FINDGEN(hdr_out.refnlp))
  ENDIF
END

PRO CRISPEX_IO_PARSE_WARPSLICE, lps, nlp, nt, dlambda, dlambda_set, verbosity, NO_WARP=no_warp, $
                                WARPSPSLICE=warpspslice, XO=xo, XI=xi, YO=yo, YI=yi, $
                                REFERENCE=reference, IDX_SELECT=idx_select
; Handles warping of the slice, also given keyword NO_WARP
  warpspslice = 0				; Temporal spectrum is not warped to correct non-equidistant spectral positions
  xi = 0  &   yi = 0  &  xo = 0  &  yo = 0
  feedback_text = ['main','reference']  &  warp_text = ['No warp','Warp']
	IF (nlp GT 1) THEN BEGIN
		IF dlambda_set THEN ndecimals = ABS(FLOOR(ALOG10(ABS(dlambda)))) ELSE ndecimals = 2
		equidist = STRING((SHIFT(FLOAT(lps),-1) - FLOAT(lps))[0:nlp-2],$
                        FORMAT='(F8.'+STRTRIM(ndecimals,2)+')')
    IF (N_ELEMENTS(IDX_SELECT) GT 0) THEN equidist = equidist[idx_select] 
    ; Check for non-equidistant spectral positions and allowed consequential warping
		warpspslice = (((WHERE(equidist NE equidist[0]))[0] NE -1) AND ~KEYWORD_SET(NO_WARP))
    IF warpspslice THEN BEGIN
		  min_lps = MIN(lps, /NAN)
		  xi = FINDGEN(nlp) # REPLICATE(1,nt)
		  xo = ((lps-min_lps) / FLOAT(MAX(lps-min_lps, /NAN)) * (nlp-1)) # REPLICATE(1,nt)
		  yi = REPLICATE(1,nlp) # FINDGEN(nt)
		  yo = yi
		ENDIF 
    IF verbosity[1] THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, warp_text[warpspslice]+$
                          ' applied to '+feedback_text[KEYWORD_SET(REFERENCE)]+$
                          ' spectral slice.', /NO_ROUTINE
  ENDIF 
END

;==================== LOOP PROCEDURES
PRO CRISPEX_LOOP_DEFINE, event
; Handles the start of loop definition procedures
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).overlayswitch).loopslit = event.SELECT
	IF ((*(*info).overlayswitch).loopslit EQ 0) THEN BEGIN
		IF ((*(*info).winids).looptlb GT 0) THEN $
      WIDGET_CONTROL, (*(*info).winids).looptlb, /DESTROY
		*(*(*info).loopparams).xp = 0		  &	*(*(*info).loopparams).yp = 0		
    *(*(*info).overlayparams).sxp = 0.  & *(*(*info).overlayparams).syp = 0.	
    *(*(*info).loopparams).xr = 0.		  &	*(*(*info).loopparams).yr = 0.
		*(*(*info).overlayparams).sxr = 0.	&	*(*(*info).overlayparams).syr = 0.	
		*(*(*info).loopparams).xpdisp = 0	&	*(*(*info).loopparams).ypdisp = 0		
    *(*(*info).loopparams).xrdisp = 0.	&	*(*(*info).loopparams).yrdisp = 0.
		*(*(*info).loopparams).xp_ref = 0.		  &	*(*(*info).loopparams).yp_ref = 0.		
    *(*(*info).overlayparams).sxp_ref = 0.  & *(*(*info).overlayparams).syp_ref = 0.	
    *(*(*info).loopparams).xr_ref = 0.		  &	*(*(*info).loopparams).yr_ref = 0.
		*(*(*info).overlayparams).sxr_ref = 0.	&	*(*(*info).overlayparams).syr_ref = 0.	
		*(*(*info).loopparams).xpdisp_ref = 0	  &	*(*(*info).loopparams).ypdisp_ref = 0		
    *(*(*info).loopparams).xrdisp_ref = 0.	&	*(*(*info).loopparams).yrdisp_ref = 0.
    (*(*info).loopparams).np_ref = 0        & (*(*info).loopparams).np = 0
		*(*(*info).loopparams).xp_sji = 0.		  &	*(*(*info).loopparams).yp_sji = 0.		
    *(*(*info).overlayparams).sxp_sji = 0.  & *(*(*info).overlayparams).syp_sji = 0.	
    *(*(*info).loopparams).xr_sji = 0.		  &	*(*(*info).loopparams).yr_sji = 0.
		*(*(*info).overlayparams).sxr_sji = 0.	&	*(*(*info).overlayparams).syr_sji = 0.	
		*(*(*info).loopparams).xpdisp_sji = 0	  &	*(*(*info).loopparams).ypdisp_sji = 0		
    *(*(*info).loopparams).xrdisp_sji = 0.	&	*(*(*info).loopparams).yrdisp_sji = 0.
    (*(*info).loopparams).np_sji = 0        ;& (*(*info).loopsdata).sjiloopsize = 0
    (*(*info).loopsdata).loopsize = 0	    & (*(*info).loopsdata).refloopsize = 0
    (*(*info).loopparams).ngaps           = 0  
    *(*(*info).loopparams).databounds     = 0 
    (*(*info).loopparams).ngaps_ref       = 0  
    *(*(*info).loopparams).databounds_ref = 0 
    (*(*info).loopparams).ngaps_sji       = 0  
    *(*(*info).loopparams).databounds_sji = 0 
    (*(*info).winids).looptlb = 0		    &	(*(*info).overlayswitch).loopslit = 0
		(*(*info).winswitch).showloop = 0
		IF (*(*info).winswitch).showrefloop THEN BEGIN
			IF ((*(*info).winids).reflooptlb GT 0) THEN $
        WIDGET_CONTROL, (*(*info).winids).reflooptlb, /DESTROY
			(*(*info).winids).reflooptlb = 0	&	(*(*info).winswitch).showrefloop = 0
		ENDIF
		WIDGET_CONTROL, (*(*info).ctrlscp).loop_slice_but, SENSITIVE = 0
		WIDGET_CONTROL, (*(*info).ctrlscp).rem_loop_pt_but, SENSITIVE = 0
		WIDGET_CONTROL, (*(*info).ctrlscp).save_loop_pts, SENSITIVE = 0
		WIDGET_CONTROL, (*(*info).ctrlscp).timeslicemenu, SENSITIVE = 0
		WIDGET_CONTROL, (*(*info).ctrlscp).loop_slit_but, SET_VALUE = 'Draw path'
		WIDGET_CONTROL, (*(*info).ctrlscp).lock_button, SET_BUTTON = 0
		WIDGET_CONTROL, (*(*info).ctrlscp).unlock_button, /SET_BUTTON
		(*(*info).curs).lockset = event.SELECT
		CRISPEX_COORDSLIDERS_SET, 1, 1, event
		CRISPEX_DRAW, event
	ENDIF
	WIDGET_CONTROL, (*(*info).ctrlscp).measure_but, SENSITIVE = ABS(event.SELECT-1)
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).overlayswitch).loopslit], $
      labels=['Draw loop path']
END

PRO CRISPEX_LOOP_FEEDBACK, event
; Loop path feedback selection procedure
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event, /IGNORE_LAST
	(*(*info).overlayswitch).looppath_feedback = event.SELECT
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).overlayswitch).looppath_feedback], $
      labels=['Loop path feedback']
END

PRO CRISPEX_LOOP_GET, event, ADD_REMOVE=add_remove
; Gets the loop path and (if the loop display window is open) also the loopslab for display
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	CRISPEX_LOOP_GET_PATH, event, ADD_REMOVE=add_remove
	IF (*(*info).winswitch).showloop THEN BEGIN
		CRISPEX_LOOP_GET_SLAB, event
		CRISPEX_DISPLAYS_LOOPSLAB_REPLOT_AXES, event					
	ENDIF
	IF (*(*info).winswitch).showrefloop THEN BEGIN
		CRISPEX_LOOP_GET_REFSLAB, event
		CRISPEX_DISPLAYS_REFLOOPSLAB_REPLOT_AXES, event					
	ENDIF
  ; If ngaps >= 1 OR ngaps_ref >= 1, create empty slice for display purposes
  IF (((*(*info).loopparams).ngaps GE 1) OR $
    ((*(*info).loopparams).ngaps_ref GE 1) OR $
    ((*(*info).loopparams).ngaps_sji GE 1)) THEN BEGIN
    *(*(*info).loopsdata).empty_slice = $
      MAKE_ARRAY(N_ELEMENTS(*(*(*info).loopparams).xr), $
        (*(*info).dispparams).t_upp-(*(*info).dispparams).t_low+1, $
        TYPE=SIZE(*(*(*info).data).imagedata, /TYPE))
  ENDIF
END

PRO CRISPEX_LOOP_GET_PATH, event, ADD_REMOVE=add_remove
; Gets the actual loop path from spline interpolation
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  IF KEYWORD_SET(ADD_REMOVE) THEN BEGIN
    xp = *(*(*info).loopparams).xp
    yp = *(*(*info).loopparams).yp
  ENDIF ELSE BEGIN
    xp = *(*(*info).loopparams).xpdisp
    yp = *(*(*info).loopparams).ypdisp
  ENDELSE
  np_local = N_ELEMENTS(xp)
  IF (np_local GE 2) THEN BEGIN
    ; Check for identical coordinates, ignore if so
  	IF ((xp)[np_local-1] EQ (xp)[np_local-2]) AND $
       ((yp)[np_local-1] EQ (yp)[np_local-2]) THEN RETURN
  ENDIF
  main = CRISPEX_GET_PATH(xp, yp, np_local, $
    (*(*info).dataparams).nx, (*(*info).dataparams).ny)
  xp = main.xp
  yp = main.yp
  IF (*(*info).winswitch).showref THEN BEGIN
    IF KEYWORD_SET(ADD_REMOVE) THEN BEGIN
      xp_ref = *(*(*info).loopparams).xp_ref
      yp_ref = *(*(*info).loopparams).yp_ref
    ENDIF ELSE BEGIN
      xp_ref = *(*(*info).loopparams).xpdisp_ref
      yp_ref = *(*(*info).loopparams).ypdisp_ref
    ENDELSE
	  np_ref_local = (SIZE(xp_ref))[1] 
  	IF (np_ref_local GE 2) THEN BEGIN
      ; Check for identical coordinates, ignore if so
  		IF ((xp_ref)[np_ref_local-1] EQ (xp_ref)[np_ref_local-2]) AND $
         ((yp_ref)[np_ref_local-1] EQ (yp_ref)[np_ref_local-2]) THEN RETURN
  	ENDIF
    ref = CRISPEX_GET_PATH(xp_ref, yp_ref, np_ref_local, $
      (*(*info).dataparams).refnx, (*(*info).dataparams).refny)
    xp_ref = ref.xp
    yp_ref = ref.yp
  ENDIF
  IF (*(*info).winswitch).showsji THEN BEGIN
    IF KEYWORD_SET(ADD_REMOVE) THEN BEGIN
      xp_sji = *(*(*info).loopparams).xp_sji
      yp_sji = *(*(*info).loopparams).yp_sji
    ENDIF ELSE BEGIN
      xp_sji = *(*(*info).loopparams).xpdisp_sji
      yp_sji = *(*(*info).loopparams).ypdisp_sji
    ENDELSE
	  np_sji_local = (SIZE(xp_sji))[1] 
  	IF (np_sji_local GE 2) THEN BEGIN
      ; Check for identical coordinates, ignore if so
  		IF ((xp_sji)[np_sji_local-1] EQ (xp_sji)[np_sji_local-2]) AND $
         ((yp_sji)[np_sji_local-1] EQ (yp_sji)[np_sji_local-2]) THEN RETURN
  	ENDIF
    sji = CRISPEX_GET_PATH(xp_sji, yp_sji, np_sji_local, $
      (*(*info).dataparams).sjinx, (*(*info).dataparams).sjiny)
    xp_sji = sji.xp
    yp_sji = sji.yp
  ENDIF
  ; Once all is set, save variables 
  ; Always adjust the temporary display path variables
  sp_result = CRISPEX_TRANSFORM_DATA2DEVICE(info, X=xp, Y=yp, /MAIN)
  sr_result = CRISPEX_TRANSFORM_DATA2DEVICE(info, X=main.xr, Y=main.yr, /MAIN)
  *(*(*info).loopparams).xpdisp = xp
  *(*(*info).loopparams).ypdisp = yp
  *(*(*info).loopparams).xrdisp = main.xr
  *(*(*info).loopparams).yrdisp = main.yr
	*(*(*info).overlayparams).sxp = sp_result.x
	*(*(*info).overlayparams).syp = sp_result.y
	*(*(*info).overlayparams).sxr = sr_result.x
	*(*(*info).overlayparams).syr = sr_result.y
  IF (*(*info).winswitch).showref THEN BEGIN
    sp_result = CRISPEX_TRANSFORM_DATA2DEVICE(info, X=xp_ref, Y=yp_ref, /REF)
    sr_result = CRISPEX_TRANSFORM_DATA2DEVICE(info, X=ref.xr, Y=ref.yr, /REF)
    *(*(*info).loopparams).xpdisp_ref = xp_ref
    *(*(*info).loopparams).ypdisp_ref = yp_ref
    *(*(*info).loopparams).xrdisp_ref = ref.xr
    *(*(*info).loopparams).yrdisp_ref = ref.yr
  	*(*(*info).overlayparams).sxp_ref = sp_result.x
  	*(*(*info).overlayparams).syp_ref = sp_result.y
  	*(*(*info).overlayparams).sxr_ref = sr_result.x
  	*(*(*info).overlayparams).syr_ref = sr_result.y
  ENDIF
  IF (*(*info).winswitch).showsji THEN BEGIN
    sp_result = CRISPEX_TRANSFORM_DATA2DEVICE(info, X=xp_sji, Y=yp_sji, /SJI)
    sr_result = CRISPEX_TRANSFORM_DATA2DEVICE(info, X=sji.xr, Y=sji.yr, /SJI)
    *(*(*info).loopparams).xpdisp_sji = xp_sji
    *(*(*info).loopparams).ypdisp_sji = yp_sji
    *(*(*info).loopparams).xrdisp_sji = sji.xr
    *(*(*info).loopparams).yrdisp_sji = sji.yr
  	*(*(*info).overlayparams).sxp_sji = sp_result.x
  	*(*(*info).overlayparams).syp_sji = sp_result.y
  	*(*(*info).overlayparams).sxr_sji = sr_result.x
  	*(*(*info).overlayparams).syr_sji = sr_result.y
  ENDIF
  ; If changed by adding or removing a point, adjust the definitive path
  ; variables
  IF KEYWORD_SET(ADD_REMOVE) THEN BEGIN
    *(*(*info).loopparams).xp = xp
    *(*(*info).loopparams).yp = yp
    *(*(*info).loopparams).xr = main.xr
    *(*(*info).loopparams).yr = main.yr
    IF (*(*info).winswitch).showref THEN BEGIN
      *(*(*info).loopparams).xp_ref = xp_ref
      *(*(*info).loopparams).yp_ref = yp_ref
      *(*(*info).loopparams).xr_ref = ref.xr
      *(*(*info).loopparams).yr_ref = ref.yr
    ENDIF
    IF (*(*info).winswitch).showsji THEN BEGIN
      *(*(*info).loopparams).xp_sji = xp_sji
      *(*(*info).loopparams).yp_sji = yp_sji
      *(*(*info).loopparams).xr_sji = sji.xr
      *(*(*info).loopparams).yr_sji = sji.yr
    ENDIF
  ENDIF 
END

PRO CRISPEX_LOOP_GET_SLAB, event
; Handles the extraction of the loopslab for display
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  ; Get selected displayed xr/yr indices
	*(*(*info).loopparams).w_lpts = $
    WHERE((*(*(*info).loopparams).xr GE 0) AND $
      (*(*(*info).loopparams).xr LT ((*(*info).dataparams).nx)) AND $
      (*(*(*info).loopparams).yr GE 0) AND $
      (*(*(*info).loopparams).yr LT ((*(*info).dataparams).ny)), nw_lpts)
  (*(*info).loopparams).nw_lpts = nw_lpts
  ; Check for gaps
  IF (nw_lpts NE 0) THEN $
    result = CRISPEX_ARRAY_GET_GAP(*(*(*info).loopparams).w_lpts, $
      N_ELEMENTS(*(*(*info).loopparams).xr)) $
  ELSE $
    result = {ngaps:0, databounds:0, wdatabounds:0}
  (*(*info).loopparams).ngaps = result.ngaps
  *(*(*info).loopparams).databounds = result.databounds
  *(*(*info).loopparams).wdatabounds = result.wdatabounds
	IF (*(*info).dispswitch).exts THEN BEGIN
		WIDGET_CONTROL, /HOURGLASS
		lp_orig = (*(*info).dataparams).lp
		FOR i=(*(*info).dispparams).lp_low,(*(*info).dispparams).lp_upp DO BEGIN
			(*(*info).dataparams).lp = i
			CRISPEX_LOOP_GET_EXACT_SLICE, event, *(*(*info).data).imagedata, $
        *(*(*info).loopparams).xr, *(*(*info).loopparams).yr, $
        *(*(*info).loopparams).xp, *(*(*info).loopparams).yp, $
				*(*(*info).loopparams).w_lpts, loopslice, crossloc, loopsize,/im
			IF (i EQ (*(*info).dispparams).lp_low) THEN $
        loopslab = loopslice $
      ELSE $
        loopslab = [[[loopslab]], [[loopslice]]]
;			PRINT,'> '+STRTRIM(i-(*(*info).dispparams).lp_low+1,2)+'/'+STRTRIM((*(*info).dispparams).lp_upp-(*(*info).dispparams).lp_low+1,2)+' slices extracted...'
		ENDFOR
		(*(*info).dataparams).lp = lp_orig
	ENDIF ELSE BEGIN
		CRISPEX_LOOP_GET_APPROX_SLAB, event, *(*(*info).loopparams).xr, $
      *(*(*info).loopparams).yr, *(*(*info).loopparams).xp, $
      *(*(*info).loopparams).yp, *(*(*info).loopparams).w_lpts, $
      loopslab, crossloc, loopsize
	ENDELSE
	*(*(*info).loopsdata).loopslab = loopslab
	*(*(*info).loopsdata).crossloc = crossloc
	(*(*info).loopsdata).loopsize = N_ELEMENTS(*(*(*info).loopparams).xr) ;loopsize
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [N_ELEMENTS(crossloc),loopsize], $
      labels=['np','loopsize']
END

PRO CRISPEX_LOOP_GET_REFSLAB, event
; Handles the extraction of the reference loopslab for display
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  ; Get selected displayed xr/yr indices
	*(*(*info).loopparams).w_lpts_ref = $
    WHERE((*(*(*info).loopparams).xr_ref GE 0) AND $
      (*(*(*info).loopparams).xr_ref LT ((*(*info).dataparams).refnx)) AND $
      (*(*(*info).loopparams).yr_ref GE 0) AND $
      (*(*(*info).loopparams).yr_ref LT ((*(*info).dataparams).refny)), $
      nw_lpts_ref)
  (*(*info).loopparams).nw_lpts_ref = nw_lpts_ref
  ; Check for gaps
  IF (nw_lpts_ref NE 0) THEN $
    result = CRISPEX_ARRAY_GET_GAP(*(*(*info).loopparams).w_lpts_ref, $
      N_ELEMENTS(*(*(*info).loopparams).xr_ref)) $
  ELSE $
    result = {ngaps:0, databounds:0, wdatabounds:0}
  (*(*info).loopparams).ngaps_ref = result.ngaps
  *(*(*info).loopparams).databounds_ref = result.databounds
  *(*(*info).loopparams).wdatabounds_ref = result.wdatabounds
	IF (*(*info).dispswitch).refexts THEN BEGIN
		WIDGET_CONTROL, /HOURGLASS
		lp_orig = (*(*info).dataparams).lp_ref
		FOR i=(*(*info).dispparams).lp_ref_low,(*(*info).dispparams).lp_ref_upp DO BEGIN
			(*(*info).dataparams).lp_ref = i
			CRISPEX_LOOP_GET_EXACT_SLICE, event, *(*(*info).data).refdata, $
        *(*(*info).loopparams).xr_ref, *(*(*info).loopparams).yr_ref, $
        *(*(*info).loopparams).xp_ref, *(*(*info).loopparams).yp_ref, $
				*(*(*info).loopparams).w_lpts_ref, refloopslice, refcrossloc, refloopsize
			IF (i EQ (*(*info).dispparams).lp_ref_low) THEN $
        refloopslab = refloopslice $
      ELSE $
        refloopslab = [[[refloopslab]], [[refloopslice]]]
;			PRINT,'> '+STRTRIM(i-(*(*info).dispparams).lp_ref_low+1,2)+'/'+STRTRIM((*(*info).dispparams).lp_ref_upp-(*(*info).dispparams).lp_ref_low+1,2)+' slices extracted...'
		ENDFOR
		(*(*info).dataparams).lp_ref = lp_orig
	ENDIF ELSE BEGIN
		CRISPEX_LOOP_GET_APPROX_SLAB, event, *(*(*info).loopparams).xr_ref, $
      *(*(*info).loopparams).yr_ref, *(*(*info).loopparams).xp_ref, $
      *(*(*info).loopparams).yp_ref, *(*(*info).loopparams).w_lpts_ref, $
      refloopslab, refcrossloc, refloopsize, /REFERENCE
	ENDELSE
	*(*(*info).loopsdata).refloopslab = refloopslab
  *(*(*info).loopsdata).refcrossloc = refcrossloc
	(*(*info).loopsdata).refloopsize = N_ELEMENTS(*(*(*info).loopparams).xr_ref)
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [N_ELEMENTS(refcrossloc),refloopsize], $
      labels=['np','loopsize']
END

PRO CRISPEX_LOOP_GET_APPROX_SLAB, event, xrs, yrs, xps, yps, w_lpts, ap_loopslab, $
  ap_crossloc, ap_loopsize, REFERENCE=reference
; Gets the approximated loopslab for in-pragram display
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	IF KEYWORD_SET(REFERENCE) THEN BEGIN
		FOR i=0,(SIZE(xrs[w_lpts]))[1]-1 DO BEGIN
			IF (i EQ 0) THEN $
        tmp = ((*(*(*info).data).refspdata)[LONG(yrs[w_lpts[i]]) * $
          (*(*info).dataparams).refnx + LONG(xrs[w_lpts[i]])]) $
      ELSE $
				tmp = [ [[tmp]] , [[ ((*(*(*info).data).refspdata)[LONG(yrs[w_lpts[i]]) * $
          (*(*info).dataparams).refnx + LONG(xrs[w_lpts[i]])]) ]] ]
		ENDFOR
	ENDIF ELSE BEGIN
		FOR i=0,(SIZE(xrs[w_lpts]))[1]-1 DO BEGIN
			IF (i EQ 0) THEN BEGIN
				tmp = ((*(*(*info).data).spdata)[LONG(yrs[w_lpts[i]]) * $
          (*(*info).dataparams).nx * (*(*info).dataparams).ns + $
          LONG(xrs[w_lpts[i]])* (*(*info).dataparams).ns + (*(*info).dataparams).s])
			ENDIF ELSE BEGIN
				tmp = [[[tmp]],[[((*(*(*info).data).spdata)[LONG(yrs[w_lpts[i]]) * $
          (*(*info).dataparams).nx * (*(*info).dataparams).ns + $
          LONG(xrs[w_lpts[i]])* (*(*info).dataparams).ns + (*(*info).dataparams).s])]]]
			ENDELSE
		ENDFOR
	ENDELSE
  IF (SIZE(tmp,/N_DIMENSIONS) EQ 3) THEN $
	  ap_loopslab = TRANSPOSE(tmp, [2,1,0]) $
  ELSE BEGIN
    ap_loopslab = MAKE_ARRAY(1, (SIZE(tmp))[2], (SIZE(tmp))[1], $
      TYPE=(SIZE(tmp, /TYPE))) 
    ap_loopslab[0,*,*] = TRANSPOSE(tmp, [1,0])
  ENDELSE
	n = 1 + (ABS(((SIZE(xps))[0] EQ 1)-1))
	FOR k=0,(SIZE(xps))[n]-1 DO BEGIN
		IF (k EQ 0) THEN $
      ap_crossloc = [0] $
    ELSE $
      ap_crossloc = [ap_crossloc,WHERE((xrs EQ (xps[k])) AND (yrs EQ (yps[k])))]
	ENDFOR
	ap_loopsize = (SIZE(ap_loopslab))[1]
END

PRO CRISPEX_LOOP_GET_EXACT_SLICE, event, extractdata, xrs, yrs, xps, yps, $
  w_lpts, ex_loopslice, ex_crossloc, ex_loopsize, NO_NLP=no_nlp, IM=im
; Gets the exact loopslice for in-program display
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info			
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  IF KEYWORD_SET(IM) THEN BEGIN
    tlow = (*(*(*info).dispparams).tsel_main)[(*(*info).dispparams).t_low]
    tupp = (*(*(*info).dispparams).tsel_main)[(*(*info).dispparams).t_upp]
  ENDIF ELSE BEGIN
    tlow = (*(*(*info).dispparams).tsel_ref)[(*(*info).dispparams).t_low]
    tupp = (*(*(*info).dispparams).tsel_ref)[(*(*info).dispparams).t_upp]
  ENDELSE
	IF KEYWORD_SET(NO_NLP) THEN BEGIN
		FOR tt=tlow,tupp DO BEGIN
			IF (tt EQ tlow) THEN $
        tmp = INTERPOLATE( extractdata[tt], (xrs)[w_lpts],(yrs)[w_lpts]) $
      ELSE $
        tmp = [[tmp], [INTERPOLATE( extractdata[tt], (xrs)[w_lpts], $
          (yrs)[w_lpts])]]
		ENDFOR
	ENDIF ELSE BEGIN
		IF KEYWORD_SET(IM) THEN BEGIN		; Get space-time diagram from main cube
			FOR tt=tlow,tupp DO BEGIN
				IF (tt EQ tlow) THEN $
          tmp = INTERPOLATE( extractdata[$
            tt * (*(*info).dataparams).nlp * (*(*info).dataparams).ns+$
            (*(*info).dataparams).s * (*(*info).dataparams).nlp + $
            (*(*info).dataparams).lp], (xrs)[w_lpts],(yrs)[w_lpts])  $
        ELSE $
					tmp = [[tmp], [INTERPOLATE( extractdata[$
            tt * (*(*info).dataparams).nlp * (*(*info).dataparams).ns + $
            (*(*info).dataparams).s * (*(*info).dataparams).nlp + $
            (*(*info).dataparams).lp], (xrs)[w_lpts],(yrs)[w_lpts])]] 
			ENDFOR
		ENDIF ELSE BEGIN			; Get space-time diagram from reference cube
			FOR tt=tlow,tupp DO BEGIN
				IF (tt EQ tlow) THEN $
          tmp = INTERPOLATE( extractdata[$
            tt * (*(*info).dataparams).refnlp + (*(*info).dataparams).lp_ref], $
            (xrs)[w_lpts],(yrs)[w_lpts]) $
        ELSE $
					tmp = [[tmp], [INTERPOLATE( extractdata[$
            tt * (*(*info).dataparams).refnlp + (*(*info).dataparams).lp_ref], $
            (xrs)[w_lpts],(yrs)[w_lpts])]]
			ENDFOR
		ENDELSE
	ENDELSE
	ex_loopslice = tmp
	n = 1 + (ABS(((SIZE(xps))[0] EQ 1)-1))
	FOR k=0,(SIZE(xps))[n]-1 DO BEGIN
		IF (k EQ 0) THEN $
      ex_crossloc = [0] $
    ELSE $
      ex_crossloc = [ex_crossloc,WHERE( (xrs EQ (xps)[k]) AND (yrs EQ (yps)[k]))]
	ENDFOR
	ex_loopsize = (SIZE(ex_loopslice))[1]
END

PRO CRISPEX_LOOP_REMOVE_POINT, event, CURSOR_ACTION=cursor_action
; Handles the removal of a loop point
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  IF ~KEYWORD_SET(CURSOR_ACTION) THEN BEGIN
  	(*(*info).loopparams).np -= 1
  	IF (*(*info).winswitch).showref THEN (*(*info).loopparams).np_ref -= 1
  	IF (*(*info).winswitch).showsji THEN (*(*info).loopparams).np_sji -= 1
  ENDIF
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).loopparams).np], labels=['np']
  ; Reset main data and device coordinate points
	*(*(*info).loopparams).xp = $
    (*(*(*info).loopparams).xp)[0:(*(*info).loopparams).np-1]
	*(*(*info).loopparams).yp = $
    (*(*(*info).loopparams).yp)[0:(*(*info).loopparams).np-1]
	*(*(*info).loopparams).xpdisp = *(*(*info).loopparams).xp
	*(*(*info).loopparams).ypdisp = *(*(*info).loopparams).yp
  ; Reset xy-coordinates
  (*(*info).dataparams).x = $
    (*(*(*info).loopparams).xpdisp)[(*(*info).loopparams).np-1]
  (*(*info).dataparams).y = $
    (*(*(*info).loopparams).ypdisp)[(*(*info).loopparams).np-1]
 ; Reset reference data and device coordinate points
 IF (*(*info).winswitch).showref THEN BEGIN
  	*(*(*info).loopparams).xp_ref = $
      (*(*(*info).loopparams).xp_ref)[0:(*(*info).loopparams).np_ref-1]
  	*(*(*info).loopparams).yp_ref = $
      (*(*(*info).loopparams).yp_ref)[0:(*(*info).loopparams).np_ref-1]
  	*(*(*info).loopparams).xpdisp_ref = *(*(*info).loopparams).xp_ref
  	*(*(*info).loopparams).ypdisp_ref = *(*(*info).loopparams).yp_ref
    ; Reset xy-coordinates
    (*(*info).dataparams).xref = $
      (*(*(*info).loopparams).xpdisp_ref)[(*(*info).loopparams).np_ref-1]
    (*(*info).dataparams).yref = $
      (*(*(*info).loopparams).ypdisp_ref)[(*(*info).loopparams).np_ref-1]
 ENDIF
 ; Reset SJI data and device coordinate points
 IF (*(*info).winswitch).showsji THEN BEGIN
  	*(*(*info).loopparams).xp_sji = $
      (*(*(*info).loopparams).xp_sji)[0:(*(*info).loopparams).np_sji-1]
  	*(*(*info).loopparams).yp_sji = $
      (*(*(*info).loopparams).yp_sji)[0:(*(*info).loopparams).np_sji-1]
  	*(*(*info).loopparams).xpdisp_sji = *(*(*info).loopparams).xp_sji
  	*(*(*info).loopparams).ypdisp_sji = *(*(*info).loopparams).yp_sji
    ; Reset xy-coordinates
    (*(*info).dataparams).xsji = $
      (*(*(*info).loopparams).xpdisp_sji)[(*(*info).loopparams).np_sji-1]
    (*(*info).dataparams).ysji = $
      (*(*(*info).loopparams).ypdisp_sji)[(*(*info).loopparams).np_sji-1]
  ENDIF
  ; Check whether main coordinates are out of range
  (*(*info).dispswitch).xy_out_of_range = $
    (((*(*info).dataparams).x LT 0) OR ((*(*info).dataparams).y LT 0) OR $
     ((*(*info).dataparams).x GE (*(*info).dataparams).nx) OR $
     ((*(*info).dataparams).y GE (*(*info).dataparams).ny))
  ; Check whether reference coordinates are out of range
  IF (*(*info).dataswitch).reffile THEN $
    (*(*info).dispswitch).xyref_out_of_range = $
      (((*(*info).dataparams).xref LT 0) OR ((*(*info).dataparams).yref LT 0) OR $
       ((*(*info).dataparams).xref GE (*(*info).dataparams).refnx) OR $
       ((*(*info).dataparams).yref GE (*(*info).dataparams).refny))
  ; Check whether SJI coordinates are out of range
  IF (*(*info).dataswitch).sjifile THEN $
    (*(*info).dispswitch).xysji_out_of_range = $
      (((*(*info).dataparams).xsji LT 0) OR ((*(*info).dataparams).ysji LT 0) OR $
       ((*(*info).dataparams).xsji GE (*(*info).dataparams).sjinx) OR $
       ((*(*info).dataparams).ysji GE (*(*info).dataparams).sjiny))
  ; Action if routine called by CURSOR
  IF KEYWORD_SET(CURSOR_ACTION) THEN BEGIN
    IF ((*(*info).loopparams).np GE 2) THEN $
      CRISPEX_LOOP_GET_PATH, event $
    ELSE BEGIN
    	*(*(*info).loopparams).xr = (*(*(*info).loopparams).xp)[0]
    	*(*(*info).loopparams).yr = (*(*(*info).loopparams).yp)[0]
    	*(*(*info).loopparams).xrdisp = *(*(*info).loopparams).xr
    	*(*(*info).loopparams).yrdisp = *(*(*info).loopparams).yr
      IF (*(*info).winswitch).showref THEN BEGIN
    		*(*(*info).loopparams).xr_ref = (*(*(*info).loopparams).xp_ref)[0]
    		*(*(*info).loopparams).yr_ref = (*(*(*info).loopparams).yp_ref)[0]
      	*(*(*info).loopparams).xrdisp_ref = *(*(*info).loopparams).xr_ref
      	*(*(*info).loopparams).yrdisp_ref = *(*(*info).loopparams).yr_ref
      ENDIF
      IF (*(*info).winswitch).showsji THEN BEGIN
    		*(*(*info).loopparams).xr_sji = (*(*(*info).loopparams).xp_sji)[0]
    		*(*(*info).loopparams).yr_sji = (*(*(*info).loopparams).yp_sji)[0]
      	*(*(*info).loopparams).xrdisp_sji = *(*(*info).loopparams).xr_sji
      	*(*(*info).loopparams).yrdisp_sji = *(*(*info).loopparams).yr_sji
      ENDIF
    ENDELSE
  ENDIF ELSE BEGIN
    ; Make buttons insensitive if necessary
  	IF ((*(*info).loopparams).np EQ 2) THEN $
      WIDGET_CONTROL, (*(*info).ctrlscp).rem_loop_pt_but, SENSITIVE = 0
  	IF ((*(*info).loopparams).np LT 2) THEN $
      WIDGET_CONTROL, (*(*info).ctrlscp).loop_slice_but, SENSITIVE = 0
    CRISPEX_LOOP_GET, event, /ADD_REMOVE
    CRISPEX_UPDATE_LP, event
  	IF ((*(*info).zooming).factor NE 1) THEN CRISPEX_ZOOM_LOOP, event
  ENDELSE
  ; Reset coordinate sliders
	CRISPEX_COORDSLIDERS_SET, 1, 1, event
  CRISPEX_UPDATE_SX, event
  CRISPEX_UPDATE_SY, event
  ; Update display data and Redraw windows as necessary 
  IF (*(*info).winswitch).showls THEN CRISPEX_UPDATE_SSP, event
  IF (*(*info).winswitch).showsp THEN CRISPEX_UPDATE_SPSLICE, event
  IF (*(*info).winswitch).showrefls THEN CRISPEX_UPDATE_REFSSP, event
  IF (*(*info).winswitch).showrefsp THEN CRISPEX_UPDATE_REFSPSLICE, event
	IF (*(*info).winswitch).showphis THEN BEGIN
		CRISPEX_PHISLIT_DIRECTION, event
    CRISPEX_UPDATE_PHISLIT_COORDS, event
		CRISPEX_UPDATE_PHISLICE, event
	ENDIF ELSE CRISPEX_DRAW, event
END

;==================== MASK PROCEDURES
PRO CRISPEX_MASK_OVERLAY_COLOR_SLIDER, event
; Handles the change mask overlay window
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).overlayparams).maskcolor = event.VALUE
	CRISPEX_DRAW, event
END

PRO CRISPEX_MASK_OVERLAY_SELECT_COLOR_TABLE, event
; Handles the change mask overlay window
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).overlayparams).maskct = event.index
	CRISPEX_DRAW, event
END

PRO CRISPEX_MASK_BUTTONS_SET, event
; Handles the setting of mask buttons
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL,((*(*info).ctrlscp).mask_button_ids)[0],SET_BUTTON = ((*(*info).overlayswitch).maskim)[0], SENSITIVE = (*(*info).overlayswitch).mask
	WIDGET_CONTROL,((*(*info).ctrlscp).mask_button_ids)[1],SET_BUTTON = ((*(*info).overlayswitch).maskim)[1], SENSITIVE = ((*(*info).overlayswitch).mask AND (*(*info).dataswitch).reffile)
	WIDGET_CONTROL,((*(*info).ctrlscp).mask_button_ids)[2],SET_BUTTON = ((*(*info).overlayswitch).maskim)[2], SENSITIVE = ((*(*info).overlayswitch).mask AND (*(*info).winswitch).showdop)
END

;==================== MEASUREMENT PROCEDURES
PRO CRISPEX_MEASURE_DX, event
; Handles the change of arcseconds per pixel resolution
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event, /IGNORE_LAST
	WIDGET_CONTROL, (*(*info).ctrlscp).dx_text, GET_VALUE = textvalue
	(*(*info).dataparams).dx = FLOAT(textvalue[0])
	IF ((*(*info).meas).np GT 0) THEN CRISPEX_MEASURE_CALC, event
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).dataparams).dx], labels=['dx']
END

PRO CRISPEX_MEASURE_DY, event
; Handles the change of arcseconds per pixel resolution
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event, /IGNORE_LAST
	WIDGET_CONTROL, (*(*info).ctrlscp).dy_text, GET_VALUE = textvalue
	(*(*info).dataparams).dy = FLOAT(textvalue[0])
	IF ((*(*info).meas).np GT 0) THEN CRISPEX_MEASURE_CALC, event
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).dataparams).dy], labels=['dy']
END

PRO CRISPEX_MEASURE_ENABLE, event, DISABLE=disable
; Enables the spatial measurement tool
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event, /IGNORE_LAST
	IF KEYWORD_SET(DISABLE) THEN $
    (*(*info).meas).spatial_measurement = 0 $
  ELSE $
    (*(*info).meas).spatial_measurement = event.SELECT
  WIDGET_CONTROL, (*(*info).ctrlscp).measure_but, $
    SET_BUTTON=(*(*info).meas).spatial_measurement
	WIDGET_CONTROL, (*(*info).ctrlscp).apix_label, $
    SENSITIVE=(*(*info).meas).spatial_measurement
	WIDGET_CONTROL, (*(*info).ctrlscp).dx_text, $
    SENSITIVE=(*(*info).meas).spatial_measurement
	WIDGET_CONTROL, (*(*info).ctrlscp).x_label, $
    SENSITIVE=(*(*info).meas).spatial_measurement
	WIDGET_CONTROL, (*(*info).ctrlscp).dy_text, $
    SENSITIVE=(*(*info).meas).spatial_measurement
	WIDGET_CONTROL, (*(*info).ctrlscp).apix_unit, $
    SENSITIVE=(*(*info).meas).spatial_measurement
	WIDGET_CONTROL, (*(*info).ctrlscp).measure_asec_lab, $
    SENSITIVE=(*(*info).meas).spatial_measurement
	WIDGET_CONTROL, (*(*info).ctrlscp).measure_asec_text, $
    SENSITIVE=(*(*info).meas).spatial_measurement
	WIDGET_CONTROL, (*(*info).ctrlscp).measure_km_lab, $
    SENSITIVE=(*(*info).meas).spatial_measurement
	WIDGET_CONTROL, (*(*info).ctrlscp).measure_km_text, $
    SENSITIVE=(*(*info).meas).spatial_measurement
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).meas).spatial_measurement], $
      labels=['Enabled measurement']
	IF ((*(*info).meas).spatial_measurement EQ 0) THEN BEGIN
		(*(*info).meas).np = 0
		*(*(*info).meas).xp = 0
		*(*(*info).meas).yp = 0
		*(*(*info).meas).sxp = 0
		*(*(*info).meas).syp = 0
    IF (*(*info).winswitch).showref THEN BEGIN
  		*(*(*info).meas).xp_ref = 0
  		*(*(*info).meas).yp_ref = 0
  		*(*(*info).meas).sxp_ref = 0
  		*(*(*info).meas).syp_ref = 0
    ENDIF
    IF (*(*info).winswitch).showsji THEN BEGIN
  		*(*(*info).meas).xp_sji = 0
  		*(*(*info).meas).yp_sji = 0
  		*(*(*info).meas).sxp_sji = 0
  		*(*(*info).meas).syp_sji = 0
    ENDIF
		WIDGET_CONTROL, (*(*info).ctrlscp).measure_asec_text, SET_VALUE = '0'
		WIDGET_CONTROL, (*(*info).ctrlscp).measure_km_text, SET_VALUE = '0'
    IF (*(*info).curs).lockset THEN BEGIN
      (*(*info).dataparams).x = (*(*info).curs).xlock
      (*(*info).dataparams).y = (*(*info).curs).ylock
      CRISPEX_COORDS_TRANSFORM_XY, event, $
        MAIN2SJI=((*(*info).winids).sjitlb NE 0), $
        MAIN2REF=(((*(*info).winids).reftlb NE 0) AND $
          ((*(*info).winids).current_wid EQ (*(*info).winids).xydrawid)),$
        REF2MAIN=(((*(*info).winids).reftlb NE 0) AND $
          ((*(*info).winids).current_wid EQ (*(*info).winids).refdrawid)),$
        REF2SJI=(((*(*info).winids).reftlb NE 0) AND $
          ((*(*info).winids).sjitlb NE 0) AND $
          ((*(*info).winids).current_wid EQ (*(*info).winids).refdrawid))
      CRISPEX_UPDATE_SX, event
      CRISPEX_UPDATE_SY, event
    ENDIF
		(*(*info).curs).lockset = (*(*info).meas).spatial_measurement
		WIDGET_CONTROL, (*(*info).ctrlscp).unlock_button, SET_BUTTON = ABS((*(*info).curs).lockset-1)
		WIDGET_CONTROL, (*(*info).ctrlscp).lock_button, SET_BUTTON = (*(*info).curs).lockset
		CRISPEX_COORDSLIDERS_SET, 1, 1, event
		IF ~KEYWORD_SET(DISABLE) THEN CRISPEX_DRAW, event
	ENDIF
	WIDGET_CONTROL, (*(*info).ctrlscp).loop_slit_but, $
    SENSITIVE=ABS((*(*info).meas).spatial_measurement-1)
	WIDGET_CONTROL, (*(*info).ctrlscp).loop_feedb_but, $
    SENSITIVE=ABS((*(*info).meas).spatial_measurement-1)
END

PRO CRISPEX_MEASURE_CALC, event
; Computes the actual distance from the measurement line length and resolution
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  au = 149697870. 
	delta_x = FLOAT((*(*(*info).meas).xp)[1]-(*(*(*info).meas).xp)[0]) * (*(*info).dataparams).dx
	delta_y = FLOAT((*(*(*info).meas).yp)[1]-(*(*(*info).meas).yp)[0]) * (*(*info).dataparams).dy
  ; Check whether dx/dy units are arcsec or (c/k/M)m
  IF (STRCMP((*(*info).dataparams).xunit,'arcsec') OR $
      STRCMP((*(*info).dataparams).xunit,'asec')) THEN BEGIN
  	delta_asec = SQRT(delta_x^2 + delta_y^2)
  	delta_km = au * TAN(delta_asec / 3600. * !DTOR)
  ENDIF ELSE BEGIN
    IF STRCMP((*(*info).dataparams).xunit,'m') THEN fact = 1E3 ELSE $
      IF STRCMP((*(*info).dataparams).xunit,'cm') THEN fact = 1E5 ELSE $
      IF STRCMP((*(*info).dataparams).xunit,'km') THEN fact = 1 ELSE $
      IF STRCMP((*(*info).dataparams).xunit,'Mm') THEN fact = 1E-3 
    delta_km = SQRT(delta_x^2 + delta_y^2) / fact
    delta_asec = ATAN(delta_km / au) / !DTOR * 3600.
  ENDELSE
	WIDGET_CONTROL, (*(*info).ctrlscp).measure_asec_text, SET_VALUE = STRTRIM(delta_asec,2)
	WIDGET_CONTROL, (*(*info).ctrlscp).measure_km_text, SET_VALUE = STRTRIM(delta_km,2)
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [delta_asec,delta_km], labels=['Arcseconds','Kilometers']
END

;================================================================================= PLAYBACK PROCEDURES
PRO CRISPEX_PB_BG, event
; Handles the actual playback, given the mode of playback
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	CASE (*(*info).pbparams).mode OF
		'PAUSE'	: BEGIN
				IF (*(*info).pbparams).spmode THEN BEGIN
          IF ((*(*info).dataparams).lp NE (*(*info).pbparams).lp_blink) THEN $
            (*(*info).dataparams).lp = (*(*info).pbparams).lp_blink $
          ELSE $
            (*(*info).dataparams).lp = (*(*info).pbparams).lp_blink_init
          (*(*info).intparams).lp_diag_all = $
            TOTAL((*(*info).dataparams).lp GE (*(*info).intparams).diag_start)-1
			  ENDIF ELSE IF (*(*info).pbparams).imrefmode THEN BEGIN
					(*(*info).winids).imrefdisp = ABS((*(*info).winids).imrefdisp-1)
				ENDIF ELSE RETURN
				WIDGET_CONTROL,(*(*info).ctrlscp).lp_slider, SET_VALUE = (*(*info).dataparams).lp
			  END
		'PLAY'	: BEGIN
				IF ((*(*info).feedbparams).count_pbstats EQ 0) THEN (*(*info).feedbparams).pbstats = SYSTIME(/SECONDS)
				(*(*info).dispparams).t += (*(*info).pbparams).direction * (*(*info).pbparams).t_step
				IF (*(*info).pbparams).spmode THEN BEGIN
          IF ((*(*info).dataparams).lp NE (*(*info).pbparams).lp_blink) THEN $
            (*(*info).dataparams).lp = (*(*info).pbparams).lp_blink $
          ELSE $
            (*(*info).dataparams).lp = (*(*info).pbparams).lp_blink_init
          (*(*info).intparams).lp_diag_all = $
            TOTAL((*(*info).dataparams).lp GE (*(*info).intparams).diag_start)-1
					WIDGET_CONTROL,(*(*info).ctrlscp).lp_slider, SET_VALUE = (*(*info).dataparams).lp
			  ENDIF ELSE IF (*(*info).pbparams).imrefmode THEN BEGIN
					(*(*info).winids).imrefdisp = ABS((*(*info).winids).imrefdisp-1)
				ENDIF
				CASE (*(*info).pbparams).lmode OF
					'LOOP'	: BEGIN
							IF (*(*info).dispparams).t GT (*(*info).dispparams).t_upp THEN (*(*info).dispparams).t -= (*(*info).dispparams).t_range
							IF (*(*info).dispparams).t LT (*(*info).dispparams).t_low THEN (*(*info).dispparams).t += (*(*info).dispparams).t_range
						  END
					'CYCLE'	: BEGIN
							IF (*(*info).dispparams).t GT (*(*info).dispparams).t_upp THEN BEGIN
								(*(*info).pbparams).direction = -1
								(*(*info).dispparams).t = (*(*info).dispparams).t_upp - ((*(*info).dispparams).t MOD (*(*info).dispparams).t_upp)
							ENDIF ELSE IF (*(*info).dispparams).t LT (*(*info).dispparams).t_low THEN BEGIN
								(*(*info).pbparams).direction = 1
								IF ((*(*info).dispparams).t_low EQ (*(*info).dispparams).t_first) THEN (*(*info).dispparams).t *= -1 ELSE $
									(*(*info).dispparams).t = -1 * ((*(*info).dispparams).t - (*(*info).dispparams).t_low) + (*(*info).dispparams).t_low
							ENDIF
							IF ((*(*info).pbparams).direction GT 0) THEN $
                CRISPEX_PB_BUTTONS_SET, event, /FWD_SET, /NO_PB_TYPE $
              ELSE $
                CRISPEX_PB_BUTTONS_SET, event, /BWD_SET, /NO_PB_TYPE
						  END
					'BLINK'	: BEGIN
							(*(*info).pbparams).direction *= -1
							IF (*(*info).dispparams).t GT (*(*info).dispparams).t_upp THEN (*(*info).dispparams).t -=(*(*info).dispparams).t_range ELSE $
								IF (*(*info).dispparams).t LT (*(*info).dispparams).t_low THEN (*(*info).dispparams).t += (*(*info).dispparams).t_range
							IF ((*(*info).pbparams).direction GT 0) THEN $
                CRISPEX_PB_BUTTONS_SET, event, /FWD_SET, /NO_PB_TYPE $
              ELSE $
                CRISPEX_PB_BUTTONS_SET, event, /BWD_SET, /NO_PB_TYPE
						  END
				ENDCASE
			  END
	ENDCASE
	WIDGET_CONTROL, (*(*info).ctrlscp).t_slider, SET_VALUE = (*(*info).dispparams).t
	WIDGET_CONTROL, (*(*info).pbparams).bg, TIMER = 1. / (*(*info).pbparams).t_speed
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).pbparams).mode,(*(*info).pbparams).lmode,STRTRIM((*(*info).dispparams).t,2),STRTRIM((*(*info).pbparams).direction,2),$
		STRTRIM((*(*info).pbparams).spmode,2),STRTRIM((*(*info).dataparams).lp,2),STRTRIM((*(*info).pbparams).spdirection,2)], $
		labels=['Play mode','Loop mode','t','Play direction','Spectral blink mode','lp','Blink direction']
	CRISPEX_UPDATE_T, event
	IF (*(*info).pbparams).spmode THEN CRISPEX_UPDATE_LP, event
	IF (*(*info).dispparams).phislice_update THEN $
    CRISPEX_UPDATE_SLICES, event, /NO_DRAW, $
      NO_PHIS=((*(*info).winswitch).showphis EQ 0), $
      SSP_UPDATE=(((*(*info).dataswitch).spfile EQ 0) AND $
                  ((*(*info).pbparams).spmode EQ 0)), $
      REFSSP_UPDATE=(((*(*info).dataswitch).refspfile EQ 0) AND $
                     ((*(*info).pbparams).spmode EQ 0))
	CRISPEX_DRAW, event
	IF (((*(*info).feedbparams).verbosity)[4] EQ 1) THEN BEGIN
		(*(*info).feedbparams).count_pbstats += 1
		newtime = SYSTIME(/SECONDS)
		timediff = newtime-(*(*info).feedbparams).pbstats
		(*(*(*info).feedbparams).sum_pbstats)[(*(*info).feedbparams).count_pbstats MOD 10] = timediff
		(*(*info).feedbparams).av_pbstats = (((*(*info).feedbparams).av_pbstats)*((*(*info).feedbparams).count_pbstats-1) + timediff)/FLOAT((*(*info).feedbparams).count_pbstats)
		(*(*info).feedbparams).pbstats = newtime
		IF ((*(*info).feedbparams).count_pbstats GE 10) THEN $
      average = STRING(MEAN(*(*(*info).feedbparams).sum_pbstats, /NAN),FORMAT='(F6.4)')+' s' $
    ELSE $
      average = 'N/A'
		CRISPEX_UPDATE_USER_FEEDBACK, event, title='CRISPEX DEBUGGING: Playback statistics', var=((*(*info).feedbparams).count_pbstats+(*(*info).winids).feedbacktlb), minvar=1, /close_button, $
			feedback_text='Time elapsed since last update: '+STRING(timediff,FORMAT='(F6.4)')+' s, average (over last 10): '+average+', (over last '+$
			STRING((*(*info).feedbparams).count_pbstats,FORMAT='(I'+STRTRIM(FLOOR(ALOG10((*(*info).feedbparams).count_pbstats))+1,2)+')')+'): '+STRING((*(*info).feedbparams).av_pbstats,FORMAT='(F6.4)')+' s'
	ENDIF
END

PRO CRISPEX_PB_BUTTONS_SET, event, FBWD_SET=fbwd_set, BWD_SET=bwd_set, PAUSE_SET=pause_set, $
  FWD_SET=fwd_set, FFWD_SET=ffwd_set, LOOP_SET=loop_set, CYCLE_SET=cycle_set, BLINK_SET=blink_set, $
  NO_PB_TYPE=no_pb_type, NO_PB_DIR=no_pb_dir, SENSITIVE_SET=sensitive_set
; Sets playback buttons according to actions
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  IF ~KEYWORD_SET(NO_PB_TYPE) THEN BEGIN
		IF KEYWORD_SET(LOOP_SET) THEN $
      WIDGET_CONTROL, (*(*info).ctrlscp).loop_button, $
        SET_VALUE=(*(*info).ctrlspbbut).loop_pressed, /SET_BUTTON, SENSITIVE=sensitive_set $
    ELSE $
			WIDGET_CONTROL, (*(*info).ctrlscp).loop_button, SET_VALUE=(*(*info).ctrlspbbut).loop_idle, $
        SENSITIVE=sensitive_set
		IF KEYWORD_SET(CYCLE_SET) THEN $
      WIDGET_CONTROL, (*(*info).ctrlscp).cycle_button, $
        SET_VALUE=(*(*info).ctrlspbbut).cycle_pressed, /SET_BUTTON, SENSITIVE=sensitive_set $
    ELSE $
			WIDGET_CONTROL, (*(*info).ctrlscp).cycle_button, SET_VALUE=(*(*info).ctrlspbbut).cycle_idle, $
        SENSITIVE=sensitive_set
		IF KEYWORD_SET(BLINK_SET) THEN $
      WIDGET_CONTROL, (*(*info).ctrlscp).blink_button, $
        SET_VALUE=(*(*info).ctrlspbbut).blink_pressed, /SET_BUTTON, SENSITIVE=sensitive_set $
    ELSE $
			WIDGET_CONTROL, (*(*info).ctrlscp).blink_button, SET_VALUE=(*(*info).ctrlspbbut).blink_idle, $
        SENSITIVE=sensitive_set
	ENDIF 
  IF ~KEYWORD_SET(NO_PB_DIR) THEN BEGIN
		IF KEYWORD_SET(FBWD_SET) THEN $
      WIDGET_CONTROL, (*(*info).ctrlscp).fbwd_button, SET_VALUE=(*(*info).ctrlspbbut).fbwd_pressed,$
        SENSITIVE=sensitive_set $
    ELSE $
			WIDGET_CONTROL, (*(*info).ctrlscp).fbwd_button, SET_VALUE=(*(*info).ctrlspbbut).fbwd_idle, $
        SENSITIVE=sensitive_set
		IF KEYWORD_SET(BWD_SET) THEN $
      WIDGET_CONTROL, (*(*info).ctrlscp).bwd_button, SET_VALUE=(*(*info).ctrlspbbut).bwd_pressed, $
        SENSITIVE=sensitive_set $
    ELSE $
			WIDGET_CONTROL, (*(*info).ctrlscp).bwd_button, SET_VALUE=(*(*info).ctrlspbbut).bwd_idle, $
        SENSITIVE=sensitive_set
		IF KEYWORD_SET(PAUSE_SET) THEN $
      WIDGET_CONTROL, (*(*info).ctrlscp).pause_button, $
        SET_VALUE=(*(*info).ctrlspbbut).pause_pressed, SENSITIVE=sensitive_set $
    ELSE $
			WIDGET_CONTROL, (*(*info).ctrlscp).pause_button, SET_VALUE=(*(*info).ctrlspbbut).pause_idle, $
        SENSITIVE=sensitive_set
		IF KEYWORD_SET(FWD_SET) THEN $
      WIDGET_CONTROL, (*(*info).ctrlscp).fwd_button, SET_VALUE=(*(*info).ctrlspbbut).fwd_pressed, $
        SENSITIVE=sensitive_set $
    ELSE $
			WIDGET_CONTROL, (*(*info).ctrlscp).fwd_button, SET_VALUE=(*(*info).ctrlspbbut).fwd_idle, $
        SENSITIVE=sensitive_set
		IF KEYWORD_SET(FFWD_SET) $
      THEN WIDGET_CONTROL, (*(*info).ctrlscp).ffwd_button, $
        SET_VALUE=(*(*info).ctrlspbbut).ffwd_pressed, SENSITIVE=sensitive_set $
    ELSE $
			WIDGET_CONTROL, (*(*info).ctrlscp).ffwd_button, SET_VALUE=(*(*info).ctrlspbbut).ffwd_idle, $
        SENSITIVE=sensitive_set
  ENDIF
END

PRO CRISPEX_PB_BACKWARD, event
; Sets the playback mode to backward play
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (*(*info).pbparams).mode EQ 'PLAY' AND (*(*info).pbparams).direction EQ -1 THEN RETURN
	(*(*info).pbparams).direction = -1			&	(*(*info).pbparams).mode = 'PLAY'
	WIDGET_CONTROL, (*(*info).pbparams).bg, TIMER = 0.0
	CRISPEX_PB_BUTTONS_SET, event, /BWD_SET, /NO_PB_TYPE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).pbparams).mode,STRTRIM((*(*info).pbparams).direction,2)], labels=['Play mode','Play direction']
END

PRO CRISPEX_PB_FORWARD, event
; Sets the playback mode to forward play
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (*(*info).pbparams).mode EQ 'PLAY' AND (*(*info).pbparams).direction EQ 1 THEN RETURN
	(*(*info).pbparams).direction = 1			&	(*(*info).pbparams).mode = 'PLAY'
	WIDGET_CONTROL, (*(*info).pbparams).bg, TIMER = 0.0
	CRISPEX_PB_BUTTONS_SET, event, /FWD_SET, /NO_PB_TYPE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).pbparams).mode,STRTRIM((*(*info).pbparams).direction,2)], labels=['Play mode','Play direction']
END

PRO CRISPEX_PB_FASTBACKWARD, event
; Sets the playback mode to single step backward
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (*(*info).pbparams).mode EQ 'PAUSE' OR (*(*info).pbparams).lmode EQ 'BLINK' THEN BEGIN
		CRISPEX_PB_BUTTONS_SET, event, /FBWD_SET, /NO_PB_TYPE
		(*(*info).dispparams).t -= (*(*info).pbparams).t_step
		IF ((*(*info).dispparams).t LT (*(*info).dispparams).t_low) THEN (*(*info).dispparams).t = (*(*info).dispparams).t_upp
		CRISPEX_UPDATE_T, event
		WIDGET_CONTROL, (*(*info).ctrlscp).t_slider, SET_VALUE = (*(*info).dispparams).t
		CRISPEX_UPDATE_SLICES, event, SSP_UPDATE=((*(*info).dataswitch).spfile EQ 0), $
      REFSSP_UPDATE=((*(*info).dataswitch).refspfile EQ 0), /NO_DRAW, $
      NO_PHIS=((*(*info).winswitch).showphis EQ 0)
		CRISPEX_DRAW, event
		CRISPEX_PB_BUTTONS_SET, event, /PAUSE_SET, /NO_PB_TYPE
	ENDIF
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).pbparams).mode,(*(*info).pbparams).lmode,STRTRIM((*(*info).dispparams).t,2)], labels=['Play mode','Loop mode','t']
END

PRO CRISPEX_PB_FASTFORWARD, event
; Sets the playback mode to single step forward
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (*(*info).pbparams).mode EQ 'PAUSE' OR (*(*info).pbparams).lmode EQ 'BLINK' THEN BEGIN
		CRISPEX_PB_BUTTONS_SET, event, /FFWD_SET, /NO_PB_TYPE
		(*(*info).dispparams).t = (((*(*info).dispparams).t - (*(*info).dispparams).t_low + (*(*info).pbparams).t_step) MOD ((*(*info).dispparams).t_upp - (*(*info).dispparams).t_low + 1)) + (*(*info).dispparams).t_low
		CRISPEX_UPDATE_T, event
		WIDGET_CONTROL, (*(*info).ctrlscp).t_slider, SET_VALUE = (*(*info).dispparams).t
		CRISPEX_UPDATE_SLICES, event, SSP_UPDATE=((*(*info).dataswitch).spfile EQ 0), $
      REFSSP_UPDATE=((*(*info).dataswitch).refspfile EQ 0), /NO_DRAW , $
      NO_PHIS=((*(*info).winswitch).showphis EQ 0)
		CRISPEX_DRAW, event
		CRISPEX_PB_BUTTONS_SET, event, /PAUSE_SET, /NO_PB_TYPE
	ENDIF
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).pbparams).mode,(*(*info).pbparams).lmode,STRTRIM((*(*info).dispparams).t,2)], labels=['Play mode','Loop mode','t']
END

PRO CRISPEX_PB_PAUSE, event
; Sets the playback mode pause
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (*(*info).pbparams).mode EQ 'PAUSE' THEN RETURN
	(*(*info).pbparams).mode = 'PAUSE'
	IF ((*(*info).winids).feedbacktlb NE 0) THEN BEGIN
		(*(*info).feedbparams).count_pbstats = 0
		WIDGET_CONTROL, (*(*info).ctrlsfeedb).close_button, /SENSITIVE
	ENDIF
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).pbparams).mode,(*(*info).pbparams).lmode,STRTRIM((*(*info).dispparams).t,2)], labels=['Play mode','Loop mode','t']
	CRISPEX_PB_BUTTONS_SET, event, /PAUSE_SET, /NO_PB_TYPE
  CRISPEX_UPDATE_SLICES, event, SSP_UPDATE=((*(*info).dataswitch).spfile EQ 0), $
    REFSSP_UPDATE=((*(*info).dataswitch).refspfile EQ 0), /REFLS_DRAW, $
    NO_PHIS=((*(*info).dispparams).phislice_update EQ 0)
END

PRO CRISPEX_PB_BLINK, event
; Sets the playback mode to temporal blink
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).pbparams).lmode = 'BLINK'
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).pbparams).mode,(*(*info).pbparams).lmode,STRTRIM((*(*info).dispparams).t,2)], labels=['Play mode','Loop mode','t']
	CRISPEX_PB_BUTTONS_SET, event, /BLINK_SET, /NO_PB_DIR
END

PRO CRISPEX_PB_CYCLE, event
; Sets the playback mode to cycle
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).pbparams).lmode = 'CYCLE'
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).pbparams).mode,(*(*info).pbparams).lmode,STRTRIM((*(*info).dispparams).t,2)], labels=['Play mode','Loop mode','t']
	CRISPEX_PB_BUTTONS_SET, event, /CYCLE_SET, /NO_PB_DIR
END

PRO CRISPEX_PB_LOOP, event
; Sets the playback mode to loop
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).pbparams).lmode = 'LOOP'
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).pbparams).mode,(*(*info).pbparams).lmode,STRTRIM((*(*info).dispparams).t,2)], labels=['Play mode','Loop mode','t']
	CRISPEX_PB_BUTTONS_SET, event, /LOOP_SET, /NO_PB_DIR
END

PRO CRISPEX_PB_SPECTBLINK, event
; Sets the playback mode to spectral blink
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).pbparams).spmode = event.SELECT
	WIDGET_CONTROL, (*(*info).ctrlscp).imref_blink_but, SENSITIVE=ABS((*(*info).pbparams).spmode-1)
	IF (*(*info).pbparams).spmode THEN BEGIN
		(*(*info).pbparams).spdirection = 1
    (*(*info).pbparams).lp_blink_init = (*(*info).dataparams).lp
		IF ((*(*info).feedbparams).count_pbstats EQ 0) THEN (*(*info).feedbparams).pbstats = SYSTIME(/SECONDS)
		WIDGET_CONTROL, (*(*info).pbparams).bg, TIMER = 0.0
	ENDIF ELSE BEGIN
    WIDGET_CONTROL, (*(*info).ctrlscp).lp_blink_but, $
      SENSITIVE=((*(*info).pbparams).lp_blink NE (*(*info).dataparams).lp)
		IF ((*(*info).winids).feedbacktlb NE 0) THEN BEGIN
			(*(*info).feedbparams).count_pbstats = 0
			WIDGET_CONTROL, (*(*info).ctrlsfeedb).close_button, /SENSITIVE
		ENDIF
	ENDELSE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).pbparams).spmode,(*(*info).pbparams).spdirection], labels=['Spectral blink mode','Blink direction']
END

;========================= SPECTRAL PHI SLIT PROCEDURES
PRO CRISPEX_PHISLIT_DIRECTION, event
; Determines the direction of the spectral phi slit
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	x_maxpts = COS(!DTOR * (*(*info).phiparams).angle) * (FINDGEN( 2 * (*(*info).phiparams).nphi/2) - (*(*info).phiparams).nphi/2) + FIX((*(*info).dataparams).x)
	y_maxpts = SIN(!DTOR * (*(*info).phiparams).angle) * (FINDGEN( 2 * (*(*info).phiparams).nphi/2) - (*(*info).phiparams).nphi/2) + FIX((*(*info).dataparams).y)
	wmax = WHERE((x_maxpts GE 0 ) AND (x_maxpts LE (*(*info).dispparams).x_last) AND (y_maxpts GE 0) AND (y_maxpts LE (*(*info).dispparams).y_last), nwmax)
  IF (nwmax GT 0) THEN BEGIN
  	thex = REBIN(x_maxpts[wmax], nwmax, 2)
  	they = REBIN(y_maxpts[wmax], nwmax, 2)
  	thep = REBIN(FINDGEN(1,2), nwmax, 2)
  	*(*(*info).data).indices = INTERPOLATE( *(*(*info).data).indexmap, thex, they, thep)
  	search = WHERE(((*(*(*info).data).indices)[*,0] EQ FIX((*(*info).dataparams).x)) AND ((*(*(*info).data).indices)[*,1] EQ FIX((*(*info).dataparams).y)))
  	(*(*info).phiparams).curindex = search[0]
  	(*(*info).phiparams).maxindex = (SIZE(wmax))[1]
  	IF ((*(*info).phiparams).curindex GT 1) OR ((*(*info).phiparams).curindex NE (*(*info).phiparams).maxindex-1) THEN BEGIN
  		IF (*(*info).ctrlsswitch).bwd_insensitive THEN WIDGET_CONTROL, (*(*info).ctrlscp).bwd_move_slit, SENSITIVE = 1
  		IF (*(*info).ctrlsswitch).fwd_insensitive THEN WIDGET_CONTROL, (*(*info).ctrlscp).fwd_move_slit, SENSITIVE = 1
  	ENDIF ELSE IF ((*(*info).phiparams).curindex LT 1) OR ((*(*info).phiparams).curindex EQ (*(*info).phiparams).maxindex-1) THEN BEGIN
  		IF ((*(*info).ctrlsswitch).bwd_insensitive EQ 0) THEN WIDGET_CONTROL, (*(*info).ctrlscp).bwd_move_slit, SENSITIVE = 0
  		IF ((*(*info).ctrlsswitch).fwd_insensitive EQ 0) THEN WIDGET_CONTROL, (*(*info).ctrlscp).fwd_move_slit, SENSITIVE = 0
  	ENDIF
  ENDIF
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).dataparams).x,(*(*info).dataparams).y,(*(*info).phiparams).curindex,(*(*info).phiparams).maxindex], $
		labels=['x','y','current index', 'maximum index']
END

PRO CRISPEX_PHISLIT_MOVE_BWD, event
; Handles the movement of the spectral phi slit backward along the slit
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	newindex = (*(*info).phiparams).curindex-1
	(*(*info).phiparams).curindex = newindex
	(*(*info).dataparams).x = ((*(*(*info).data).indices)[newindex,*])[0]
	(*(*info).dataparams).y = ((*(*(*info).data).indices)[newindex,*])[1]
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [newindex+1,newindex,(*(*info).dataparams).x,(*(*info).dataparams).y], labels=['Previous index','New index','x','y']
	CRISPEX_PHISLIT_MOVE_SET_COORDS, event
	IF ((*(*info).phiparams).curindex EQ 0) THEN BEGIN
		WIDGET_CONTROL, (*(*info).ctrlscp).bwd_move_slit, SENSITIVE = 0
		(*(*info).ctrlsswitch).bwd_insensitive = 1
	ENDIF
	IF (*(*info).ctrlsswitch).fwd_insensitive THEN WIDGET_CONTROL, (*(*info).ctrlscp).fwd_move_slit, SENSITIVE = 1
  CRISPEX_UPDATE_PHISLIT_COORDS, event
	CRISPEX_UPDATE_PHISLICE, event 
	CRISPEX_COORDSLIDERS_SET, 1, 1, event
END

PRO CRISPEX_PHISLIT_MOVE_FWD, event
; Handles the movement of the spectral phi slit forward along the slit
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	newindex = (*(*info).phiparams).curindex+1
	(*(*info).phiparams).curindex = newindex
	(*(*info).dataparams).x = ((*(*(*info).data).indices)[newindex,*])[0]
	(*(*info).dataparams).y = ((*(*(*info).data).indices)[newindex,*])[1]
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [newindex-1,newindex,(*(*info).dataparams).x,(*(*info).dataparams).y], labels=['Previous index','New index','x','y']
	CRISPEX_PHISLIT_MOVE_SET_COORDS, event
	IF ((*(*info).phiparams).curindex EQ (*(*info).phiparams).maxindex-1) THEN BEGIN
		WIDGET_CONTROL, (*(*info).ctrlscp).fwd_move_slit, SENSITIVE = 0
		(*(*info).ctrlsswitch).fwd_insensitive = 1
	ENDIF
	IF (*(*info).ctrlsswitch).bwd_insensitive THEN WIDGET_CONTROL, (*(*info).ctrlscp).bwd_move_slit, SENSITIVE = 1
  CRISPEX_UPDATE_PHISLIT_COORDS, event
	CRISPEX_UPDATE_PHISLICE, event 
	CRISPEX_COORDSLIDERS_SET, 1, 1, event
END

PRO CRISPEX_PHISLIT_MOVE_SET_COORDS, event
; Handles the coordinate update after the movement of the spectral phi slit along the slit
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF ((*(*info).zooming).factor EQ 1) THEN BEGIN
		(*(*info).curs).sx = (*(*info).dataparams).x * (*(*info).winsizes).xywinx / (*(*info).dataparams).nx
		(*(*info).curs).sy = (*(*info).dataparams).y * (*(*info).winsizes).xywiny / (*(*info).dataparams).ny
	ENDIF ELSE BEGIN
		(*(*info).curs).sx = (*(*info).dataparams).x * ((*(*info).dataparams).d_nx+1) / (*(*info).dataparams).nx
		(*(*info).curs).sy = (*(*info).dataparams).y * ((*(*info).dataparams).d_ny+1) / (*(*info).dataparams).ny
	ENDELSE
	IF (*(*info).curs).lockset EQ 1 THEN BEGIN
		(*(*info).curs).xlock = (*(*info).dataparams).x	&	(*(*info).curs).ylock = (*(*info).dataparams).y
		(*(*info).curs).sxlock= (*(*info).curs).sx	&	(*(*info).curs).sylock= (*(*info).curs).sy
	ENDIF
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).curs).sx,(*(*info).curs).sy,(*(*info).curs).xlock,(*(*info).curs).ylock,(*(*info).curs).sxlock,(*(*info).curs).sylock], $
		labels=['sx','sy','xlock','ylock','sxlock','sylock']
END

;========================= PREFERENCES ROUTINES
PRO CRISPEX_PREFERENCES_WINDOW, event
; Opens up the preferences window
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	base 		= WIDGET_BASE(TITLE = 'CRISPEX'+(*(*info).sesparams).instance_label+$
    ': Preferences', GROUP_LEADER = (*(*info).winids).root, TLB_FRAME_ATTR = 1, $
    /TLB_KILL_REQUEST_EVENTS)
	main		= WIDGET_BASE(base, /COLUMN)
  tab_width = 432
  pad = 3
  tab_tlb = WIDGET_TAB(main, LOCATION=0, MULTILINE=3, XSIZE=tab_width+2*pad)
 
  ; Start-up preferences
  startup_base   = WIDGET_BASE(tab_tlb, TITLE='Start-up', /COLUMN, XSIZE=tab_width);, /FRAME)
	startup_buts 	= WIDGET_BASE(startup_base, /COLUMN, /NONEXCLUSIVE)
	(*(*info).ctrlspref).startup_win = $
                  WIDGET_BUTTON(startup_buts, VALUE = 'Show start-up window', $
                    EVENT_PRO='CRISPEX_PREFERENCES_SET_STARTUPWIN')
	(*(*info).ctrlspref).startup_autopl	= $
                  WIDGET_BUTTON(startup_buts, VALUE='Start playing automatically', $
                  EVENT_PRO='CRISPEX_PREFERENCES_SET_AUTOPLAY')
	(*(*info).ctrlspref).displays_phislice = $
                    WIDGET_BUTTON(startup_buts, $
                      VALUE='Automatically update spectral Phi-slice '+$
                      '(may impact performance)', $
                      EVENT_PRO='CRISPEX_PREFERENCES_SET_PHISLICE_UPDATE')
  ; Set buttons according to preferences	
  WIDGET_CONTROL, (*(*info).ctrlspref).startup_win, SET_BUTTON=(*(*info).prefs).startupwin
	WIDGET_CONTROL, (*(*info).ctrlspref).startup_autopl, SET_BUTTON=(*(*info).prefs).autoplay
	WIDGET_CONTROL, (*(*info).ctrlspref).displays_phislice, $
    SET_BUTTON=(*(*info).dispparams).phislice_update

  ; Displays preferences
	layout_base   	= WIDGET_BASE(tab_tlb, TITLE='Layout', /COLUMN, XSIZE=tab_width);, /FRAME)
	displays_buts 	= WIDGET_BASE(layout_base, /GRID_LAYOUT, COLUMN=2)
	(*(*info).prefs).bgplotcol_old = (*(*info).plotparams).bgplotcol
	(*(*info).ctrlspref).displays_bgcols = $
                    WIDGET_SLIDER(displays_buts, TITLE='Default background plot color', $
                      MIN=0, MAX=255, VALUE=(*(*info).plotparams).bgplotcol, /DRAG, $
		                  EVENT_PRO='CRISPEX_PREFERENCES_SET_BGPLOTCOL', $
                      XSIZE=FLOOR((tab_width-3*pad)/2.))
	(*(*info).ctrlspref).displays_plcols = $
                    WIDGET_SLIDER(displays_buts, TITLE='Default line plot color', $
                      MIN=0, MAX=255, VALUE=(*(*info).plotparams).plotcol, /DRAG, $
                      EVENT_PRO='CRISPEX_PREFERENCES_SET_PLOTCOL')
	displays_int_base = WIDGET_BASE(layout_base, /ROW, /NONEXCLUSIVE)
	(*(*info).ctrlspref).displays_interp = $
                    WIDGET_BUTTON(displays_int_base, VALUE='Interpolate spectral slices',$
                      EVENT_PRO='CRISPEX_PREFERENCES_SET_INTERPOLATE')
	displays_preview= WIDGET_BUTTON(displays_int_base, VALUE='Preview changes', $
                      EVENT_PRO='CRISPEX_PREFERENCES_SET_PREVIEW')
  displays_divider= CRISPEX_WIDGET_DIVIDER(layout_base)
  displays_off_base= WIDGET_BASE(layout_base, /ROW, /NONEXCLUSIVE)
  (*(*info).ctrlspref).displays_offsets = $
                     WIDGET_BUTTON(displays_off_base, VALUE='Use current '+$
                      'window offsets as default', $
                      EVENT_PRO='CRISPEX_PREFERENCES_SET_OFFSETS')
  WIDGET_CONTROL, (*(*info).ctrlspref).displays_offsets, $
    SET_BUTTON=(*(*info).prefs).current_offsets

  scaling_base    = WIDGET_BASE(tab_tlb, TITLE='Scaling', /COLUMN, XSIZE=tab_width);, /FRAME)
  histo_base      = WIDGET_BASE(scaling_base, /ROW)
  histo_opt_lab   = WIDGET_LABEL(histo_base, VALUE='Default histogram optimisation value:', /ALIGN_LEFT)
  (*(*info).ctrlspref).histo_opt_txt = $
                    WIDGET_TEXT(histo_base, VALUE=STRTRIM((*(*info).prefs).histo_opt_val,2), $
                      /EDITABLE, XSIZE=11, EVENT_PRO='CRISPEX_PREFERENCES_SET_SCALING_HISTO_OPT')
  (*(*info).ctrlspref).gamma_label = $
                    WIDGET_LABEL(scaling_base, VALUE=STRING((*(*info).prefs).gamma_val, $
                      FORMAT='(F6.3)'), /ALIGN_CENTER)
  (*(*info).ctrlspref).gamma_slid = $
                    WIDGET_SLIDER(scaling_base, TITLE='Default gamma', MIN=0, MAX=1000, $
                      VALUE=500*(ALOG10((*(*info).prefs).gamma_val)+1), $
                      EVENT_PRO='CRISPEX_PREFERENCES_SET_SCALING_GAMMA', /SUPPRESS, /DRAG)
	displays_opts	  = WIDGET_BASE(scaling_base, /COLUMN, /NONEXCLUSIVE)
	(*(*info).ctrlspref).displays_slices = $
                    WIDGET_BUTTON(displays_opts, $
                      VALUE='Scale slices according main/reference image', $
                      EVENT_PRO='CRISPEX_PREFERENCES_SET_SLICES_IMSCALE')
  ; Set buttons according to settings
	(*(*info).prefs).plotcol_old = (*(*info).plotparams).plotcol
	(*(*info).prefs).interpspslice_old = (*(*info).dispparams).interpspslice
	WIDGET_CONTROL, (*(*info).ctrlspref).displays_interp, $
    SET_BUTTON=(*(*info).dispparams).interpspslice
	WIDGET_CONTROL, displays_preview, SET_BUTTON=(*(*info).prefs).preview
	WIDGET_CONTROL, (*(*info).ctrlspref).displays_slices, $
    SET_BUTTON=(*(*info).dispparams).slices_imscale

  ; IO preferences: inputs
  paths_base      = WIDGET_BASE(tab_tlb, TITLE='Input/Output', /COLUMN, XSIZE=tab_width);, /FRAME)
	paths_io_base	  = WIDGET_BASE(paths_base, /COLUMN)
	paths_i_labbuts = WIDGET_BASE(paths_io_base, /ROW)
	paths_i_lab	    = WIDGET_LABEL(paths_i_labbuts, VALUE = 'Default input path:')
	paths_i_buts	  = WIDGET_BASE(paths_i_labbuts, /ROW, /EXCLUSIVE)
	(*(*info).ctrlspref).paths_i_def_but = $
                    WIDGET_BUTTON(paths_i_buts, VALUE='Local working directory', $
                      EVENT_PRO='CRISPEX_PREFERENCES_SET_IPATH_SEL_DEFAULT', /NO_RELEASE)
	(*(*info).ctrlspref).paths_i_sav_but = $
                    WIDGET_BUTTON(paths_i_buts, VALUE='Other directory', $
                      EVENT_PRO='CRISPEX_PREFERENCES_SET_IPATH_SEL_OTHER', /NO_RELEASE)
	(*(*info).ctrlspref).paths_ipath_text = $
                    WIDGET_TEXT(paths_io_base, VALUE=(*(*info).prefs).prefipath, /EDITABLE,$
                      EVENT_PRO='CRISPEX_PREFERENCES_SET_IPATH_OTHER', $
                      SENSITIVE=(*(*info).prefs).defipath)
  ; Set buttons according to settings
	WIDGET_CONTROL, (*(*info).ctrlspref).paths_i_def_but, $
    SET_BUTTON=ABS((*(*info).prefs).defipath-1)
	WIDGET_CONTROL, (*(*info).ctrlspref).paths_i_sav_but, $
    SET_BUTTON=(*(*info).prefs).defipath
  ; IO preferences: outputs
	paths_o_labbuts = WIDGET_BASE(paths_io_base, /ROW)
	paths_o_lab	    = WIDGET_LABEL(paths_o_labbuts, VALUE = 'Default output path:')
	paths_o_buts	  = WIDGET_BASE(paths_o_labbuts, /ROW, /EXCLUSIVE)
	(*(*info).ctrlspref).paths_o_def_but = $
                    WIDGET_BUTTON(paths_o_buts, VALUE='Local working directory', $
                      EVENT_PRO='CRISPEX_PREFERENCES_SET_OPATH_SEL_DEFAULT', /NO_RELEASE)
	(*(*info).ctrlspref).paths_o_sav_but = $
                    WIDGET_BUTTON(paths_o_buts, VALUE='Other directory', $
                      EVENT_PRO='CRISPEX_PREFERENCES_SET_OPATH_SEL_OTHER', /NO_RELEASE)
	(*(*info).ctrlspref).paths_opath_text = $
                    WIDGET_TEXT(paths_io_base, VALUE=(*(*info).prefs).prefopath, /EDITABLE,$
                      EVENT_PRO='CRISPEX_PREFERENCES_SET_OPATH_OTHER', $
                      SENSITIVE=(*(*info).prefs).defopath)
	(*(*info).ctrlspref).paths_iopath = $
                    WIDGET_BUTTON(paths_base, VALUE='Set output path to input path', $
                      EVENT_PRO='CRISPEX_PREFERENCES_SET_IOPATH', $
                      SENSITIVE=((*(*info).prefs).prefipath NE (*(*info).prefs).prefopath))
  ; Set buttons according to settings
	WIDGET_CONTROL, (*(*info).ctrlspref).paths_o_def_but, $
    SET_BUTTON=ABS((*(*info).prefs).defopath-1)
	WIDGET_CONTROL, (*(*info).ctrlspref).paths_o_sav_but, $
    SET_BUTTON=(*(*info).prefs).defopath
  ; File-ID
	save_base	      = WIDGET_BASE(tab_tlb, TITLE='Filenaming', /COLUMN, XSIZE=tab_width);, /FRAME)
	saveid_buts 	  = WIDGET_BASE(save_base, /ROW)
	saveid_lab	    = WIDGET_LABEL(saveid_buts, VALUE='Default unique file ID:', /ALIGN_LEFT)
	saveids	= ['YYYYMMMDD_hhmmss (default)','DDMMMYYYY_hhmmss', $
              'YYYYMMDD_hhmmss','DDMMYYYY_hhmmss']
	(*(*info).ctrlspref).save_defsaveid = $
                    WIDGET_COMBOBOX(saveid_buts, VALUE=saveids, /DYNAMIC_RESIZE, $
                      EVENT_PRO='CRISPEX_PREFERENCES_SET_SAVEID')
	CRISPEX_SAVE_DETERMINE_SAVEID, event, defsaveid_sample, /PREF
	saveid_sample	  = WIDGET_BASE(save_base, /ROW)
	saveid_sample_lab = WIDGET_LABEL(saveid_sample, VALUE = 'Example:')
	(*(*info).ctrlspref).save_defsaveid_sample = $
                    WIDGET_LABEL(saveid_sample, VALUE=defsaveid_sample, /DYNAMIC_RESIZE)
	WIDGET_CONTROL, (*(*info).ctrlspref).save_defsaveid, $
    SET_COMBOBOX_SELECT=(*(*info).prefs).defsaveid

  ; Messages
  messages_base = WIDGET_BASE(tab_tlb, TITLE='Messages', /COLUMN, XSIZE=tab_width)
  warn_cbox_base = WIDGET_BASE(messages_base, /ROW)
  warnings_lab  = WIDGET_LABEL(warn_cbox_base, VALUE='Display set-up warnings:', $
                    /ALIGN_LEFT)
  warnings_desc =['Do not show messages',$
                  'Write messages to terminal only',$
                  'Always pop-up messages']
  (*(*info).ctrlspref).warnings_cbox = WIDGET_COMBOBOX(warn_cbox_base, VALUE=warnings_desc, $
                    EVENT_PRO='CRISPEX_PREFERENCES_SET_WARNINGS_SETUP')
  WIDGET_CONTROL, (*(*info).ctrlspref).warnings_cbox, SET_COMBOBOX_SELECT=(*(*info).prefs).warnings

  ; Defaults / Cancel / Accept settings buttons
	dec_buts 	      = WIDGET_BASE(main, /ALIGN_CENTER, /GRID_LAYOUT, COLUMN=3)
	(*(*info).ctrlspref).set_defaults	= $
                    WIDGET_BUTTON(dec_buts, VALUE='Default settings', $
                      EVENT_PRO='CRISPEX_PREFERENCES_SET_DEFAULTS', SENSITIVE=nondefault)
	CRISPEX_PREFERENCES_CHECK_DEFAULT_BUTTON, event
	cancel 		      = WIDGET_BUTTON(dec_buts, VALUE='Cancel', $
                      EVENT_PRO='CRISPEX_PREFERENCES_CANCEL')
	save_settings 	= WIDGET_BUTTON(dec_buts, VALUE='Save settings', $
                      EVENT_PRO='CRISPEX_PREFERENCES_SAVE_SETTINGS')

  ; Realize widget window
	WIDGET_CONTROL, base, /REALIZE, TLB_SET_XOFFSET=(*(*info).winsizes).aboutxoffset, $
    TLB_SET_YOFFSET=(*(*info).winsizes).aboutyoffset
	WIDGET_CONTROL, base, SET_UVALUE=info
	XMANAGER, 'CRISPEX', base, /NO_BLOCK
	(*(*info).winids).preftlb = base
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).winids).preftlb], labels=['preftlb']
END

PRO CRISPEX_PREFERENCES_CHECK_DEFAULT_BUTTON, event
; Handles the checking whether preference buttons and values are in their default position
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (((*(*info).prefs).tmp_autoplay NE (*(*info).prefs).default_autoplay) OR $
		((*(*info).prefs).tmp_startupwin NE (*(*info).prefs).default_startupwin) OR $
		((*(*info).prefs).tmp_bgplotcol NE (*(*info).prefs).default_bgplotcol) OR $
		((*(*info).prefs).tmp_plotcol NE (*(*info).prefs).default_plotcol) OR $
		((*(*info).prefs).current_offsets NE 0) OR $
		((*(*info).prefs).tmp_interpspslice NE (*(*info).prefs).default_interpspslice) OR $
		((*(*info).prefs).tmp_slices_imscale NE (*(*info).prefs).default_slices_imscale) OR $			
		((*(*info).prefs).tmp_histo_opt_val NE (*(*info).prefs).default_histo_opt_val) OR $			
		((*(*info).prefs).tmp_gamma_val NE (*(*info).prefs).default_gamma_val) OR $			
		((*(*info).prefs).tmp_phislice_update NE (*(*info).prefs).default_phislice_update) OR $			
		((*(*info).prefs).tmp_defipath NE (*(*info).prefs).default_defipath) OR $
		((*(*info).prefs).tmp_prefipath NE (*(*info).prefs).default_prefipath) OR $
		((*(*info).prefs).tmp_defopath NE (*(*info).prefs).default_defopath) OR $
		((*(*info).prefs).tmp_prefopath NE (*(*info).prefs).default_prefopath) OR $
		((*(*info).prefs).tmp_defsaveid NE (*(*info).prefs).default_defsaveid) OR $
		((*(*info).prefs).tmp_warnings NE (*(*info).prefs).default_warnings)) THEN $
      nondefault = 1 $
    ELSE $
      nondefault = 0
	WIDGET_CONTROL, (*(*info).ctrlspref).set_defaults, SENSITIVE=nondefault
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [ABS(nondefault-1)], labels=['Buttons on default']
END

PRO CRISPEX_PREFERENCES_SET_STARTUPWIN, event
; Handles the toggle on/off setting of start-up window
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).prefs).tmp_startupwin = event.SELECT
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).prefs).tmp_startupwin], labels=['Startup window']
	CRISPEX_PREFERENCES_CHECK_DEFAULT_BUTTON, event
END

PRO CRISPEX_PREFERENCES_SET_AUTOPLAY, event
; Handles the toggle on/off setting of autoplay at start-up
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).prefs).tmp_autoplay = event.SELECT
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).prefs).tmp_autoplay], labels=['Autoplay']
	CRISPEX_PREFERENCES_CHECK_DEFAULT_BUTTON, event
END

PRO CRISPEX_PREFERENCES_SET_BGPLOTCOL, event
; Handles the setting of the background plot color
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).prefs).tmp_bgplotcol = event.VALUE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).prefs).tmp_bgplotcol], labels=['Background color']
	CRISPEX_PREFERENCES_CHECK_DEFAULT_BUTTON, event
	IF (*(*info).prefs).preview THEN BEGIN
		(*(*info).plotparams).bgplotcol = (*(*info).prefs).tmp_bgplotcol
		CRISPEX_PREFERENCES_REDRAW, event
	ENDIF
END

PRO CRISPEX_PREFERENCES_SET_PHISLICE_UPDATE, event									
; Handles the toggle on/off live update of spectral phi-slice
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).prefs).tmp_phislice_update = event.SELECT
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).prefs).tmp_phislice_update], labels=['Live update spectral Phi-slice']
	CRISPEX_PREFERENCES_CHECK_DEFAULT_BUTTON, event
END

PRO CRISPEX_PREFERENCES_SET_PLOTCOL, event
; Handles the setting of the line plot color
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).prefs).tmp_plotcol = event.VALUE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).prefs).tmp_plotcol], labels=['Plot color']
	CRISPEX_PREFERENCES_CHECK_DEFAULT_BUTTON, event
	IF (*(*info).prefs).preview THEN BEGIN
		(*(*info).plotparams).plotcol = (*(*info).prefs).tmp_plotcol
		CRISPEX_PREFERENCES_REDRAW, event
	ENDIF
END

PRO CRISPEX_PREFERENCES_SET_SLICES_IMSCALE, event									
; Handles the toggle on/off scaling of slices according to main/reference image scaling
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).prefs).tmp_slices_imscale = event.SELECT
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).prefs).tmp_slices_imscale], $
      labels=['Scale slices with main/reference image']
	CRISPEX_PREFERENCES_CHECK_DEFAULT_BUTTON, event
END

PRO CRISPEX_PREFERENCES_SET_SCALING_HISTO_OPT, event
; Handles setting the default histrogram optimisation value
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, (*(*info).ctrlspref).histo_opt_txt, GET_VALUE = textvalue
	(*(*info).prefs).tmp_histo_opt_val = textvalue[0]
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).prefs).tmp_histo_opt_val], $
      labels=['Histogram optimisation value']
	CRISPEX_PREFERENCES_CHECK_DEFAULT_BUTTON, event
END

PRO CRISPEX_PREFERENCES_SET_SCALING_GAMMA, event
; Handles setting the default histrogram optimisation value
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  (*(*info).prefs).tmp_gamma_val = 10.^((FLOAT(event.VALUE)/500.) - 1.)
  WIDGET_CONTROL, (*(*info).ctrlspref).gamma_label, $
    SET_VALUE=STRING((*(*info).prefs).tmp_gamma_val,FORMAT='(F6.3)')
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).prefs).tmp_gamma_val], $
      labels=['Gamma']
	CRISPEX_PREFERENCES_CHECK_DEFAULT_BUTTON, event
END

PRO CRISPEX_PREFERENCES_SET_INTERPOLATE, event
; Handles the toggle on/off setting of interpolating the spectral slices
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).prefs).tmp_interpspslice = event.SELECT
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).prefs).tmp_interpspslice], labels=['Interpolate']
	CRISPEX_PREFERENCES_CHECK_DEFAULT_BUTTON, event
	IF (*(*info).prefs).preview THEN BEGIN
		(*(*info).dispparams).interpspslice = (*(*info).prefs).tmp_interpspslice
		CRISPEX_PREFERENCES_REDRAW, event
	ENDIF
END

PRO CRISPEX_PREFERENCES_SET_IPATH_SEL_DEFAULT, event
; Handles the toggle on/off selection of the default input path
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).prefs).tmp_defipath = ABS(event.SELECT-1)
	(*(*info).prefs).tmp_prefipath = (*(*info).prefs).default_prefipath
	WIDGET_CONTROL, (*(*info).ctrlspref).paths_ipath_text, SET_VALUE = (*(*info).prefs).default_prefipath, SENSITIVE = (*(*info).prefs).tmp_defipath
	WIDGET_CONTROL, (*(*info).ctrlspref).paths_iopath, SENSITIVE = ((*(*info).prefs).tmp_prefopath NE (*(*info).prefs).tmp_prefipath)
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [STRTRIM(event.SELECT,2),(*(*info).prefs).tmp_prefipath], labels=['Default input path set','Input path']
	CRISPEX_PREFERENCES_CHECK_DEFAULT_BUTTON, event
END

PRO CRISPEX_PREFERENCES_SET_IPATH_SEL_OTHER, event
; Handles the toggle on/off selection of different input path
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).prefs).tmp_defipath = event.SELECT
	IF (*(*info).prefs).tmp_defipath THEN BEGIN
		IF ((*(*info).prefs).tmp_prefipath NE (*(*info).paths).ipath) THEN (*(*info).prefs).tmp_prefipath = (*(*info).paths).ipath
		WIDGET_CONTROL, (*(*info).ctrlspref).paths_ipath_text, SET_VALUE = (*(*info).prefs).tmp_prefipath, SENSITIVE = (*(*info).prefs).tmp_defipath
		CRISPEX_SAVE_SET_IPATH, event
		WIDGET_CONTROL, (*(*info).ctrlspref).paths_ipath_text, SET_VALUE = (*(*info).prefs).tmp_prefipath
	ENDIF
	WIDGET_CONTROL, (*(*info).ctrlspref).paths_iopath, SENSITIVE = ((*(*info).prefs).tmp_prefopath NE (*(*info).prefs).tmp_prefipath)
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [STRTRIM(ABS(event.SELECT-1),2),(*(*info).prefs).tmp_prefipath], labels=['Default input path set','Input path']
	CRISPEX_PREFERENCES_CHECK_DEFAULT_BUTTON, event
END

PRO CRISPEX_PREFERENCES_SET_IPATH_OTHER, event
; Handles the setting of the input path
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, (*(*info).ctrlspref).paths_ipath_text, GET_VALUE = textvalue
	(*(*info).prefs).tmp_prefipath = textvalue[0]
	WIDGET_CONTROL, (*(*info).ctrlspref).paths_iopath, SENSITIVE = ((*(*info).prefs).tmp_prefopath NE (*(*info).prefs).tmp_prefipath)
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).prefs).tmp_prefipath], labels=['Input path']
	CRISPEX_PREFERENCES_CHECK_DEFAULT_BUTTON, event
END

PRO CRISPEX_PREFERENCES_SET_OPATH_SEL_DEFAULT, event
; Handles the toggle on/off selection of the default output path
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).prefs).tmp_defopath = ABS(event.SELECT-1)
	(*(*info).prefs).tmp_prefopath = (*(*info).prefs).default_prefopath
	WIDGET_CONTROL, (*(*info).ctrlspref).paths_opath_text, SET_VALUE = (*(*info).prefs).default_prefopath, SENSITIVE = (*(*info).prefs).tmp_defopath
	WIDGET_CONTROL, (*(*info).ctrlspref).paths_iopath, SENSITIVE = ((*(*info).prefs).tmp_prefopath NE (*(*info).prefs).tmp_prefipath)
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [STRTRIM(event.SELECT,2),(*(*info).prefs).tmp_prefopath], labels=['Default output path set','Output path']
	CRISPEX_PREFERENCES_CHECK_DEFAULT_BUTTON, event
END

PRO CRISPEX_PREFERENCES_SET_OPATH_SEL_OTHER, event
; Handles the toggle on/off selection of different output path
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).prefs).tmp_defopath = event.SELECT
	IF (*(*info).prefs).tmp_defopath THEN BEGIN
		IF ((*(*info).prefs).tmp_prefopath NE (*(*info).paths).opath) THEN (*(*info).prefs).tmp_prefopath = (*(*info).paths).opath
		WIDGET_CONTROL, (*(*info).ctrlspref).paths_opath_text, SET_VALUE = (*(*info).prefs).tmp_prefopath, SENSITIVE = (*(*info).prefs).tmp_defopath
		CRISPEX_SAVE_SET_OPATH, event
		WIDGET_CONTROL, (*(*info).ctrlspref).paths_opath_text, SET_VALUE = (*(*info).prefs).tmp_prefopath
	ENDIF
	WIDGET_CONTROL, (*(*info).ctrlspref).paths_iopath, SENSITIVE = ((*(*info).prefs).tmp_prefopath NE (*(*info).prefs).tmp_prefipath)
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [STRTRIM(ABS(event.SELECT-1),2),(*(*info).prefs).tmp_prefopath], labels=['Default output path set','Output path']
	CRISPEX_PREFERENCES_CHECK_DEFAULT_BUTTON, event
END

PRO CRISPEX_PREFERENCES_SET_OPATH_OTHER, event
; Handles the setting of the output path
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, (*(*info).ctrlspref).paths_opath_text, GET_VALUE = textvalue
	(*(*info).prefs).tmp_prefopath = textvalue[0]
	WIDGET_CONTROL, (*(*info).ctrlspref).paths_iopath, SENSITIVE = ((*(*info).prefs).tmp_prefopath NE (*(*info).prefs).tmp_prefipath)
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).prefs).tmp_prefopath], labels=['Output path']
	CRISPEX_PREFERENCES_CHECK_DEFAULT_BUTTON, event
END

PRO CRISPEX_PREFERENCES_SET_IOPATH, event
; Handles the setting of the output path to the input path
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).prefs).tmp_prefopath = (*(*info).prefs).tmp_prefipath
	(*(*info).prefs).tmp_defopath = (*(*info).prefs).tmp_defipath
	WIDGET_CONTROL, (*(*info).ctrlspref).paths_o_def_but, SET_BUTTON = ABS((*(*info).prefs).tmp_defopath-1)
	WIDGET_CONTROL, (*(*info).ctrlspref).paths_o_sav_but, SET_BUTTON = (*(*info).prefs).tmp_defopath
	WIDGET_CONTROL, (*(*info).ctrlspref).paths_opath_text, SET_VALUE = (*(*info).prefs).tmp_prefopath, SENSITIVE = (*(*info).prefs).tmp_defopath
	WIDGET_CONTROL, (*(*info).ctrlspref).paths_iopath, SENSITIVE = 0
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [STRTRIM(ABS((*(*info).prefs).tmp_defipath-1),2),(*(*info).prefs).tmp_prefipath,STRTRIM(ABS((*(*info).prefs).tmp_defopath-1),2),$
		(*(*info).prefs).tmp_prefopath], labels=['Default input path set','Input path','Default output path set','Output path']
	CRISPEX_PREFERENCES_CHECK_DEFAULT_BUTTON, event
END

PRO CRISPEX_PREFERENCES_SET_PREVIEW, event
; Handles the enabling of preview mode
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).prefs).preview = event.SELECT
	IF (*(*info).prefs).preview THEN BEGIN
		(*(*info).plotparams).plotcol = (*(*info).prefs).tmp_plotcol		&	(*(*info).plotparams).bgplotcol = (*(*info).prefs).tmp_bgplotcol
		(*(*info).dispparams).interpspslice = (*(*info).prefs).tmp_interpspslice
	ENDIF ELSE BEGIN
		(*(*info).plotparams).plotcol = (*(*info).prefs).plotcol_old		& 	(*(*info).plotparams).bgplotcol = (*(*info).prefs).bgplotcol_old
		(*(*info).dispparams).interpspslice = (*(*info).prefs).interpspslice_old
	ENDELSE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).prefs).preview], labels=['Preview']
	CRISPEX_PREFERENCES_REDRAW, event
END

PRO CRISPEX_PREFERENCES_SET_OFFSETS, event
; Handles the use of current window offsets
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).prefs).current_offsets = event.SELECT
END

PRO CRISPEX_PREFERENCES_SET_SAVEID, event
; Handles the setting of unique save ID
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).prefs).tmp_defsaveid = event.INDEX
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).prefs).tmp_defsaveid], labels=['Default save ID']
	CRISPEX_SAVE_DETERMINE_SAVEID, event, defsaveid_sample, /PREF
	WIDGET_CONTROL, (*(*info).ctrlspref).save_defsaveid_sample, SET_VALUE = defsaveid_sample
	CRISPEX_PREFERENCES_CHECK_DEFAULT_BUTTON, event
END

PRO CRISPEX_PREFERENCES_SET_WARNINGS_SETUP, event
; Handles setting of warnings
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  (*(*info).prefs).tmp_warnings = event.INDEX 
	IF (event.TOP EQ (*(*info).winids).preftlb) THEN $
	  CRISPEX_PREFERENCES_CHECK_DEFAULT_BUTTON, event $
  ELSE $
    CRISPEX_PREFERENCES_SAVE_SETTINGS, event, /RESAVE
END

PRO CRISPEX_PREFERENCES_SET_DEFAULTS, event
; Handles the setting of all defaults
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).prefs).tmp_startupwin = (*(*info).prefs).default_startupwin
  (*(*info).prefs).tmp_interpspslice = (*(*info).prefs).default_interpspslice
	(*(*info).prefs).tmp_autoplay = (*(*info).prefs).default_autoplay
  (*(*info).prefs).tmp_defsaveid = (*(*info).prefs).default_defsaveid
	(*(*info).prefs).tmp_defipath = (*(*info).prefs).default_defipath
  (*(*info).prefs).tmp_prefipath = (*(*info).prefs).default_prefipath
	(*(*info).prefs).tmp_defopath = (*(*info).prefs).default_defopath
  (*(*info).prefs).tmp_prefopath = (*(*info).prefs).default_prefopath
	(*(*info).prefs).tmp_bgplotcol = (*(*info).prefs).default_bgplotcol
  (*(*info).prefs).tmp_plotcol = (*(*info).prefs).default_plotcol
  (*(*info).prefs).current_offsets = 0
	(*(*info).prefs).tmp_phislice_update = (*(*info).prefs).default_phislice_update
  (*(*info).prefs).tmp_slices_imscale = (*(*info).prefs).default_slices_imscale		
  (*(*info).prefs).tmp_histo_opt_val = (*(*info).prefs).default_histo_opt_val
  (*(*info).prefs).tmp_gamma_val = (*(*info).prefs).default_gamma_val
  (*(*info).prefs).tmp_warnings = (*(*info).prefs).default_warnings
	WIDGET_CONTROL, (*(*info).ctrlspref).startup_win, SET_BUTTON = (*(*info).prefs).tmp_startupwin
	WIDGET_CONTROL, (*(*info).ctrlspref).startup_autopl, SET_BUTTON = (*(*info).prefs).tmp_autoplay
	WIDGET_CONTROL, (*(*info).ctrlspref).displays_bgcols, SET_VALUE = (*(*info).prefs).tmp_bgplotcol
	WIDGET_CONTROL, (*(*info).ctrlspref).displays_plcols, SET_VALUE = (*(*info).prefs).tmp_plotcol
	WIDGET_CONTROL, (*(*info).ctrlspref).displays_interp, SET_BUTTON = (*(*info).prefs).tmp_interpspslice
	WIDGET_CONTROL, (*(*info).ctrlspref).displays_phislice, $
    SET_BUTTON = (*(*info).prefs).tmp_phislice_update		
	WIDGET_CONTROL, (*(*info).ctrlspref).displays_slices, SET_BUTTON = (*(*info).prefs).tmp_slices_imscale
  WIDGET_CONTROL, (*(*info).ctrlspref).displays_offsets, SET_BUTTON=0
	WIDGET_CONTROL, (*(*info).ctrlspref).histo_opt_txt, $
    SET_VALUE=STRTRIM((*(*info).prefs).tmp_histo_opt_val,2)
	WIDGET_CONTROL, (*(*info).ctrlspref).gamma_label, $
    SET_VALUE=STRING((*(*info).prefs).tmp_gamma_val, FORMAT='(F6.3)') 
	WIDGET_CONTROL, (*(*info).ctrlspref).gamma_slid, $
    SET_VALUE=(500*(ALOG10((*(*info).prefs).tmp_gamma_val)+1))
	WIDGET_CONTROL, (*(*info).ctrlspref).paths_i_def_but, SET_BUTTON = ABS((*(*info).prefs).tmp_defipath-1)
	WIDGET_CONTROL, (*(*info).ctrlspref).paths_i_sav_but, SET_BUTTON = (*(*info).prefs).tmp_defipath
	WIDGET_CONTROL, (*(*info).ctrlspref).paths_ipath_text, $
    SET_VALUE = (*(*info).prefs).tmp_prefipath, SENSITIVE = (*(*info).prefs).tmp_defipath
	WIDGET_CONTROL, (*(*info).ctrlspref).paths_o_def_but, SET_BUTTON = ABS((*(*info).prefs).tmp_defopath-1)
	WIDGET_CONTROL, (*(*info).ctrlspref).paths_o_sav_but, SET_BUTTON = (*(*info).prefs).tmp_defopath
	WIDGET_CONTROL, (*(*info).ctrlspref).paths_opath_text, $
    SET_VALUE = (*(*info).prefs).tmp_prefopath, SENSITIVE = (*(*info).prefs).tmp_defopath
	WIDGET_CONTROL, (*(*info).ctrlspref).paths_iopath, SENSITIVE = 0
	WIDGET_CONTROL, (*(*info).ctrlspref).save_defsaveid, $
    SET_COMBOBOX_SELECT = (*(*info).prefs).tmp_defsaveid
	CRISPEX_SAVE_DETERMINE_SAVEID, event, defsaveid_sample
	WIDGET_CONTROL, (*(*info).ctrlspref).save_defsaveid_sample, SET_VALUE = defsaveid_sample
  WIDGET_CONTROL, (*(*info).ctrlspref).warnings_cbox, SET_COMBOBOX_SELECT=(*(*info).prefs).warnings
	IF (*(*info).prefs).preview THEN BEGIN
		(*(*info).plotparams).plotcol = (*(*info).prefs).tmp_plotcol
		(*(*info).plotparams).bgplotcol = (*(*info).prefs).tmp_bgplotcol
		(*(*info).dispparams).interpspslice = (*(*info).prefs).tmp_interpspslice
		CRISPEX_PREFERENCES_REDRAW, event
	ENDIF
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [STRTRIM((*(*info).prefs).tmp_startupwin,2),STRTRIM((*(*info).prefs).tmp_autoplay,2),STRTRIM((*(*info).prefs).tmp_bgplotcol,2),$
		STRTRIM((*(*info).prefs).tmp_plotcol,2),STRTRIM((*(*info).prefs).tmp_interpspslice,2),STRTRIM((*(*info).prefs).preview,2),STRTRIM((*(*info).prefs).tmp_phislice_update,2),$
		STRTRIM((*(*info).prefs).tmp_slices_imscale,2),STRTRIM(ABS((*(*info).prefs).tmp_defipath-1),2),(*(*info).prefs).tmp_prefipath,STRTRIM(ABS((*(*info).prefs).tmp_defopath-1),2),$
		STRTRIM((*(*info).prefs).tmp_prefopath,2),STRTRIM((*(*info).prefs).tmp_defsaveid,2)], labels=['Startup window','Autoplay','Background color','Plot color',$
		'Interpolate','Preview','Update phi-slice','Scale slices','Default input path set','Input path','Default output path set','Output path','Default save ID']
	CRISPEX_PREFERENCES_CHECK_DEFAULT_BUTTON, event
END

PRO CRISPEX_PREFERENCES_SAVE_SETTINGS, event, RESAVE=resave
; Handles the saving of settings
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	CD, CURRENT=curpath
	IF (*(*info).prefs).tmp_defipath THEN BEGIN
		IF ((*(*info).prefs).tmp_prefipath EQ curpath) THEN (*(*info).prefs).tmp_defipath = 0
	ENDIF
	IF (*(*info).prefs).tmp_defopath THEN BEGIN
		IF ((*(*info).prefs).tmp_prefopath EQ curpath) THEN (*(*info).prefs).tmp_defopath = 0
	ENDIF
	curpath = curpath+PATH_SEP()
	startupwin = (*(*info).prefs).tmp_startupwin		&	interpspslice = (*(*info).prefs).tmp_interpspslice
	autoplay = (*(*info).prefs).tmp_autoplay		&	defsaveid = (*(*info).prefs).tmp_defsaveid
	defipath = (*(*info).prefs).tmp_defipath		&	prefipath = (*(*info).prefs).tmp_prefipath
	defopath = (*(*info).prefs).tmp_defopath		&	prefopath = (*(*info).prefs).tmp_prefopath
	bgplotcol = (*(*info).prefs).tmp_bgplotcol		&	plotcol = (*(*info).prefs).tmp_plotcol
	phislice_update = (*(*info).prefs).tmp_phislice_update	&	slices_imscale = (*(*info).prefs).tmp_slices_imscale	
  histo_opt_val = (*(*info).prefs).tmp_histo_opt_val
  gamma_val = (*(*info).prefs).tmp_gamma_val
  warnings = (*(*info).prefs).tmp_warnings
	crispex_version = [(*(*info).versioninfo).version_number, (*(*info).versioninfo).revision_number]
  ; Window offsets
  IF (*(*info).prefs).current_offsets THEN BEGIN
    CRISPEX_WINDOWS_GET_OFFSETS, event
    spxoffset = (*(*info).winsizes).spxoffset
    spyoffset = (*(*info).winsizes).spyoffset
    lsxoffset = (*(*info).winsizes).lsxoffset
    lsyoffset = (*(*info).winsizes).lsyoffset
    dopxoffset = (*(*info).winsizes).dopxoffset
    dopyoffset = (*(*info).winsizes).dopyoffset
    imrefxoffset = (*(*info).winsizes).imrefxoffset
    imrefyoffset = (*(*info).winsizes).imrefyoffset
    refxoffset = (*(*info).winsizes).refxoffset
    refyoffset = (*(*info).winsizes).refyoffset
    refspxoffset = (*(*info).winsizes).refspxoffset
    refspyoffset = (*(*info).winsizes).refspyoffset
    reflsxoffset = (*(*info).winsizes).reflsxoffset
    reflsyoffset = (*(*info).winsizes).reflsyoffset
    sjixoffset = (*(*info).winsizes).sjixoffset
    sjiyoffset = (*(*info).winsizes).sjiyoffset
    phisxoffset = (*(*info).winsizes).phisxoffset
    phisyoffset = (*(*info).winsizes).phisyoffset
    intxoffset = (*(*info).winsizes).intxoffset
    intyoffset = (*(*info).winsizes).intyoffset
    loopxoffset = (*(*info).winsizes).loopxoffset
    loopyoffset = (*(*info).winsizes).loopyoffset
    window_offsets = {set:1, spxoffset:spxoffset, spyoffset:spyoffset,$
      lsxoffset:lsxoffset, lsyoffset:lsyoffset, $
      dopxoffset:dopxoffset, dopyoffset:dopyoffset, $
      imrefxoffset:imrefxoffset, imrefyoffset:imrefyoffset, $
      refxoffset:refxoffset, refyoffset:refyoffset, $
      refspxoffset:refspxoffset, refspyoffset:refspyoffset, $
      reflsxoffset:reflsxoffset, reflsyoffset:reflsyoffset, $
      sjixoffset:sjixoffset, sjiyoffset:sjiyoffset, $
      phisxoffset:phisxoffset, phisyoffset:phisyoffset, $
      intxoffset:intxoffset, intyoffset:intyoffset, $
      loopxoffset:loopxoffset, loopyoffset:loopyoffset}
  ENDIF ELSE $
    window_offsets = {set:0}
	SAVE, crispex_version, startupwin, interpspslice, phislice_update, $
    slices_imscale, histo_opt_val,gamma_val, autoplay, defsaveid, defipath, $
    defopath, bgplotcol, plotcol, prefipath, prefopath, warnings, window_offsets, $
    FILENAME = (*(*info).paths).dir_settings+'crispex.cpref'
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).paths).dir_settings+'crispex.cpref'],labels=['Written']
	(*(*info).prefs).startupwin = startupwin		&	(*(*info).dispparams).interpspslice = interpspslice
	(*(*info).prefs).autoplay = autoplay			&	(*(*info).prefs).defsaveid = defsaveid
	(*(*info).prefs).defipath = defipath			&	(*(*info).prefs).defopath = defopath
	(*(*info).plotparams).bgplotcol = bgplotcol		&	(*(*info).plotparams).plotcol = plotcol
	(*(*info).prefs).prefipath = prefipath			&	(*(*info).paths).ipath = prefipath
	(*(*info).prefs).prefopath = prefopath			&	(*(*info).paths).opath = prefopath
	(*(*info).dispparams).phislice_update = phislice_update	&	(*(*info).dispparams).slices_imscale = slices_imscale	
  (*(*info).prefs).histo_opt_val = histo_opt_val
  (*(*info).prefs).gamma_val = gamma_val
  (*(*info).prefs).warnings = warnings
	IF ~KEYWORD_SET(RESAVE) THEN BEGIN
		CRISPEX_PREFERENCES_REDRAW, event
		WIDGET_CONTROL, (*(*info).winids).preftlb, /DESTROY
		(*(*info).winids).preftlb = 0
	ENDIF
END

PRO CRISPEX_PREFERENCES_CANCEL, event
; Handles the exiting from the preferences window
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (*(*info).prefs).preview THEN BEGIN
		(*(*info).plotparams).plotcol = (*(*info).prefs).plotcol_old		& 	(*(*info).plotparams).bgplotcol = (*(*info).prefs).bgplotcol_old
		(*(*info).dispparams).interpspslice = (*(*info).prefs).interpspslice_old
		CRISPEX_PREFERENCES_REDRAW, event
	ENDIF
	WIDGET_CONTROL, (*(*info).winids).preftlb, /DESTROY
	(*(*info).winids).preftlb = 0
END

PRO CRISPEX_PREFERENCES_REDRAW, event
; Handles the redrawing of plot windows in case the preview mode is set
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF ((*(*info).winids).sptlb NE 0) THEN CRISPEX_DISPLAYS_SP_REPLOT_AXES, event
	IF (TOTAL(*(*(*info).winids).restlooptlb) NE 0) THEN CRISPEX_DISPLAYS_RESTORE_LOOPSLAB_REPLOT_AXES, event
	IF ((*(*info).winids).retrdettlb NE 0) THEN CRISPEX_DISPLAYS_RETRIEVE_DET_LOOPSLAB_REPLOT_AXES, event
	IF ((*(*info).winids).looptlb NE 0) THEN CRISPEX_DISPLAYS_LOOPSLAB_REPLOT_AXES, event
	IF ((*(*info).winids).refsptlb NE 0) THEN CRISPEX_DISPLAYS_REFSP_REPLOT_AXES, event
	CRISPEX_DRAW_SPECTRAL, event
	CRISPEX_DRAW_TIMESLICES, event
	IF (*(*info).winswitch).showint THEN CRISPEX_DRAW_INT, event
END

;================================================================================= READ HEADER PROCEDURE
PRO CRISPEX_IO_PARSE_HEADER, filename, HDR_IN=hdr_in, HDR_OUT=hdr_out, $
                         IMCUBE=imcube, SPCUBE=spcube, REFIMCUBE=refimcube, REFSPCUBE=refspcube, $
                         SJICUBE=sjicube, MASKCUBE=maskcube, CUBE_COMPATIBILITY=cube_compatibility,$
                         EXTEN_NO=exten_no, SINGLE_CUBE=single_cube
; Handles read-in of file header, running different parsing depending on CUBE_COMPATIBILITY setting
  ; Start filling data header structure with header info from inputfile
  IF ~KEYWORD_SET(CUBE_COMPATIBILITY) THEN BEGIN
    offset = CRISPEX_FITSPOINTER(filename, EXTEN_NO=exten_no, header, /SILENT)   ; Get header offset to data
    CRISPEX_READ_FITSHEADER, header, key, filename, $                    ; Parse FITS header into key struct
      IMCUBE=imcube, SPCUBE=spcube, REFIMCUBE=refimcube, REFSPCUBE=refspcube, $
      SJICUBE=sjicube, VERBOSE=hdr_out.verbosity[1]
  ENDIF ELSE BEGIN
    offset = 512                                                ; Set header offset to data
    CRISPEX_READ_HEADER, filename, datatype=datatype, $         ; Parse old header into variables
                         dims=dims, nx=nx, ny=ny, nt=nt, endian=endian, stokes=stokes, ns=ns, $
                         diagnostics=diagnostics
  ENDELSE
  hdr_out = hdr_in                                              ; Set output hdr to output hdr
  IF KEYWORD_SET(IMCUBE) THEN BEGIN                             ; Fill hdr_out parameters for IMCUBE
    hdr_out.imoffset = offset
    IF ~KEYWORD_SET(CUBE_COMPATIBILITY) THEN BEGIN              ; In case of FITS cube
      hdr_out.imtype = key.datatype     &  hdr_out.imnt = key.nlp * key.nt * key.ns
      hdr_out.nx = key.nx               &  hdr_out.dx = key.dx
      hdr_out.ny = key.ny               &  hdr_out.dy = key.dy
      hdr_out.imns = key.ns             &  hdr_out.ns = key.ns
      hdr_out.nlp = key.nlp             &  hdr_out.mainnt = key.nt
      hdr_out.xpix = key.xpix           &  hdr_out.ypix = key.ypix
      hdr_out.xval = key.xval           &  hdr_out.yval = key.yval
      hdr_out.blabel = key.btype        &  hdr_out.bunit = key.bunit
      hdr_out.xlabel = key.xlab         &  hdr_out.xunit = key.xunit     
      hdr_out.ylabel = key.ylab         &  hdr_out.yunit = key.yunit
      hdr_out.tlabel = key.tlab         &  hdr_out.tunit = key.tunit
      hdr_out.lplabel = key.lplab       &  hdr_out.lpunit = key.lpunit
      hdr_out.dt = key.dt               &  hdr_out.single_cube = key.nlp
      hdr_out.wcs_set = key.wcs_set 
      wcs_main = key.wcs_str
      lc = key.lc
      hdr_out.obsid = STRTRIM(key.obsid,2)
      hdr_out.date_obs_main = key.date_obs
      utc_main = key.utc_sel
      utc_raster_main = key.utc_raster_sel
      hdr_out = CREATE_STRUCT(hdr_out, 'lps', key.lam, 'lc', lc)
      ; Handle spectral windows, if present
      hdr_out.ndiagnostics = key.ndiagnostics
      diagnostics = key.diagnostics
      wstart = key.wstart
      wwidth = key.wwidth
      twave = key.twave
      tarr_main = key.tarr_sel
      tarr_raster_main = key.tarr_raster
      toffset_main = key.tini_col
      headers = key.headers
    ENDIF ELSE BEGIN       ; In case of compatibility mode
      hdr_out.imtype = datatype         &  hdr_out.imendian = endian
      hdr_out.nx = nx                   &  hdr_out.dx = 0.0592
      hdr_out.ny = ny                   &  hdr_out.dy = 0.0592
      hdr_out.imns = ns                 &  hdr_out.ns = ns
      hdr_out.imstokes = stokes         &  hdr_out.imnt = nt
      ndiagnostics = N_ELEMENTS(diagnostics)
      CRISPEX_IO_PARSE_SINGLE_CUBE, single_cube, HDR_IN=hdr_out, $
        HDR_OUT=hdr_out,/MAIN
      IF (hdr_out.dt EQ 0) THEN $
        tarr_main = FINDGEN(hdr_out.mainnt) $
      ELSE $
        tarr_main = FINDGEN(hdr_out.mainnt) * hdr_out.dt
      tarr_raster_main = tarr_main
      utc_main = tarr_main
      utc_raster_main = tarr_raster_main
      toffset_main = 0
      IF (ndiagnostics GT 0) THEN BEGIN
        diagnostics = STRTRIM(STRSPLIT(STRMID(diagnostics,1,$
          STRLEN(diagnostics)-2),',',/EXTRACT),2)
        hdr_out.ndiagnostics = ndiagnostics
        wstart = INDGEN(ndiagnostics)
        wwidth = REPLICATE(1,ndiagnostics)
      ENDIF ELSE BEGIN
        wstart = 0
        wwidth = hdr_out.nlp
        hdr_out.ndiagnostics = 1
        diagnostics = 'CRISP'
      ENDELSE
      twave = 0
      headers = PTR_NEW('')
      wcs_main = 0
    ENDELSE
    hdr_out = CREATE_STRUCT(hdr_out, 'diagnostics', diagnostics, $
      'diag_start', wstart, 'diag_width', wwidth, 'tarr_main', tarr_main, $
      'tarr_raster_main', tarr_raster_main, 'toffset_main', toffset_main, $
      'twave', twave, 'hdrs_main', headers, 'wcs_main', wcs_main, $
      'utc_main', utc_main, 'utc_raster_main', utc_raster_main)
  ENDIF ELSE IF KEYWORD_SET(SPCUBE) THEN BEGIN                  ; Fill hdr parameters for SPCUBE
    hdr_out.spoffset = offset
    IF ~KEYWORD_SET(CUBE_COMPATIBILITY) THEN BEGIN              ; In case of FITS cube
      hdr_out.sptype = key.datatype     &  hdr_out.spnt = key.nx * key.ny * key.ns
      hdr_out.spns = key.ns
    ENDIF ELSE BEGIN                                            ; In case of compatibility mode
      hdr_out.sptype = datatype         &  hdr_out.spendian = endian
      hdr_out.nlp = nx                  &  hdr_out.mainnt = ny
      hdr_out.spns = ns                 &  hdr_out.spstokes = stokes
      hdr_out.spnt = nt
    ENDELSE
  ENDIF ELSE IF KEYWORD_SET(REFIMCUBE) THEN BEGIN               ; Fill hdr parameters for REFIMCUBE
    hdr_out.refimoffset = offset
    IF ~KEYWORD_SET(CUBE_COMPATIBILITY) THEN BEGIN              ; In case of FITS cube
      hdr_out.refimtype = key.datatype  &  hdr_out.refimnt = key.nlp * key.nt * key.ns
      hdr_out.refnx = key.nx            &  hdr_out.refdx = key.dx
      hdr_out.refny = key.ny            &  hdr_out.refdy = key.dy
      hdr_out.xpix_ref = key.xpix       &  hdr_out.ypix_ref = key.ypix
      hdr_out.xval_ref = key.xval       &  hdr_out.yval_ref = key.yval
      hdr_out.refnlp = key.nlp          &  hdr_out.refnt = key.nt
      hdr_out.refns = key.ns
      hdr_out.refbunit = key.bunit      &  hdr_out.refblabel = key.btype
      hdr_out.refxlabel = key.xlab      &  hdr_out.refxunit = key.xunit
      hdr_out.refylabel = key.ylab      &  hdr_out.refyunit = key.yunit
      hdr_out.reflplabel = key.lplab    &  hdr_out.reflpunit = key.lpunit
      hdr_out.ref_wcs_set = key.wcs_set
      wcs_ref = key.wcs_str
      reflc = key.lc
      hdr_out.date_obs_ref = STRTRIM(key.date_obs,2)
      utc_ref = key.utc_sel
      utc_raster_ref = key.utc_raster_sel
      hdr_out = CREATE_STRUCT(hdr_out, 'reflps', key.lam, 'reflc', reflc)
      ; Handle spectral windows, if present
      hdr_out.nrefdiagnostics = key.ndiagnostics
      diagnostics = key.diagnostics
      wstart = key.wstart
      wwidth = key.wwidth
      twave = key.twave
      tarr_ref = key.tarr_sel
      tarr_raster_ref = key.tarr_raster
      toffset_ref = key.tini_col
      headers = key.headers
    ENDIF ELSE BEGIN                                            
      ; In case of compatibility mode
      hdr_out.refimtype = datatype      &  hdr_out.refimendian = endian
      hdr_out.refnx = nx                &  hdr_out.refdx = 0.0592
      hdr_out.refny = ny                &  hdr_out.refdy = 0.0592
      hdr_out.refimnt = nt              &  hdr_out.refns = 1L
      IF (FLOOR(hdr_out.refimnt/FLOAT(hdr_out.mainnt)) EQ $
          hdr_out.refimnt/FLOAT(hdr_out.mainnt)) THEN $
        hdr_out.refnt = hdr_out.mainnt ELSE hdr_out.refnt = 1L
      hdr_out.refnlp = LONG(hdr_out.refimnt/FLOAT(hdr_out.refnt))
      CRISPEX_IO_PARSE_SINGLE_CUBE, single_cube, HDR_IN=hdr_out, $
        HDR_OUT=hdr_out,/REFERENCE
      IF (hdr_out.dt EQ 0) THEN $
        tarr_ref = FINDGEN(hdr_out.refnt) $
      ELSE $
        tarr_ref = FINDGEN(hdr_out.refnt) * hdr_out.dt
      tarr_raster_ref = tarr_ref
      utc_ref = tarr_ref
      utc_raster_ref = tarr_raster_ref
      toffset_ref = 0
      ndiagnostics = N_ELEMENTS(diagnostics)
      IF (ndiagnostics GT 0) THEN BEGIN
        diagnostics = STRTRIM(STRSPLIT(STRMID(diagnostics,1,$
          STRLEN(diagnostics)-2),',',/EXTRACT),2)
        hdr_out.nrefdiagnostics = ndiagnostics
        wstart = INDGEN(ndiagnostics)
        wwidth = REPLICATE(1,ndiagnostics)
      ENDIF ELSE BEGIN
        wstart = 0
        wwidth = hdr_out.refnlp
        hdr_out.nrefdiagnostics = 1
        diagnostics = 'CRISP'
      ENDELSE
      twave = 0
      headers = PTR_NEW('')
      wcs_ref = 0
    ENDELSE
    hdr_out = CREATE_STRUCT(hdr_out, 'refdiagnostics', diagnostics, $
      'refdiag_start', wstart, 'refdiag_width', wwidth, 'tarr_ref', tarr_ref, $
      'tarr_raster_ref', tarr_raster_ref, 'toffset_ref', toffset_ref, $
      'twave_ref', twave, 'hdrs_ref', headers, 'wcs_ref', wcs_ref, $
      'utc_ref', utc_ref, 'utc_raster_ref', utc_raster_ref)
  ENDIF ELSE IF KEYWORD_SET(REFSPCUBE) THEN BEGIN               ; Fill hdr parameters for REFSPCUBE
    hdr_out.refspoffset = offset
    IF ~KEYWORD_SET(CUBE_COMPATIBILITY) THEN BEGIN              ; In case of FITS cube
      hdr_out.refsptype = key.datatype  &  hdr_out.refspnt = key.nx * key.ny * key.ns
    ENDIF ELSE BEGIN                                            ; In case of compatibility mode
      hdr_out.refsptype = datatype      &  hdr_out.refspendian = endian
      hdr_out.refnlp = nx               &  hdr_out.refnt = ny
      hdr_out.refspnx = nx              &  hdr_out.refspny = ny
      hdr_out.refspnt = nt
    ENDELSE
  ENDIF ELSE IF KEYWORD_SET(SJICUBE) THEN BEGIN                ; Fill hdr parameters for SJICUBE
      hdr_out.sjioffset = offset
      hdr_out.sjitype = key.datatype    &  hdr_out.sjint = key.nt
      hdr_out.sjinx = key.nx            &  hdr_out.sjiny = key.ny
      hdr_out.sjidx = key.dx            &  hdr_out.sjidy = key.dy
      hdr_out.xpix_sji = key.xpix       &  hdr_out.ypix_sji = key.ypix
      hdr_out.xval_sji = key.xval       &  hdr_out.yval_sji = key.yval
      hdr_out.sjix0 = key.sjix0         &  hdr_out.sjiy0 = key.sjiy0
      hdr_out.sjibunit = key.bunit      &  headers = key.headers
      hdr_out.sjibscale = key.bscale    &  hdr_out.sjibzero = key.bzero
      hdr_out.sji_wcs_set = key.wcs_set
      ; Check for scaled integer
      hdr_out.sjiscaled = ((key.bscale NE 1.) AND (key.datatype EQ 2)) 
      hdr_out.date_obs_sji = STRTRIM(key.date_obs,2)
      hdr_out = CREATE_STRUCT(hdr_out, 'tarr_sji', key.tarr_sel, $
        'sjixoff', key.sjixoff, 'sjiyoff', key.sjiyoff, 'hdrs_sji', headers, $
        'wcs_sji', key.wcs_str, 'utc_sji', key.utc_sel) 
  ENDIF ELSE IF KEYWORD_SET(MASKCUBE) THEN BEGIN                
    ; Fill hdr parameters for MASKCUBE
    hdr_out.maskoffset = offset
    IF ~KEYWORD_SET(CUBE_COMPATIBILITY) THEN BEGIN              
      ; In case of FITS cube
      hdr_out.masktype = key.datatype   &  hdr_out.masknt = key.nt
      hdr_out.masknx = key.nx           &  hdr_out.maskny = key.ny
    ENDIF ELSE BEGIN                                            
      ; In case of compatibility mode
      hdr_out.masktype = datatype       &  hdr_out.maskendian = endian
      hdr_out.masknx = nx               &  hdr_out.maskny = ny
      hdr_out.masknt = nt
    ENDELSE
  ENDIF
END

PRO CRISPEX_READ_FITSHEADER, header, key, filename, $
  IMCUBE=imcube, SPCUBE=spcube, REFIMCUBE=refcube, REFSPCUBE=refspcube, $
  SJICUBE=sjicube, VERBOSE=verbose
; Handle parsing of FITS file header
; Based on earlier PARSEHEADER.PRO, modification history:
;   v1.1 21-Sep-2012 Viggo Hansteen - first version
;   v1.2 26-Jan-2013 Mats Carlsson - works for both Bifrost and Iris cubes
;   v1.3 13-Feb-2013 Mats Carlsson 
; Incorporated functionality into CRISPEX on 29-May-2013 and extended subsequently
  hdr1 = ''   ; initialise header placeholders
  hdr2 = ''
  ; Get number of data axes
  naxis = SXPAR(header,'NAXIS*')
  wcsaxes = SXPAR(header,'WCSAXES*')
  IF (wcsaxes EQ '') THEN wcsaxes = naxis
  ; Get number of extensions
  FITS_OPEN, filename, fcb
  next = fcb.nextend
  FITS_CLOSE, filename
  FREE_LUN, fcb.unit
  ; Determine cube type
  CASE (strsplit(SXPAR(header,'CTYPE2'),' ',/extract))[0] OF
    'y': sortorder = INDGEN(4)       ; CRISPEX imcube
    'HPLT-TAN': sortorder = INDGEN(3); IRIS SJI-file
    'time': sortorder = [2,3,0,1]    ; CRISPEX spcube
    'SolarY': sortorder = INDGEN(3)  ; Bifrost simcube
    ELSE: BEGIN
      MESSAGE,'Valid object not found! Correct fits file?',/cont
      key = {nx:-1}
      RETURN
    ENDELSE
  ENDCASE
  nx = naxis[sortorder[0]]
  ny = naxis[sortorder[1]]
  nlp = naxis[sortorder[2]]
  IF (N_ELEMENTS(naxis) EQ 4) THEN $
    nt = naxis[sortorder[3]] $
  ELSE $
    nt = 1
  ns = 1 ; number of Stokes posisitons
  cslab = [' ']
  ; Convert FITS datatype to IDL datatype
  CASE SXPAR(header,'BITPIX') OF
          8:      datatype = 1
         16:      datatype = 2  
         32:      datatype = 3  
        -32:      datatype = 4 
        -64:      datatype = 5 
          8:      datatype = 7
         16:      datatype = 12
         32:      datatype = 13
         64:      datatype = 14
          ELSE:   BEGIN
            MESSAGE,'ERROR: Illegal Image Datatype',/CONT
            datatype = -1
          ENDELSE
       endcase
  ; Read in header keywords      
  cdelt = SXPAR(header,'CDELT*')
  crpix = SXPAR(header,'CRPIX*')
  crval = SXPAR(header,'CRVAL*')
  ctype = SXPAR(header,'CTYPE*')
  cunit = SXPAR(header,'CUNIT*')
  btype = STRTRIM(SXPAR(header,'BTYPE'),2)
  bunit = STRTRIM(SXPAR(header,'BUNIT'))
  ; Get necessary info to process scaled data
  bscale= SXPAR(header,'BSCALE')
  bzero = SXPAR(header,'BZERO')
  ; Assign values to variables
  dx = cdelt[sortorder[0]]
  dy = cdelt[sortorder[1]]
  xpix = crpix[sortorder[0]]-1  ; Switch FITS->IDL pixel convention
  ypix = crpix[sortorder[1]]-1  ; Switch FITS->IDL pixel convention
  xval = crval[sortorder[0]]
  yval = crval[sortorder[1]]
  pc1 = SXPAR(header,'PC1_*')
  wcs_set = (pc1[0] NE 0.)
  IF wcs_set THEN BEGIN
    ; Functions using the wcs_str already take care of the FITS->IDL pixel
    ; convention switch
    wcs = FITSHEAD2WCS(header) 
    ; Grab the subset that only covers the first two dimensions
    wcs_str = {coord_type:wcs.coord_type, wcsname:wcs.wcsname, $
      naxis:wcs.naxis[0:1], variation:wcs.variation, compliant:wcs.compliant, $
      projection:wcs.projection, ix:wcs.ix, iy:wcs.iy, $
      crpix:wcs.crpix[0:1], crval:wcs.crval[0:1], ctype:wcs.ctype[0:1], $
      cname:wcs.cname[0:1], cunit:wcs.cunit[0:1], $
      cdelt:wcs.cdelt[0:1], pc:wcs.pc[0:1, 0:1], simple:wcs.simple, $
      time:wcs.time, position:wcs.position};, spectrum:wcs.spectrum}
  ENDIF ELSE $ 
    wcs_str = 0
  IF (N_ELEMENTS(naxis) EQ 4) THEN BEGIN
    dt = cdelt[sortorder[3]]
    tlab = STRTRIM(ctype[sortorder[3]],2)
    tunit = STRTRIM(cunit[sortorder[3]],2)
  ENDIF ELSE BEGIN
    dt = 0
    tlab = 't'
    tunit = 's' ; Assume default timing in seconds
  ENDELSE
  tini_col = 0    ; Default raster timing column
  IF ~KEYWORD_SET(SJICUBE) THEN BEGIN
    ; Get time array (assuming each raster is co-temporal)
    IF ((nt GE 1) AND (next GE 2)) THEN BEGIN
      tarr = READFITS(filename, hdr2, EXTEN_NO=2, SILENT=~KEYWORD_SET(VERBOSE))
      ntarrdims = SIZE(tarr,/N_DIMENSIONS)
      tarr_raster = tarr
      tval = SXPAR(header, 'CRVAL4')    ; tini_col = toffset_main/ref defaults to CRVAL4
      dum = MIN(ABS(tarr-tval),wheretval, /NAN)
      IF (wheretval EQ -1) THEN BEGIN
        nrasterpos = (SIZE(tarr))[ntarrdims-1]
        tini_col = FLOOR(nrasterpos/2.)
      ENDIF ELSE $
        tini_col = (ARRAY_INDICES(tarr,wheretval))[0]
      IF (ntarrdims EQ 2) THEN $
        tarr_sel = REFORM(tarr[tini_col,*]) $
      ELSE $
        tarr_sel = tarr
    ENDIF ELSE BEGIN
      tarr_sel = [0] 
      tarr_raster = 0
    ENDELSE
    sjixoff = 0
    sjiyoff = 0
    sjix0 = 0
    sjiy0 = 0
  ENDIF ELSE BEGIN
    ; Get timing array for the SJI cube
    offsetarray = READFITS(filename, hdr1, EXTEN_NO=1, SILENT=~KEYWORD_SET(VERBOSE))
    tarr_sel = REFORM(offsetarray[0,*]) ; TIME
    tarr_raster = tarr_sel
    sjixoff = REFORM(offsetarray[1,*])  ; PZTX
    sjiyoff = REFORM(offsetarray[2,*])  ; PZTY
    sjix0 = SXPAR(header, 'ROWSTAR')
    sjiy0 = SXPAR(header, 'COLSTAR')
    nt = naxis[sortorder[2]]
    tunit = STRTRIM(cunit[sortorder[2]],2)
  ENDELSE
  ; Determine tfactor and set time units to seconds
  common_tunit = [(tunit EQ 's'),(tunit EQ 'ms'),(tunit EQ 'hs')]
  where_common_tunit = WHERE(common_tunit EQ 1, count)
  IF (count GT 0) THEN $
    tfactor = ([1,0.001,100.])[where_common_tunit] $
  ELSE $
    tfactor = 1.
  tunit = 's'
  tarr_sel *= REPLICATE(tfactor,nt)     ; Get tarr_sel in seconds
  ; Failsafe against tarr_raster with nt unique values (instead of nt*nx)
  IF ((N_ELEMENTS(UNIQ(tarr_raster)) EQ nt) OR $
      (SIZE(tarr_raster,/N_DIMENSIONS) EQ 0)) THEN $
    tarr_raster = tarr_sel $
  ELSE IF (SIZE(tarr_raster,/N_DIMENSIONS) NE 0) THEN $
    tarr_raster *= REPLICATE(tfactor,(SIZE(tarr_raster))[1],nt) 
  ; Determine plot labels
  xlab = STRTRIM(ctype[sortorder[0]],2)
  ylab = STRTRIM(ctype[sortorder[1]],2)
  lplab = STRTRIM(ctype[sortorder[2]],2)
  xunit = STRTRIM(cunit[sortorder[0]],2)
  yunit = STRTRIM(cunit[sortorder[1]],2)
  lpunit = STRTRIM(cunit[sortorder[2]],2)
  ; Determine spectral parameters
  IF (N_PARAMS() EQ 3) THEN BEGIN
    lam = READFITS(filename,hdr1,EXTEN_NO=1,SILENT=~KEYWORD_SET(VERBOSE))
  ENDIF ELSE BEGIN
    lam = (FINDGEN(nlp)+1-crpix[sortorder[2]])*cdelt[sortorder[2]]+crval[sortorder[2]]
  ENDELSE
  lcval = crval[sortorder[2]]
  lc = (WHERE(lam EQ lcval, count))[0]
  IF (count NE 1) THEN lc = 0
  ; Determine number of diagnostics
  ndiagnostics = SXPAR(header,'NWIN')
  IF (ndiagnostics GT 0) THEN BEGIN
    wstart = SXPAR(header,'WSTART*')
    wwidth = SXPAR(header,'WWIDTH*')
    wdesc = SXPAR(header,'WDESC*')
    whereselect = WHERE(wdesc NE '', count)
    IF (count GT 0) THEN BEGIN
      wstart = wstart[whereselect]
      wwidth = wwidth[whereselect]
      diagnostics = wdesc[whereselect]
    ENDIF ELSE diagnostics = wdesc
  ENDIF ELSE BEGIN
    wstart = 0
    wwidth = nlp
    whereselect = 0
    ndiagnostics = 1
    diagnostics = btype
  ENDELSE
  twave = SXPAR(header,'TWAVE*')
  IF (count GT 0) THEN $
    twave  = twave[whereselect]
  ; Get third header too, even if not used in CRISPEX
  IF KEYWORD_SET(SJICUBE) THEN $
    dummy = READFITS(filename, hdr2, EXTEN_NO=2, SILENT=~KEYWORD_SET(VERBOSE))
  ; Initialise headers variable
  headers = [PTR_NEW(header),PTR_NEW(hdr1),PTR_NEW(hdr2)]
  ; Get OBSID and DATE_OBS
  obsid = SXPAR(header,'OBSID')
  date_obs = STRTRIM(SXPAR(header,'DATE_OBS'),2)
  ; IF DATE_OBS is set, derive the UTC (raster) time array
  IF (date_obs NE '0') THEN BEGIN
    utc_sel = STRARR(nt)
    ; Check for N_DIMENSIONS of tarr_raster
    IF (SIZE(tarr_raster, /N_DIMENSIONS) EQ 2) THEN $
      utc_raster_sel = STRARR(nx,nt) $
    ELSE BEGIN
      ; If N_DIMS!=2, then either:
      ; - IRIS sit-and-stare (nx=1,nt>1) 
      ; - non-raster time series (nx>1,nt>1)
      ; - IRIS single timestep (nx>1,nt=1)
      IF (nt GT 1) THEN $
        utc_raster_sel = STRARR(nt)  $
      ELSE $
        utc_raster_sel = STRARR(nx)
    ENDELSE
    orig_str = STR2UTC(date_obs)
    ; Loop over time
    FOR t=0,nt-1 DO BEGIN
      ; Create new main time structure and save time to utc_sel
      new_str = {mjd:orig_str.mjd, $
        time:(orig_str.time+LONG(tarr_sel[t]*1000*tfactor))}
      utc_sel[t] = UTC2STR(new_str, /TIME_ONLY)
      ; Do the same for the raster in case of N_DIMS=2
      IF (SIZE(tarr_raster, /N_DIMENSIONS) EQ 2) THEN BEGIN
        FOR x=0,nx-1 DO BEGIN
          new_str = {mjd:orig_str.mjd, time:(orig_str.time+$
            LONG(tarr_raster[x,t]*1000*tfactor))}
          utc_raster_sel[x,t] = UTC2STR(new_str, /TIME_ONLY)
        ENDFOR
      ENDIF ELSE BEGIN
        ; Alternatively, if nt>1, then nx=1 and set utc_raster_sel = utc_sel
        IF (nt GT 1) THEN $
          utc_raster_sel[t] = utc_sel[t] $
        ELSE BEGIN
        ; Else, if nt=1, then nx>1 and get utc_raster_sel for each slit pos
          FOR x=0,nx-1 DO BEGIN
            new_str = {mjd:orig_str.mjd, time:(orig_str.time+$
              LONG(tarr_raster[x]*1000*tfactor))}
            utc_raster_sel[x] = UTC2STR(new_str, /TIME_ONLY)
          ENDFOR
        ENDELSE
      ENDELSE
    ENDFOR
  ENDIF ELSE BEGIN
    utc_sel = tarr_sel
    utc_raster_sel = tarr_raster
  ENDELSE
  ;
  key = {nx:nx,ny:ny,nlp:nlp,nt:nt,ns:ns,cslab:cslab, $
       datatype:datatype,dx:dx,dy:dy,dt:dt,lam:lam,lc:lc, $
       xpix:xpix, ypix:ypix, xval:xval, yval:yval, $
       wcs_set:wcs_set, wcs_str:wcs_str, $
       tarr_sel:tarr_sel, tarr_raster:tarr_raster, tini_col:tini_col, $
       sjixoff:sjixoff, sjiyoff:sjiyoff, sjix0:sjix0, sjiy0:sjiy0, $
       xlab:xlab,ylab:ylab,lplab:lplab,tlab:tlab, $
       btype:btype,bunit:bunit, bscale:bscale, bzero:bzero, $ 
       xunit:xunit,yunit:yunit,lpunit:lpunit,tunit:tunit,$
       wstart:wstart, wwidth:wwidth, diagnostics:diagnostics, $
       ndiagnostics:ndiagnostics, twave:twave, headers:headers, obsid:obsid, $
       date_obs:date_obs, utc_sel:utc_sel, utc_raster_sel:utc_raster_sel $
       }
END

PRO CRISPEX_READ_HEADER, filename, header=header, datatype=datatype, dims=dims,$
      nx=nx, ny=ny, nt=nt, endian=endian, stokes=stokes, ns=ns, $
      diagnostics=diagnostics
; Handles the read in of the header of the input files
	OPENR, lun, filename, /GET_LUN
	rec	= ASSOC(lun, BYTARR(512,/NOZERO))	&	header	= STRING(rec[0])
	FREE_LUN, lun
	len	= STRLEN(header)

	search	= 'datatype='	&	pos	= STRPOS(header, search)
	IF pos EQ -1 THEN BEGIN
		MESSAGE, /INFO, 'Unknown datatype!'
		PRINT, 'Header: '+header
		RETALL
	ENDIF
	datatype= LONG( STRMID(header, pos + STRLEN(search), 1) )
	search	= 'dims='	&	pos	= STRPOS(header, search)
	IF pos EQ -1 THEN BEGIN
		MESSAGE, /INFO, 'Unknown number of dimensions!'
		PRINT, 'Header: '+header
		RETALL
	ENDIF
	dims	= LONG( STRMID(header, pos + STRLEN(search), 1) )
	IF (dims LT 2) OR (dims GT 3) THEN BEGIN
		MESSAGE, /INFO, 'Number of dimensions not supported!'
		PRINT, 'Dimensions: '+dims
		RETALL
	ENDIF
	search	= 'nx='		&	pos	= STRPOS(header, search)
	IF pos EQ -1 THEN BEGIN
		MESSAGE, /INFO, 'Unknown number of pixels in x-direction!'
		PRINT, 'Header: '+header
		RETALL
	ENDIF
	pos1	= STRPOS(header, ',', pos)
	nx	= LONG( STRMID(header, pos + STRLEN(search), pos1-pos) )
	search	= 'ny='		&	pos	= STRPOS(header, search)
	IF pos EQ -1 THEN BEGIN
		MESSAGE, /INFO, 'Unknown number of pixels in y-direction!'
		PRINT, 'Header: '+header
		RETALL
	ENDIF
	pos1	= STRPOS(header, ',', pos)
	ny	= LONG( STRMID(header, pos + STRLEN(search), pos1-pos) )
	search	= 'nt='		&	pos	= STRPOS(header, search)
	IF pos EQ -1 THEN BEGIN
		MESSAGE, /INFO, 'Unknown number of pixels in t-direction!'
		PRINT, 'Header: '+header
		RETALL
	ENDIF
	pos1	= STRPOS(header, ',', pos)
	nt	= LONG( STRMID(header, pos + STRLEN(search), pos1-pos) )
	search	= 'endian='	&	pos	= STRPOS(header, search)
	IF pos EQ -1 THEN BEGIN
		MESSAGE, /INFO, 'Unknown endianness!'
		PRINT, 'Header: '+header
		RETALL
	ENDIF
	endian	= STRMID(header, pos + STRLEN(search), 1)
	search	= 'ns='	&	pos	= STRPOS(header, search)
	IF pos EQ -1 THEN ns = 1 ELSE ns = STRMID(header, pos + STRLEN(search), 1)
	search	= 'stokes='	&	pos	= STRPOS(header, search)
	IF pos EQ -1 THEN stokes = ['I'] ELSE stokes = STRMID(header, pos + STRLEN(search), 2*ns+1)
	search	= 'diagnostics='	&	pos	= STRPOS(header, search)
	pos1	= STRPOS(header,']',pos)
	IF pos NE -1 THEN diagnostics = STRMID(header, pos + STRLEN(search), pos1-pos-STRLEN(search)+1)
END
 
;==================== RESTORE LOOPS PROCEDURES
PRO CRISPEX_RESTORE_LOOPS_MAIN, event
; Start the restore loops procedures, opens the menu if CLSAV files are present
; or otherwise returns an error message 
  WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).loopswitch).restore_loops = event.SELECT
  IF event.SELECT THEN BEGIN
  	CRISPEX_FIND_CSAV, event, /ALLOW_SELECT_DIR
  	IF ((*(*info).restoreparams).cfilecount GT 0) THEN BEGIN
  		IF (*(*info).loopswitch).restore_loops THEN BEGIN
  			CRISPEX_RESTORE_LOOPS_MENU, event
  			WIDGET_CONTROL, (*(*info).ctrlscp).loop_overlay_all, SENSITIVE = 1
  			WIDGET_CONTROL, (*(*info).ctrlscp).loop_overlay_sav, SENSITIVE = 1
  		ENDIF ELSE CRISPEX_RESTORE_LOOPS_MENU_CLOSE, event
  	ENDIF ELSE BEGIN
  		CRISPEX_WINDOW_OK, event,'ERROR!',$
        'No saved time slice (*csav) files found corresponding '+$
        'to the current data file. Unable to produce loop overlays.',$
  			OK_EVENT='CRISPEX_CLOSE_EVENT_WINDOW', BASE=tlb
  		(*(*info).winids).errtlb = tlb
  		WIDGET_CONTROL, (*(*info).ctrlscp).overlay_but, SET_BUTTON = 0
  	ENDELSE
  	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
      CRISPEX_VERBOSE_GET, event, [(*(*info).loopswitch).restore_loops],$
        labels=['Restoring loops']
  ENDIF
END

PRO CRISPEX_RESTORE_LOOPS_MENU, event, set_but_array
; Sets up the restored loops menu and reads in the loop points
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL,/HOURGLASS
	filenames = *(*(*info).restoreparams).cfiles
	filecount = (*(*info).restoreparams).cfilecount
	IF (N_ELEMENTS(set_but_array) NE filecount) THEN $
    *(*(*info).restoreparams).sel_loops = $
      INTARR((*(*info).restoreparams).cfilecount)
	eventval = INDGEN(filecount)
	base = WIDGET_BASE(TITLE = 'CRISPEX'+(*(*info).sesparams).instance_label+$
    ': Choose loop overlays', GROUP_LEADER = (*(*info).winids).root, $
    TLB_FRAME_ATTR = 1, /TLB_KILL_REQUEST_EVENTS)
	disp = WIDGET_BASE(base, /COLUMN)
	disp2 = WIDGET_BASE(disp, /COLUMN, /FRAME)
	sel_allnone = WIDGET_BASE(disp2, /ROW)
	sel_allnone_lab = WIDGET_LABEL(sel_allnone, VALUE = 'Select:', /ALIGN_LEFT)
	sel_allnone_buts = WIDGET_BASE(sel_allnone, /ROW, /EXCLUSIVE)
	(*(*info).ctrlsrestore).sel_all = $
    WIDGET_BUTTON(sel_allnone_buts, VALUE = 'All', $
    EVENT_PRO = 'CRISPEX_RESTORE_LOOPS_SEL_ALL')
	(*(*info).ctrlsrestore).sel_none = $
    WIDGET_BUTTON(sel_allnone_buts, VALUE = 'None', $
    EVENT_PRO = 'CRISPEX_RESTORE_LOOPS_SEL_NONE')
	disp_txt = REPLICATE('Display time slice ', filecount)
	list_values = ['Do not display any slice', disp_txt+STRTRIM(eventval,2)]
	(*(*info).ctrlsrestore).disp_list = WIDGET_COMBOBOX(sel_allnone, $
    VALUE = list_values, /DYNAMIC_RESIZE, $
    EVENT_PRO = 'CRISPEX_DISPLAYS_RESTORE_LOOPSLAB_SELECT')
	WIDGET_CONTROL, (*(*info).ctrlsrestore).sel_none, /SET_BUTTON
	IF (filecount GT 15) THEN $
    sel_buts = WIDGET_BASE(disp2, /COLUMN, /NONEXCLUSIVE,Y_SCROLL_SIZE = 425) $
  ELSE $
    sel_buts = WIDGET_BASE(disp2, /COLUMN, /NONEXCLUSIVE)
  ; Initialise variables
  *(*(*info).restoreparams).xp = PTRARR(filecount, /ALLOCATE_HEAP)
  *(*(*info).restoreparams).yp = PTRARR(filecount, /ALLOCATE_HEAP)
  *(*(*info).restoreparams).xr = PTRARR(filecount, /ALLOCATE_HEAP)
  *(*(*info).restoreparams).yr = PTRARR(filecount, /ALLOCATE_HEAP)
	*(*(*info).restoreparams).lp = LONARR(filecount)
	*(*(*info).restoreparams).ngaps = LONARR(filecount)
	*(*(*info).restoreparams).databounds = PTRARR(filecount, /ALLOCATE_HEAP)
	*(*(*info).restoreparams).wdatabounds = PTRARR(filecount, /ALLOCATE_HEAP)
  *(*(*info).loopsdata).rest_empty_slice = PTRARR(filecount, /ALLOCATE_HEAP)
	*(*(*info).restoreparams).imref = BYTARR(filecount)
  imfilename_noext = $
    STRMID(FILE_BASENAME((*(*info).dataparams).imfilename),0,$
    STRPOS(FILE_BASENAME((*(*info).dataparams).imfilename), '.', /REVERSE_SEARCH))
  refimfilename_noext = $
    STRMID(FILE_BASENAME((*(*info).dataparams).refimfilename),0,$
    STRPOS(FILE_BASENAME((*(*info).dataparams).refimfilename), '.', $
    /REVERSE_SEARCH))
	FOR i=0,filecount-1 DO BEGIN
		IF (N_ELEMENTS(set_but_array) NE filecount) THEN $
      (*(*(*info).restoreparams).sel_loops)[i] = 0
		singlefilename = FILE_BASENAME((*(*(*info).restoreparams).cfiles)[i])
		name = 'sel_restore_but_'+STRTRIM(i,2)
		but_val = STRTRIM(i,2)+': '+singlefilename
		sel_but = WIDGET_BUTTON(sel_buts, VALUE = but_val, UVALUE = eventval[i], $
      EVENT_PRO = 'CRISPEX_RESTORE_LOOPS_MENU_EVENT', UNAME = name) 
		IF (N_ELEMENTS(set_but_array) GT 0) THEN $
      WIDGET_CONTROL, sel_but, SET_BUTTON = set_but_array[i]
		RESTORE,(*(*(*info).restoreparams).cfiles)[i]
    ; Failsafe against older saved files
    IF (N_ELEMENTS(ngaps) EQ 0) THEN BEGIN
      ngaps = 0
      databounds = -1
      wdatabounds = -1
    ENDIF
    ; Support for different saving methods of xp and yp points
		nel = N_ELEMENTS(SIZE(x_coords))						
		IF (nel EQ 5) THEN BEGIN
			xpcoords = REFORM(x_coords[0,*])
			ypcoords = REFORM(y_coords[0,*])
		ENDIF ELSE BEGIN
			xpcoords = x_coords
			ypcoords = y_coords
		ENDELSE
    ; Start filling variables
		*(*(*(*info).restoreparams).xp)[i] = xpcoords
		*(*(*(*info).restoreparams).yp)[i] = ypcoords
		*(*(*(*info).restoreparams).xr)[i] = x_loop_pts
		*(*(*(*info).restoreparams).yr)[i] = y_loop_pts
		(*(*(*info).restoreparams).lp)[i] = spect_pos
		(*(*(*info).restoreparams).ngaps)[i] = ngaps
		*(*(*(*info).restoreparams).databounds)[i] = databounds
		*(*(*(*info).restoreparams).wdatabounds)[i] = wdatabounds
    (*(*(*info).restoreparams).imref)[i] = $
      STRMATCH(singlefilename, imfilename_noext+'*', /FOLD_CASE) + $
      STRMATCH(singlefilename, refimfilename_noext+'*', /FOLD_CASE) * 2
    ; Update user feedback
		initial_feedback = 'Processed save file '+STRTRIM(i,2)+': '+singlefilename
		CRISPEX_UPDATE_USER_FEEDBACK, event, title='Restoring loops...', var=i, $
      maxvar=filecount-1, feedback_text=initial_feedback
		IF (i EQ filecount-1) THEN CRISPEX_WINDOW_USER_FEEDBACK_CLOSE, event
	ENDFOR
  ; Add decision buttons
	decision_base = WIDGET_BASE(disp2,COLUMN=3,/GRID_LAYOUT,/ALIGN_CENTER)
	update_filelist = WIDGET_BUTTON(decision_base, VALUE = 'Update filelist', $
    EVENT_PRO = 'CRISPEX_RESTORE_LOOPS_UPDATE_FILELIST')
	(*(*info).ctrlsrestore).open_tanat = WIDGET_BUTTON(decision_base, $
    VALUE = 'Open in TANAT...', EVENT_PRO = 'CRISPEX_RESTORE_LOOPS_OPEN_TANAT')
	closebut = WIDGET_BUTTON(decision_base, VALUE = 'Close', $
    EVENT_PRO = 'CRISPEX_RESTORE_LOOPS_MENU_CLOSE')
  ; Realize widget window
	WIDGET_CONTROL, base, /REALIZE, $
    TLB_SET_XOFFSET=(*(*info).winsizes).lsxoffset, $
    TLB_SET_YOFFSET=(*(*info).winsizes).lswiny+1.5*(*(*info).winsizes).ydelta
	WIDGET_CONTROL, base, SET_UVALUE = info
	XMANAGER, 'CRISPEX', base, /NO_BLOCK
	(*(*info).winids).restoretlb = base
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).winids).restoretlb,filecount],$
      labels=['restoretlb','Restored loops']
END

PRO CRISPEX_RESTORE_LOOPS_MENU_EVENT, event
; Handles the selection of loops to be restored
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, event.ID, GET_UVALUE = eventval
	(*(*(*info).restoreparams).sel_loops)[eventval] = ( (*(*(*info).restoreparams).sel_loops)[eventval] EQ 0) 
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [eventval,(*(*(*info).restoreparams).sel_loops)[eventval]], labels=['Loop ID','Loop selected']
	CRISPEX_RESTORE_LOOPS_BUTTON_CONDITION, event
	CRISPEX_DRAW, event
END

PRO CRISPEX_RESTORE_LOOPS_BUTTON_CONDITION, event
; Handles the update of buttons after selection
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	condition = WHERE(*(*(*info).restoreparams).sel_loops EQ 1, count)
	WIDGET_CONTROL, (*(*info).ctrlsrestore).sel_none, SET_BUTTON = ABS((count GT 0)-1)
	WIDGET_CONTROL, (*(*info).ctrlsrestore).sel_all, SET_BUTTON = (count EQ (*(*info).restoreparams).cfilecount)
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(((N_ELEMENTS(condition) GT 0) AND (TOTAL(condition) NE -1)) AND (N_ELEMENTS(condition) EQ (*(*info).restoreparams).cfilecount)),$
		ABS(((N_ELEMENTS(condition) GT 0) AND (TOTAL(condition) NE -1))-1),N_ELEMENTS(condition)-(TOTAL(condition) EQ -1)], labels=['All selected','None selected','Total selected']
END

PRO CRISPEX_RESTORE_LOOPS_MENU_CLOSE, event
; Handles the closing of the restored loops menu and clean-up of display afterwards
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF ((*(*info).dispparams).t_range NE (*(*info).dataparams).nt) THEN CRISPEX_DISPRANGE_T_RESET, event, /NO_DRAW
	IF ((*(*info).dispparams).lp_range NE (*(*info).dataparams).nlp) THEN CRISPEX_DISPRANGE_LP_RESET, event, /NO_DRAW
	IF ((*(*info).dispparams).lp_ref_range NE (*(*info).dataparams).refnlp) THEN CRISPEX_DISPRANGE_LP_REF_RESET, event, /NO_DRAW
	WIDGET_CONTROL, (*(*info).ctrlscp).loop_overlay_all, SENSITIVE = 0
	WIDGET_CONTROL, (*(*info).ctrlscp).loop_overlay_sav, SENSITIVE = 0
	(*(*info).loopswitch).restore_loops = 0
	(*(*info).restoreparams).disp_loopfile = '0'
	*(*(*info).restoreparams).disp_loopnr = -1
	IF (*(*info).winswitch).showrestloop THEN BEGIN
		FOR i=0,N_ELEMENTS(*(*(*info).winids).restlooptlb)-1 DO BEGIN
			WIDGET_CONTROL, (*(*(*info).winids).restlooptlb)[i], /DESTROY
			*(*(*(*info).loopsdata).rest_loopslice[i]) = 0
			*(*(*(*info).loopsdata).rest_loopslab[i]) = 0
			*(*(*(*info).loopsdata).rest_crossloc[i]) = 0
		ENDFOR
		(*(*info).winswitch).showrestloop = 0
		*(*(*info).winids).restlooptlb = 0
	ENDIF
	WIDGET_CONTROL, (*(*info).ctrlscp).overlay_but, SET_BUTTON = 0
	WIDGET_CONTROL, (*(*info).ctrlscp).lp_slider, /SENSITIVE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).loopswitch).restore_loops,(*(*info).winids).restoretlb], labels=['Restoring loops','restoretlb was']
	CRISPEX_DRAW, event
	WIDGET_CONTROL, (*(*info).winids).restoretlb, /DESTROY
	(*(*info).winids).restoretlb = 0
END

PRO CRISPEX_RESTORE_LOOPS_SEL_ALL, event
; Handles selection of all restored loops
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	*(*(*info).restoreparams).sel_loops = REPLICATE(1,(*(*info).restoreparams).cfilecount)
	FOR i=0,(*(*info).restoreparams).cfilecount-1 DO BEGIN
		name = 'sel_restore_but_'+STRTRIM(i,2)
		WIDGET_CONTROL, WIDGET_INFO(event.TOP, FIND_BY_UNAME = name), SET_BUTTON = 1
	ENDFOR		
	CRISPEX_DRAW, event
END

PRO CRISPEX_RESTORE_LOOPS_SEL_NONE, event
; Handles selection of none restored loops
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	*(*(*info).restoreparams).sel_loops = REPLICATE(0,(*(*info).restoreparams).cfilecount)
	FOR i=0,(*(*info).restoreparams).cfilecount-1 DO BEGIN
		name = 'sel_restore_but_'+STRTRIM(i,2)
		WIDGET_CONTROL, WIDGET_INFO(event.TOP, FIND_BY_UNAME = name), SET_BUTTON = 0
	ENDFOR		
	CRISPEX_DRAW, event
END

PRO CRISPEX_RESTORE_LOOPS_UPDATE_FILELIST, event
; Handles the update of the restored file list
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF ((*(*info).dispparams).t_range NE (*(*info).dataparams).nt) THEN CRISPEX_DISPRANGE_T_RESET, event, /NO_DRAW
	IF ((*(*info).dispparams).lp_range NE (*(*info).dataparams).nlp) THEN CRISPEX_DISPRANGE_LP_RESET, event, /NO_DRAW
	IF ((*(*info).dispparams).lp_ref_range NE (*(*info).dataparams).refnlp) THEN CRISPEX_DISPRANGE_LP_REF_RESET, event, /NO_DRAW
	(*(*info).restoreparams).disp_loopfile = '0'
	*(*(*info).restoreparams).disp_loopnr = -1
	IF (*(*info).winswitch).showrestloop THEN BEGIN
		FOR i=0,N_ELEMENTS(*(*(*info).winids).restlooptlb)-1 DO BEGIN
			WIDGET_CONTROL, (*(*(*info).winids).restlooptlb)[i], /DESTROY
			*(*(*(*info).loopsdata).rest_loopslice[i]) = 0
			*(*(*(*info).loopsdata).rest_loopslab[i]) = 0
			*(*(*(*info).loopsdata).rest_crossloc[i]) = 0
		ENDFOR
		(*(*info).winswitch).showrestloop = 0
		*(*(*info).winids).restlooptlb = 0
	ENDIF
	WIDGET_CONTROL, (*(*info).ctrlscp).lp_slider, /SENSITIVE
	WIDGET_CONTROL, (*(*info).winids).root, SET_UVALUE = info
	WIDGET_CONTROL, event.TOP, /DESTROY
	event.TOP = (*(*info).winids).root
	CRISPEX_RESTORE_LOOPS_MAIN, event
	CRISPEX_DRAW_IMREF, event
END

PRO CRISPEX_RESTORE_LOOPS_ALWAYS, event
; Sets the display of restored loops to always (i.e. at all spectral positions) or selected (i.e. at saved positions)
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).overlayswitch).overlalways = event.SELECT
	IF ((*(*info).loopswitch).restore_loops EQ 0) THEN CRISPEX_RESTORE_LOOPS_MAIN, event ELSE CRISPEX_DRAW, event
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).overlayswitch).overlalways], labels=['Overlay loops always']
END

PRO CRISPEX_RESTORE_LOOPS_OPEN_TANAT, event			
; Handles all prior to loading TANAT to analyse the selected loop slice/slab
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	path_tanat = (ROUTINE_INFO('TANAT',/SOURCE)).PATH								; CHeck whether TANAT has already been compiled
	tanat_file = FILE_SEARCH((*(*info).paths).dir_aux,'tanat.pro', /FULLY_QUALIFY_PATH, COUNT=tanat_count)	; Try to find TANAT where it should be
	IF (tanat_count EQ 1) THEN (*(*info).paths).dir_tanat = (*(*info).paths).dir_aux
	IF (path_tanat NE '') THEN BEGIN										; TANAT has been compiled, so check whether it is the one at the expected location
		IF (path_tanat NE (*(*info).paths).dir_tanat+'tanat.pro') THEN BEGIN					; Compiled TANAT is not the correct TANAT
			IF (tanat_count EQ 1) THEN BEGIN								; Correct TANAT exists, so compile that one and run
				dir_tanat = STRMID((*(*info).paths).dir_tanat,0,STRPOS((*(*info).paths).dir_tanat,'/',/REVERSE_SEARCH))
				IF (STRPOS(!PATH,dir_tanat) NE 0) THEN !PATH = dir_tanat+':'+!PATH
				RESOLVE_ROUTINE, 'TANAT'
				CRISPEX_RESTORE_LOOPS_OPEN_TANAT_OPEN, event
			ENDIF ELSE IF ((*(*info).paths).tanat_repointed NE 1) THEN BEGIN				; Correct TANAT can not be found, run anyway but warn
				CRISPEX_WINDOW_OK, event,'WARNING!',$
          'CRISPEX could not find TANAT at the expected location '+$
          '('+(*(*info).paths).dir_aux+'), but a local copy has been compiled before from '+$
					'('+STRMID(path_tanat,0,STRPOS(path_tanat,'/',/REVERSE_SEARCH))+'). '+$
          'Press OK to continue with that local copy of TANAT, or select a different one.',$
					OK_EVENT='CRISPEX_RESTORE_LOOPS_OPEN_TANAT_OPEN', $
          CANCEL_EVENT='CRISPEX_RESTORE_LOOPS_OPEN_TANAT_REPOINT', $
          CANCEL_LABEL='Select different', BASE=tlb
				(*(*info).winids).errtlb = tlb
				(*(*info).paths).tanat_repointed = 1
			ENDIF ELSE CRISPEX_RESTORE_LOOPS_OPEN_TANAT_OPEN, event
		ENDIF ELSE CRISPEX_RESTORE_LOOPS_OPEN_TANAT_OPEN, event
	ENDIF ELSE BEGIN												; TANAT has not been compiled, but perhaps resides where it should
		IF (tanat_count EQ 1) THEN BEGIN									; Correct TANAT can be found
			dir_tanat = STRMID((*(*info).paths).dir_tanat,0,STRPOS((*(*info).paths).dir_tanat,'/',/REVERSE_SEARCH))
			IF (STRPOS(!PATH,dir_tanat) NE 0) THEN !PATH = dir_tanat+':'+!PATH				; Make sure that that version will be compiled
			RESOLVE_ROUTINE, 'TANAT'
			CRISPEX_RESTORE_LOOPS_OPEN_TANAT_OPEN, event
		ENDIF ELSE BEGIN											; TANAT has not been compiled, nor can be found where it should: have user point to local copy or abort	
			CRISPEX_WINDOW_OK, event,'ERROR!',$
        'CRISPEX could not find TANAT at the expected location ('+(*(*info).paths).dir_aux+'). '+$
				'Press OK to point CRISPEX to a local copy of TANAT, or cancel to abort.',$
        OK_EVENT='CRISPEX_RESTORE_LOOPS_OPEN_TANAT_REPOINT', $
        CANCEL_EVENT='CRISPEX_CLOSE_EVENT_WINDOW', BASE=tlb
			(*(*info).winids).errtlb = tlb
		ENDELSE
	ENDELSE 
END

PRO CRISPEX_RESTORE_LOOPS_OPEN_TANAT_REPOINT, event				
; Handles (re)pointing CRISPEX to the correct copy of TANAT
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	file_tanat = DIALOG_PICKFILE(PATH='~/', FILTER='*.pro', /FIX_FILTER, /MUST_EXIST, TITLE='CRISPEX'+(*(*info).sesparams).instance_label+': Choose copy of TANAT to compile')
	(*(*info).paths).dir_tanat = STRMID(file_tanat,0,STRPOS(file_tanat,'/',/REVERSE_SEARCH))
	!PATH = (*(*info).paths).dir_tanat+':'+!PATH
	RESOLVE_ROUTINE,'TANAT'
	(*(*info).paths).tanat_repointed = 1
	WIDGET_CONTROL, (*(*info).winids).root, SET_UVALUE = info
	WIDGET_CONTROL, (*(*info).winids).errtlb,/DESTROY
	(*(*info).winids).errtlb = 0
	event.TOP = (*(*info).winids).root
	CRISPEX_RESTORE_LOOPS_OPEN_TANAT_OPEN, event
END

PRO CRISPEX_RESTORE_LOOPS_OPEN_TANAT_OPEN, event
; Handles the actual loading TANAT to analyse the selected loop slice/slab
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF ((*(*info).winids).errtlb GT 0) THEN BEGIN
		WIDGET_CONTROL, (*(*info).winids).root, SET_UVALUE = info
		WIDGET_CONTROL, (*(*info).winids).errtlb,/DESTROY
		(*(*info).winids).errtlb = 0
		event.TOP = (*(*info).winids).root
	ENDIF
	file_csav = DIALOG_PICKFILE(PATH=(*(*info).paths).ipath, FILTER='*.csav', /FIX_FILTER, /MUST_EXIST, TITLE='CRISPEX'+(*(*info).sesparams).instance_label+': Choose CSAV file to load in TANAT')
	IF (STRLEN(file_csav) GT 0) THEN $
    TANAT, file_csav, ASECPIX=[(*(*info).dataparams).dx,$
      (*(*info).dataparams).dy], DT=(*(*info).plotaxes).dt
END


;==================== RETRIEVE FROM DETECTIONS PROCEDURES
PRO CRISPEX_RETRIEVE_DET_FILE_MENU, event, set_but_array, $
  DETFILENAME=detfilename, NO_DRAW=no_draw
; Opens the retrieved detections menu and reads in the data from the detection file
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (N_ELEMENTS(detfilename) NE 1) THEN $
    (*(*info).detparams).detfilename = DIALOG_PICKFILE(/READ, /MUST_EXIST, $
      TITLE = 'CRISPEX'+(*(*info).sesparams).instance_label+$
      ': Select detection file', PATH=(*(*info).paths).ipath)
	IF ((*(*info).detparams).detfilename EQ '') THEN BEGIN
		(*(*info).loopswitch).retrieve_detfile = 0
		RETURN
	ENDIF ELSE BEGIN
		WIDGET_CONTROL, (*(*info).ctrlscp).det_file_but, SENSITIVE = 0
		WIDGET_CONTROL, /HOURGLASS
		(*(*info).loopswitch).retrieve_detfile = 1
		RESTORE,(*(*info).detparams).detfilename
		(*(*info).detparams).nr_dets = ntot
		IF (N_ELEMENTS(set_but_array) NE (*(*info).detparams).nr_dets) THEN $
      *(*(*info).detparams).sel_dets = INTARR((*(*info).detparams).nr_dets)
    *(*(*info).detparams).overlay_dets = *(*(*info).detparams).sel_dets
		eventval = INDGEN((*(*info).detparams).nr_dets)
		base = WIDGET_BASE(TITLE = 'CRISPEX'+(*(*info).sesparams).instance_label+$
      ': Save from detection file', GROUP_LEADER = (*(*info).winids).root, $
      TLB_FRAME_ATTR = 1, /TLB_KILL_REQUEST_EVENTS)
		disp = WIDGET_BASE(base, /COLUMN)
		disp2 = WIDGET_BASE(disp, /COLUMN, /FRAME)
		sel_allnone = WIDGET_BASE(disp2, /ROW)
		sel_allnone_lab = WIDGET_LABEL(sel_allnone, VALUE = 'Select:', /ALIGN_LEFT)
		sel_allnone_buts = WIDGET_BASE(sel_allnone, /ROW, /EXCLUSIVE)
		(*(*info).ctrlsdet).sel_all = WIDGET_BUTTON(sel_allnone_buts, VALUE='All', $
      EVENT_PRO = 'CRISPEX_RETRIEVE_DET_SEL_ALL')
		(*(*info).ctrlsdet).sel_none = WIDGET_BUTTON(sel_allnone_buts, VALUE='None',$
      EVENT_PRO = 'CRISPEX_RETRIEVE_DET_SEL_NONE')
		WIDGET_CONTROL, (*(*info).ctrlsdet).sel_none, /SET_BUTTON
		disp_txt = REPLICATE('Display time slice D', (*(*info).detparams).nr_dets)
		list_values = ['Do not display any slice', disp_txt+STRTRIM(eventval,2)]
		(*(*info).ctrlsdet).disp_list = WIDGET_COMBOBOX(sel_allnone, $
      VALUE = list_values, /DYNAMIC_RESIZE, $
      EVENT_PRO = 'CRISPEX_DISPLAYS_RETRIEVE_DET_LOOPSLAB')
		overlays = WIDGET_BASE(disp2,/ROW)
		overlay_lab = WIDGET_LABEL(overlays, VALUE = 'Overlay:', /ALIGN_LEFT)
		overlay_buts = WIDGET_BASE(overlays, /ROW, /EXCLUSIVE)
		(*(*info).ctrlsdet).overlay_all = WIDGET_BUTTON(overlay_buts, $
      VALUE = 'All detections', EVENT_PRO = 'CRISPEX_RETRIEVE_DET_OVERLAY_ALL')
		(*(*info).ctrlsdet).overlay_sel = WIDGET_BUTTON(overlay_buts, $
      VALUE = 'Selected detections')
		WIDGET_CONTROL, (*(*info).ctrlsdet).overlay_sel, /SET_BUTTON
		IF ((*(*info).detparams).nr_dets GT 15) THEN $
      sel_buts = WIDGET_BASE(disp2, /ROW, Y_SCROLL_SIZE = 425) $
    ELSE $
      sel_buts = WIDGET_BASE(disp2, /ROW)
		ncols = 5
		nlines = CEIL((*(*info).detparams).nr_dets / FLOAT(ncols))
		sel_buts_col_0 = WIDGET_BASE(sel_buts, /NONEXCLUSIVE, /COLUMN)
		sel_buts_col_1 = WIDGET_BASE(sel_buts, /NONEXCLUSIVE, /COLUMN)
		sel_buts_col_2 = WIDGET_BASE(sel_buts, /NONEXCLUSIVE, /COLUMN)
		sel_buts_col_3 = WIDGET_BASE(sel_buts, /NONEXCLUSIVE, /COLUMN)
		sel_buts_col_4 = WIDGET_BASE(sel_buts, /NONEXCLUSIVE, /COLUMN)
    ; Initialise variables
    *(*(*info).detparams).xlp = PTRARR((*(*info).detparams).nr_dets, /ALLOCATE_HEAP)
    *(*(*info).detparams).ylp = PTRARR((*(*info).detparams).nr_dets, /ALLOCATE_HEAP)
    *(*(*info).detparams).xlr = PTRARR((*(*info).detparams).nr_dets, /ALLOCATE_HEAP)
    *(*(*info).detparams).ylr = PTRARR((*(*info).detparams).nr_dets, /ALLOCATE_HEAP)
  	*(*(*info).detparams).t   = LONARR((*(*info).detparams).nr_dets)
		FOR i=0,(*(*info).detparams).nr_dets-1 DO BEGIN
			IF (N_ELEMENTS(set_but_array) NE (*(*info).detparams).nr_dets) THEN $
        (*(*(*info).detparams).sel_dets)[i] = 0
			col = FLOOR(i/nlines)
			name = 'det_sel_but_'+STRTRIM(i,2)
			but_val = 'D'+STRTRIM(i,2)
			IF (col EQ 0) THEN act_sel_buts_col = sel_buts_col_0
			IF (col EQ 1) THEN act_sel_buts_col = sel_buts_col_1
			IF (col EQ 2) THEN act_sel_buts_col = sel_buts_col_2
			IF (col EQ 3) THEN act_sel_buts_col = sel_buts_col_3
			IF (col EQ 4) THEN act_sel_buts_col = sel_buts_col_4
			sel_but = WIDGET_BUTTON(act_sel_buts_col, VALUE = but_val, $
        UVALUE = eventval[i], EVENT_PRO = 'CRISPEX_RETRIEVE_DET_MENU_EVENT', $
        UNAME = name) 
			IF (N_ELEMENTS(set_but_array) EQ (*(*info).detparams).nr_dets) THEN $
        WIDGET_CONTROL, sel_but, SET_BUTTON = set_but_array[i]
			npoints = (SIZE((*detections[i]).x))[1]
			maxwidth = (SIZE((*detections[i]).x))[2]
			stdwidth = CEIL(maxwidth/2.)
			IF ~KEYWORD_SET(NO_DRAW) THEN (*(*info).detparams).width = stdwidth
			(*(*info).detparams).mid = CEIL(maxwidth/2.)-1
			(*(*(*info).detparams).t)[i] = (*detections[i]).t
			*(*(*(*info).detparams).xlp)[i] = $
        [(*detections[i]).x[0,2],(*detections[i]).x[npoints-1,2]]
			*(*(*(*info).detparams).ylp)[i] = $
        [(*detections[i]).y[0,2],(*detections[i]).y[npoints-1,2]]
			*(*(*(*info).detparams).xlr)[i] = (*detections[i]).x
			*(*(*(*info).detparams).ylr)[i] = (*detections[i]).y
		ENDFOR			
		time_base = WIDGET_BASE(disp, /ROW, /FRAME)
		dtmin_label = WIDGET_LABEL(time_base, VALUE = 'Delta t down:', /ALIGN_LEFT)
		(*(*info).ctrlsdet).dtmin_text = WIDGET_TEXT(time_base, $
      VALUE = STRTRIM((*(*info).detparams).delta_t_dn,2), /EDITABLE, XSIZE = 5,$
      EVENT_PRO = 'CRISPEX_RETRIEVE_DET_DELTA_T_DN')
		dtmax_label = WIDGET_LABEL(time_base, VALUE = 'Delta t up:', /ALIGN_LEFT)
		(*(*info).ctrlsdet).dtmax_text = WIDGET_TEXT(time_base, $
      VALUE = STRTRIM((*(*info).detparams).delta_t_up,2), /EDITABLE, XSIZE = 5,$
      EVENT_PRO = 'CRISPEX_RETRIEVE_DET_DELTA_T_UP')
		(*(*info).ctrlsdet).width_slider = WIDGET_SLIDER(disp, $
      TITLE = 'Detection loop width', MIN = 1, MAX = maxwidth, $
      VALUE = (*(*info).detparams).width, EVENT_PRO = 'CRISPEX_RETRIEVE_DET_WIDTH')
		spectral_pos = WIDGET_BASE(disp, /COLUMN, /FRAME)
		spectral_pos_base = WIDGET_BASE(spectral_pos, /ROW)
		spectral_pos_label = WIDGET_LABEL(spectral_pos_base, $
      VALUE = 'Spectral positions:', /ALIGN_LEFT)
		spectral_pos_buts_base = WIDGET_BASE(spectral_pos_base, /ROW, /EXCLUSIVE)
		(*(*info).ctrlsdet).all_pos = WIDGET_BUTTON(spectral_pos_buts_base, $
      VALUE = 'All', EVENT_PRO = 'CRISPEX_RETRIEVE_DET_ALL_POS', /NO_RELEASE)
		WIDGET_CONTROL, (*(*info).ctrlsdet).all_pos, $
      SET_BUTTON = ((*(*info).savswitch).pos_dets EQ 1)
		(*(*info).ctrlsdet).saved_pos = WIDGET_BUTTON(spectral_pos_buts_base, $
      VALUE = 'Current', EVENT_PRO = 'CRISPEX_RETRIEVE_DET_CUR_POS', /NO_RELEASE)
		WIDGET_CONTROL, (*(*info).ctrlsdet).saved_pos, $
      SET_BUTTON = ((*(*info).savswitch).pos_dets EQ 2)
		(*(*info).ctrlsdet).sel_range_pos = WIDGET_BUTTON(spectral_pos_buts_base, $
      VALUE = 'Selected range', EVENT_PRO = 'CRISPEX_RETRIEVE_DET_SEL_RANGE_POS', /NO_RELEASE)
		WIDGET_CONTROL, (*(*info).ctrlsdet).sel_range_pos, $
      SET_BUTTON = ((*(*info).savswitch).pos_dets EQ 3)
		range_pos_base = WIDGET_BASE(spectral_pos, /ROW)
		main_label = WIDGET_LABEL(range_pos_base, VALUE = 'Main:', /ALIGN_LEFT)
		dlpmin_label = WIDGET_LABEL(range_pos_base, VALUE = 'Lower lp-index:', $
      /ALIGN_LEFT)
		(*(*info).ctrlsdet).dlpmin_text = WIDGET_TEXT(range_pos_base, $
      VALUE = STRTRIM((*(*info).detparams).lp_dn,2), /EDITABLE, XSIZE = 5, $
      EVENT_PRO = 'CRISPEX_RETRIEVE_DET_LP_DN', SENSITIVE = 0)
		dlpmax_label = WIDGET_LABEL(range_pos_base, VALUE = 'Upper lp-index:', $
      /ALIGN_LEFT)
		(*(*info).ctrlsdet).dlpmax_text = WIDGET_TEXT(range_pos_base, $
      VALUE = STRTRIM((*(*info).detparams).lp_up,2), /EDITABLE, XSIZE = 5, $
      EVENT_PRO = 'CRISPEX_RETRIEVE_DET_LP_UP', SENSITIVE = 0)
		refrange_pos_base = WIDGET_BASE(spectral_pos, /ROW)
		ref_label = WIDGET_LABEL(refrange_pos_base, VALUE = 'Reference:', $
      /ALIGN_LEFT)
		refdlpmin_label = WIDGET_LABEL(refrange_pos_base, VALUE = 'Lower lp-index:',$
      /ALIGN_LEFT)
		(*(*info).ctrlsdet).refdlpmin_text = WIDGET_TEXT(refrange_pos_base, $
      VALUE = STRTRIM((*(*info).detparams).lp_ref_dn,2), /EDITABLE, XSIZE = 5, $
      EVENT_PRO = 'CRISPEX_RETRIEVE_DET_LP_REF_DN', SENSITIVE = 0)
		refdlpmax_label = WIDGET_LABEL(refrange_pos_base, VALUE = 'Upper lp-index:',$
      /ALIGN_LEFT)
		(*(*info).ctrlsdet).refdlpmax_text = WIDGET_TEXT(refrange_pos_base, $
      VALUE = STRTRIM((*(*info).detparams).lp_ref_up,2), /EDITABLE, XSIZE = 5, $
      EVENT_PRO = 'CRISPEX_RETRIEVE_DET_LP_REF_UP', SENSITIVE = 0)
		save_cube = WIDGET_BASE(disp, /ROW, /FRAME)
		save_cube_lab = WIDGET_LABEL(save_cube, VALUE = 'Save from: ')
		save_cube_but = WIDGET_BASE(save_cube, /ROW, /EXCLUSIVE)
		(*(*info).ctrlsdet).save_imonly = WIDGET_BUTTON(save_cube_but, $
      VALUE = 'IMCUBE only', EVENT_PRO = 'CRISPEX_RETRIEVE_DET_IMCUBE_ONLY', $
      /NO_RELEASE)
		WIDGET_CONTROL, (*(*info).ctrlsdet).save_imonly, /SET_BUTTON
		refsens = (*(*info).winswitch).showref AND ((*(*info).dataparams).refnt GT 1) 
		(*(*info).ctrlsdet).save_refonly = WIDGET_BUTTON(save_cube_but, $
      VALUE = 'REFCUBE only', EVENT_PRO = 'CRISPEX_RETRIEVE_DET_REFCUBE_ONLY', $
      SENSITIVE = refsens, /NO_RELEASE)
		(*(*info).ctrlsdet).save_imref = WIDGET_BUTTON(save_cube_but, $
      VALUE = 'both cubes', EVENT_PRO = 'CRISPEX_RETRIEVE_DET_IMREF', $
      SENSITIVE = refsens, /NO_RELEASE)
		dec_buts = WIDGET_BASE(disp, /ROW, /ALIGN_CENTER)
		change_path_but = WIDGET_BUTTON(dec_buts, VALUE = 'Change path', $
      EVENT_PRO = 'CRISPEX_SAVE_SET_OPATH')
		(*(*info).ctrlsdet).get_dets = WIDGET_BUTTON(dec_buts, $
      VALUE = 'Save selected detection(s)', $
      EVENT_PRO = 'CRISPEX_RETRIEVE_DET_SEL_LOOPS', SENSITIVE = 0)
		cancel = WIDGET_BUTTON(dec_buts, VALUE = 'Cancel', $
      EVENT_PRO = 'CRISPEX_RETRIEVE_DET_CANCEL')
		WIDGET_CONTROL, base, /REALIZE, TLB_SET_XOFFSET = (*(*info).winsizes).lsxoffset
		WIDGET_CONTROL, base, SET_UVALUE = info
		XMANAGER, 'CRISPEX', base, /NO_BLOCK
		(*(*info).winids).detsavetlb = base
	ENDELSE
	IF ~KEYWORD_SET(NO_DRAW) THEN CRISPEX_DRAW, event
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, $
      [(*(*info).loopswitch).retrieve_detfile,(*(*info).winids).detsavetlb,$
      (*(*info).detparams).nr_dets],$
      labels=['Retrieving detections','detsavetlb','Retrieved detections']
END

PRO CRISPEX_RETRIEVE_DET_SEL_ALL, event
; Handles the selection of all detections
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	*(*(*info).detparams).sel_dets = REPLICATE(1,(*(*info).detparams).nr_dets)
	WIDGET_CONTROL, (*(*info).ctrlsdet).get_dets, SENSITIVE = 1
	FOR i=0,(*(*info).detparams).nr_dets-1 DO BEGIN
		name = 'det_sel_but_'+STRTRIM(i,2)
		WIDGET_CONTROL, WIDGET_INFO(event.TOP, FIND_BY_UNAME = name), SET_BUTTON = 1
	ENDFOR		
	IF ((*(*info).overlayswitch).det_overlay_all EQ 0) THEN CRISPEX_DRAW, event
END

PRO CRISPEX_RETRIEVE_DET_SEL_NONE, event
; Handles the selection of no detections
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	*(*(*info).detparams).sel_dets = REPLICATE(0,(*(*info).detparams).nr_dets)
	WIDGET_CONTROL, (*(*info).ctrlsdet).get_dets, SENSITIVE = 0
	FOR i=0,(*(*info).detparams).nr_dets-1 DO BEGIN
		name = 'det_sel_but_'+STRTRIM(i,2)
		WIDGET_CONTROL, WIDGET_INFO(event.TOP, FIND_BY_UNAME = name), SET_BUTTON = 0
	ENDFOR		
	IF ((*(*info).overlayswitch).det_overlay_all EQ 0) THEN CRISPEX_DRAW, event
END

PRO CRISPEX_RETRIEVE_DET_MENU_EVENT, event
; Handles the selection of a certain detection
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event, /IGNORE_LAST
	WIDGET_CONTROL, event.ID, GET_UVALUE = eventval
	(*(*(*info).detparams).sel_dets)[eventval] = ( (*(*(*info).detparams).sel_dets)[eventval] EQ 0) 
	condition = WHERE(*(*(*info).detparams).sel_dets EQ 1, count)
	WIDGET_CONTROL, (*(*info).ctrlsdet).get_dets, SENSITIVE = (count GT 0)
	WIDGET_CONTROL, (*(*info).ctrlsdet).sel_all, SET_BUTTON = (count EQ (*(*info).detparams).nr_dets)
	WIDGET_CONTROL, (*(*info).ctrlsdet).sel_none, SET_BUTTON = ABS((count GT 0)-1)
	IF ((*(*info).overlayswitch).det_overlay_all EQ 0) THEN BEGIN
    (*(*(*info).detparams).overlay_dets)[eventval] = $
      (*(*(*info).detparams).sel_dets)[eventval]
    CRISPEX_DRAW, event
  ENDIF
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [eventval,(*(*(*info).detparams).sel_dets)[eventval],$
		(((N_ELEMENTS(condition) GT 0) AND (TOTAL(condition) NE -1)) AND (N_ELEMENTS(condition) EQ (*(*info).restoreparams).cfilecount)),ABS(((N_ELEMENTS(condition) GT 0) AND (TOTAL(condition) NE -1))-1),$
		N_ELEMENTS(condition)-(TOTAL(condition) EQ -1)], labels=['Detection ID','Detection selected','All selected','None selected','Total selected']

END

PRO CRISPEX_RETRIEVE_DET_OVERLAY_ALL, event
; Enables the overlay of all or no detections
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).overlayswitch).det_overlay_all = event.SELECT
  IF (*(*info).overlayswitch).det_overlay_all THEN $
    *(*(*info).detparams).overlay_dets = REPLICATE(1, $
      (*(*info).detparams).nr_dets) $
  ELSE $
    *(*(*info).detparams).overlay_dets = *(*(*info).detparams).sel_dets
	CRISPEX_DRAW, event
END

PRO CRISPEX_RETRIEVE_DET_WIDTH, event
; Handles the width of the retrieved detection
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	prev_width = (*(*info).detparams).width
	set_width = event.VALUE
	IF (set_width NE prev_width) THEN BEGIN
		WIDGET_CONTROL, /HOURGLASS
		IF (FLOOR(set_width/2.) EQ set_width/2.) THEN BEGIN
			IF (prev_width GT set_width) THEN $
        set_width = set_width-1 $
      ELSE $
        set_width = set_width+1
		ENDIF
		(*(*info).detparams).width = set_width
		WIDGET_CONTROL, (*(*info).ctrlsdet).width_slider, $
      SET_VALUE = (*(*info).detparams).width
		IF (*(*info).winswitch).showretrdet THEN BEGIN
      ; Gather input parameters
      maxpass = ((*(*info).detparams).lp_up-(*(*info).detparams).lp_dn+1) * $
        (*(*info).detparams).width
      t_0 = SYSTIME(/SECONDS)
      inparams = {xlp:*(*(*(*info).detparams).xlp)[(*(*info).detparams).idx], $
        ylp:*(*(*(*info).detparams).ylp)[(*(*info).detparams).idx], $
        xlr:*(*(*(*info).detparams).xlr)[(*(*info).detparams).idx], $
        ylr:*(*(*(*info).detparams).ylr)[(*(*info).detparams).idx], $
        nx:(*(*info).dataparams).nx, ny:(*(*info).dataparams).ny, $
        lp_dn:(*(*info).detparams).lp_dn, lp_up:(*(*info).detparams).lp_up, $
        no_nlp:((*(*info).dataparams).nlp LE 1), idx:(*(*info).detparams).idx, $
        detimref:1, data:(*(*info).data).imagedata, t_0:t_0, maxpass:maxpass}
      ; Get actual detection slab
      CRISPEX_RETRIEVE_DET_GET_SLAB, event, inparams, w_lpts_out, gapresult_out, $
        loopslab_out, crossloc_out, loopsize_out, t_det_out, t_low_out, $
        t_upp_out
      (*(*info).detparams).ngaps = gapresult_out.ngaps
      *(*(*info).detparams).databounds = gapresult_out.databounds
      *(*(*info).detparams).wdatabounds = gapresult_out.wdatabounds
  	  *(*(*info).loopsdata).det_loopslab = loopslab_out
  	  *(*(*info).loopsdata).det_crossloc = crossloc_out
  	  (*(*info).loopsdata).det_loopsize = loopsize_out
      *(*(*info).detparams).w_lpts = w_lpts_out
      (*(*info).dispparams).t_low = t_low_out
      (*(*info).dispparams).t_upp = t_upp_out
      (*(*info).dispparams).t = t_det_out
			CRISPEX_UPDATE_LP, event
			CRISPEX_DISPRANGE_T_RANGE, event
			WIDGET_CONTROL, (*(*info).ctrlscp).lower_t_text,$
        SET_VALUE = STRTRIM((*(*info).dispparams).t_low,2),SENSITIVE = 0
			WIDGET_CONTROL, (*(*info).ctrlscp).upper_t_text,$
        SET_VALUE = STRTRIM((*(*info).dispparams).t_upp,2),SENSITIVE = 0 
		IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
      CRISPEX_VERBOSE_GET, event, [prev_width,set_width],$
        labels=['Previous width','New width']
		ENDIF ELSE CRISPEX_DRAW, event
	ENDIF ELSE RETURN
END

PRO CRISPEX_RETRIEVE_DET_ALL_POS, event
; Enables the retreival of detections at all spectral positions
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savswitch).pos_dets = 1
	WIDGET_CONTROL, (*(*info).ctrlsdet).dlpmin_text, SENSITIVE = 0
	WIDGET_CONTROL, (*(*info).ctrlsdet).dlpmax_text, SENSITIVE = 0
	IF ((*(*info).savswitch).det_imref_only GE 2) THEN BEGIN
		WIDGET_CONTROL, (*(*info).ctrlsdet).refdlpmin_text, SENSITIVE = 0
		WIDGET_CONTROL, (*(*info).ctrlsdet).refdlpmax_text, SENSITIVE = 0
	ENDIF
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).savswitch).pos_dets],labels=['Saving spectral position setting']
END

PRO CRISPEX_RETRIEVE_DET_CUR_POS, event
; Enables the retreival of detections at the current spectral position only
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savswitch).pos_dets = 2
	WIDGET_CONTROL, (*(*info).ctrlsdet).dlpmin_text, SENSITIVE = 0
	WIDGET_CONTROL, (*(*info).ctrlsdet).dlpmax_text, SENSITIVE = 0
	IF ((*(*info).savswitch).det_imref_only GE 2) THEN BEGIN
		WIDGET_CONTROL, (*(*info).ctrlsdet).refdlpmin_text, SENSITIVE = 0
		WIDGET_CONTROL, (*(*info).ctrlsdet).refdlpmax_text, SENSITIVE = 0
	ENDIF
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).savswitch).pos_dets],labels=['Saving spectral position setting']
END
	
PRO CRISPEX_RETRIEVE_DET_SEL_RANGE_POS, event
; Enables the retreival of detections at a selected range of spectral positions
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savswitch).pos_dets = 3
	WIDGET_CONTROL, (*(*info).ctrlsdet).dlpmin_text, SENSITIVE = ((*(*info).savswitch).det_imref_only NE 2)
	WIDGET_CONTROL, (*(*info).ctrlsdet).dlpmax_text, SENSITIVE = ((*(*info).savswitch).det_imref_only NE 2)
	WIDGET_CONTROL, (*(*info).ctrlsdet).refdlpmin_text, SENSITIVE = ((*(*info).savswitch).det_imref_only GE 2)
	WIDGET_CONTROL, (*(*info).ctrlsdet).refdlpmax_text, SENSITIVE = ((*(*info).savswitch).det_imref_only GE 2)
	CRISPEX_RETRIEVE_DET_LP_DN, event
	CRISPEX_RETRIEVE_DET_LP_UP, event
	CRISPEX_RETRIEVE_DET_LP_REF_DN, event
	CRISPEX_RETRIEVE_DET_LP_REF_UP, event
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).savswitch).pos_dets],labels=['Saving spectral position setting']
END

PRO CRISPEX_RETRIEVE_DET_IMCUBE_ONLY, event
; Enables the retreival of detections from the image cube only
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savswitch).det_imref_only = 1
	WIDGET_CONTROL, (*(*info).ctrlsdet).dlpmin_text, SENSITIVE = ((*(*info).savswitch).pos_dets EQ 3) 
	WIDGET_CONTROL, (*(*info).ctrlsdet).dlpmax_text, SENSITIVE = ((*(*info).savswitch).pos_dets EQ 3) 
	WIDGET_CONTROL, (*(*info).ctrlsdet).refdlpmin_text, SENSITIVE = 0
	WIDGET_CONTROL, (*(*info).ctrlsdet).refdlpmax_text, SENSITIVE = 0
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).savswitch).det_imref_only],labels=['Saving from cube setting']
END

PRO CRISPEX_RETRIEVE_DET_REFCUBE_ONLY, event
; Enables the retreival of detections from the reference cube only
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savswitch).det_imref_only = 2
	WIDGET_CONTROL, (*(*info).ctrlsdet).dlpmin_text, SENSITIVE = 0
	WIDGET_CONTROL, (*(*info).ctrlsdet).dlpmax_text, SENSITIVE = 0
	WIDGET_CONTROL, (*(*info).ctrlsdet).refdlpmin_text, SENSITIVE = ((*(*info).savswitch).pos_dets EQ 3) 
	WIDGET_CONTROL, (*(*info).ctrlsdet).refdlpmax_text, SENSITIVE = ((*(*info).savswitch).pos_dets EQ 3) 
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).savswitch).det_imref_only],labels=['Saving from cube setting']
END

PRO CRISPEX_RETRIEVE_DET_IMREF, event
; Enables the retreival of detections from both the image and the reference cube
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savswitch).det_imref_only = 3
	WIDGET_CONTROL, (*(*info).ctrlsdet).dlpmin_text, SENSITIVE = ((*(*info).savswitch).pos_dets EQ 3) 
	WIDGET_CONTROL, (*(*info).ctrlsdet).dlpmax_text, SENSITIVE = ((*(*info).savswitch).pos_dets EQ 3) 
	WIDGET_CONTROL, (*(*info).ctrlsdet).refdlpmin_text, SENSITIVE = ((*(*info).savswitch).pos_dets EQ 3) 
	WIDGET_CONTROL, (*(*info).ctrlsdet).refdlpmax_text, SENSITIVE = ((*(*info).savswitch).pos_dets EQ 3) 
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).savswitch).det_imref_only],labels=['Saving from cube setting']
END

PRO CRISPEX_RETRIEVE_DET_SEL_LOOPS, event
; Opens the warning windows giving the saving time estimates of the chosen saving procedure, intermediate step towards saving detection loopslabs
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	CRISPEX_SAVE_CHECK_PATH_WRITE, event
	IF ((*(*info).paths).opath_write EQ 1) THEN BEGIN
		*(*(*info).detparams).sel_loops = $
      WHERE(*(*(*info).detparams).sel_dets EQ 1, count)
		(*(*info).detparams).nr_sel_loops = count
    IF (count GT 0) THEN BEGIN
  		IF ((*(*info).savswitch).pos_dets EQ 2) THEN BEGIN
        ; Saving from single wavelength position
  			IF ((*(*info).feedbparams).estimate_run EQ 0) THEN BEGIN
  				CRISPEX_ESTIMATE_TIME_WINDOW, event
  				CRISPEX_ESTIMATE_TIME_CALCULATION, event
  			ENDIF
  			time = 0
  			FOR i=0,(*(*info).detparams).nr_sel_loops-1 DO BEGIN
          xlr_tmp = $
            (*(*(*(*info).detparams).xlr)[(*(*(*info).detparams).sel_loops)[i]])[$
              *,(*(*info).detparams).mid]
          ylr_tmp = $
            (*(*(*(*info).detparams).ylr)[(*(*(*info).detparams).sel_loops)[i]])[$
              *,(*(*info).detparams).mid]
          w_loop_pts =  $
            WHERE((xlr_tmp GE 0) AND (xlr_tmp LT ((*(*info).dataparams).nx)) AND $
                  (ylr_tmp GE 0) AND (ylr_tmp LT ((*(*info).dataparams).ny)), $
                  nw_lpts)
  				sub_time = (*(*info).feedbparams).estimate_time * $
            nw_lpts/FLOAT((*(*info).feedbparams).estimate_lx) * $
            (*(*info).detparams).width * ((*(*info).detparams).delta_t_up + $
  					(*(*info).detparams).delta_t_dn + 1) * $
            CEIL((*(*info).savswitch).det_imref_only/2.)
  				time = time + sub_time
  			ENDFOR
  			CRISPEX_ESTIMATE_FULL_TIME, time, denom, units
  			(*(*info).savswitch).cont = 4
  			CRISPEX_SAVE_WARNING_YESNO, event,$
          STRTRIM((*(*info).detparams).nr_sel_loops,2)+$
          ' detection(s) selected. Saving the exact loop slice(s) may take' ,$
  				'up to about '+STRTRIM(CEIL(time/denom),2)+units+$
          '. Do you wish to continue saving?', $
          OK_EVENT='CRISPEX_SAVE_LOOPSL_CONTINUE', $
          CANCEL_EVENT='CRISPEX_SAVE_LOOPSL_ABORT'
  			IF ((*(*info).winswitch).estimate_win EQ 1) THEN BEGIN
  				WIDGET_CONTROL, (*(*info).winids).estimatetlb, /DESTROY
  				(*(*info).winids).estimatetlb = 0
  				(*(*info).winswitch).estimate_win = 0
  			ENDIF
  		ENDIF ELSE IF ((*(*info).savswitch).pos_dets EQ 1) THEN BEGIN
        ; Saving from all wavelength positions
  			IF ((*(*info).feedbparams).estimate_run EQ 0) THEN BEGIN
  				CRISPEX_ESTIMATE_TIME_WINDOW, event
  				CRISPEX_ESTIMATE_TIME_CALCULATION, event
  			ENDIF
  			time = 0
  			FOR i=0,(*(*info).detparams).nr_sel_loops-1 DO BEGIN
          xlr_tmp = $
            (*(*(*(*info).detparams).xlr)[(*(*(*info).detparams).sel_loops)[i]])[$
              *,(*(*info).detparams).mid]
          ylr_tmp = $
            (*(*(*(*info).detparams).ylr)[(*(*(*info).detparams).sel_loops)[i]])[$
              *,(*(*info).detparams).mid]
          w_loop_pts =  $
            WHERE((xlr_tmp GE 0) AND (xlr_tmp LT ((*(*info).dataparams).nx)) AND $
                  (ylr_tmp GE 0) AND (ylr_tmp LT ((*(*info).dataparams).ny)),$
                  nw_lpts)
  				sub_im_time = (*(*info).feedbparams).estimate_time * $
            nw_lpts/FLOAT((*(*info).feedbparams).estimate_lx) * $
            (*(*info).dataparams).nlp * (*(*info).detparams).width * $
  					((*(*info).detparams).delta_t_up + (*(*info).detparams).delta_t_dn + 1)
  				IF ((*(*info).dataparams).refnt EQ (*(*info).dataparams).nt) THEN $
            sub_ref_time = sub_im_time/(*(*info).dataparams).nlp $
          ELSE $
            sub_ref_time = sub_im_time
  				IF ((*(*info).savswitch).det_imref_only EQ 1) THEN $
            sub_time = sub_im_time $
          ELSE IF ((*(*info).savswitch).det_imref_only EQ 2) THEN $
            sub_time = sub_ref_time $
          ELSE $
            sub_time = sub_im_time + sub_ref_time
  				time += sub_time
  			ENDFOR
  			CRISPEX_ESTIMATE_FULL_TIME, time, denom, units
  			(*(*info).savswitch).cont = 5
  			CRISPEX_SAVE_WARNING_YESNO, event, $
          STRTRIM((*(*info).detparams).nr_sel_loops,2)+$
          ' detection(s) selected. Saving the exact loop slab(s) may take',$
  				'up to about '+STRTRIM(CEIL(time/denom),2)+units+$
          '. Do you wish to continue saving?', $
          OK_EVENT='CRISPEX_SAVE_LOOPSL_CONTINUE', $
          CANCEL_EVENT='CRISPEX_SAVE_LOOPSL_ABORT'
  			IF ((*(*info).winswitch).estimate_win EQ 1) THEN BEGIN
  				WIDGET_CONTROL, (*(*info).winids).estimatetlb, /DESTROY
  				(*(*info).winids).estimatetlb = 0
  				(*(*info).winswitch).estimate_win = 0
  			ENDIF
  		ENDIF ELSE IF ((*(*info).savswitch).pos_dets EQ 3) THEN BEGIN
        ; Saving from selected wavelength range
  			IF ((*(*info).feedbparams).estimate_run EQ 0) THEN BEGIN
  				CRISPEX_ESTIMATE_TIME_WINDOW, event
  				CRISPEX_ESTIMATE_TIME_CALCULATION, event
  			ENDIF
  			time = 0
  			FOR i=0,(*(*info).detparams).nr_sel_loops-1 DO BEGIN
          xlr_tmp = $
            (*(*(*(*info).detparams).xlr)[(*(*(*info).detparams).sel_loops)[i]])[$
              *,(*(*info).detparams).mid]
          ylr_tmp = $
            (*(*(*(*info).detparams).ylr)[(*(*(*info).detparams).sel_loops)[i]])[$
              *,(*(*info).detparams).mid]
          w_loop_pts =  $
            WHERE((xlr_tmp GE 0) AND (xlr_tmp LT ((*(*info).dataparams).nx)) AND $
                  (ylr_tmp GE 0) AND (ylr_tmp LT ((*(*info).dataparams).ny)),$
                  nw_lpts)
  				sub_im_time = (*(*info).feedbparams).estimate_time * $
            nw_lpts/FLOAT((*(*info).feedbparams).estimate_lx) * $
            ((*(*info).detparams).lp_up-(*(*info).detparams).lp_dn+1) * $
  					(*(*info).detparams).width * ((*(*info).detparams).delta_t_up + $
            (*(*info).detparams).delta_t_dn + 1)
  				IF ((*(*info).dataparams).refnt EQ (*(*info).dataparams).nt) THEN $
            sub_ref_time = sub_im_time/((*(*info).detparams).lp_up-$
              (*(*info).detparams).lp_dn+1) $
          ELSE $
            sub_ref_time = sub_im_time
  				IF ((*(*info).savswitch).det_imref_only EQ 1) THEN $
            sub_time = sub_im_time $
          ELSE IF ((*(*info).savswitch).det_imref_only EQ 2) THEN $
            sub_time = sub_ref_time $
          ELSE $
            sub_time = sub_im_time + sub_ref_time
  				time += sub_time
  			ENDFOR
  			CRISPEX_ESTIMATE_FULL_TIME, time, denom, units
  			(*(*info).savswitch).cont = 5
  			CRISPEX_SAVE_WARNING_YESNO, event, $
          STRTRIM((*(*info).detparams).nr_sel_loops,2)+$
          ' detection(s) selected. Saving the exact loop slab(s) may take',$
  				'up to about '+STRTRIM(CEIL(time/denom),2)+units+$
          '. Do you wish to continue saving?', $
          OK_EVENT='CRISPEX_SAVE_LOOPSL_CONTINUE', $
          CANCEL_EVENT='CRISPEX_SAVE_LOOPSL_ABORT'
  			IF ((*(*info).winswitch).estimate_win EQ 1) THEN BEGIN
  				WIDGET_CONTROL, (*(*info).winids).estimatetlb, /DESTROY
  				(*(*info).winids).estimatetlb = 0
  				(*(*info).winswitch).estimate_win = 0
  			ENDIF
  		ENDIF ELSE RETURN
    ENDIF
		IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
      CRISPEX_VERBOSE_GET, event, $
        [(*(*info).detparams).nr_sel_loops,(*(*info).savswitch).cont],$
        labels=['Number of detections','Saving procedure']
	ENDIF
END

PRO CRISPEX_RETRIEVE_DET_DELTA_T_DN, event
; Handles the change in delta_t down from the detection framenumber
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, (*(*info).ctrlsdet).dtmin_text, GET_VALUE = textvalue
	(*(*info).detparams).delta_t_dn = FLOAT(LONG(FLOAT(textvalue[0])))
	IF (((*(*info).detparams).delta_t_dn GE 0) AND ((*(*info).detparams).delta_t_dn LT 1)) THEN (*(*info).detparams).delta_t_dn = 1 
	IF ((*(*info).detparams).delta_t_dn LT 0) THEN (*(*info).detparams).delta_t_dn = FLOAT(LONG(ABS((*(*info).detparams).delta_t_dn)))
	IF ((*(*info).detparams).delta_t_dn GT (*(*info).dispparams).t_last) THEN (*(*info).detparams).delta_t_dn = (*(*info).dispparams).t_last
	WIDGET_CONTROL, (*(*info).ctrlsdet).dtmin_text, SET_VALUE = STRTRIM((*(*info).detparams).delta_t_dn, 2)
	CRISPEX_DISPRANGE_T_RANGE, event
END

PRO CRISPEX_RETRIEVE_DET_DELTA_T_UP, event
; Handles the change in delta_t up from the detection framenumber
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, (*(*info).ctrlsdet).dtmax_text, GET_VALUE = textvalue
	(*(*info).detparams).delta_t_up = FLOAT(LONG(FLOAT(textvalue[0])))
	IF (((*(*info).detparams).delta_t_up GE 0) AND ((*(*info).detparams).delta_t_up LT 1)) THEN (*(*info).detparams).delta_t_up = 1 
	IF ((*(*info).detparams).delta_t_up LT 0) THEN (*(*info).detparams).delta_t_up = FLOAT(LONG(ABS((*(*info).detparams).delta_t_up)))
	IF ((*(*info).detparams).delta_t_up GT (*(*info).dispparams).t_last) THEN (*(*info).detparams).delta_t_up = (*(*info).dispparams).t_last
	WIDGET_CONTROL, (*(*info).ctrlsdet).dtmax_text, SET_VALUE = STRTRIM((*(*info).detparams).delta_t_up, 2)
	CRISPEX_DISPRANGE_T_RANGE, event
END

PRO CRISPEX_RETRIEVE_DET_LP_DN, event
; Handles the change in lower spectral boundary for the detection extraction
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, (*(*info).ctrlsdet).dlpmin_text, GET_VALUE = textvalue
	(*(*info).detparams).lp_dn = FLOAT(textvalue[0])
	IF ((*(*info).detparams).lp_dn LT (*(*info).dispparams).lp_first) THEN (*(*info).detparams).lp_dn = (*(*info).dispparams).lp_first ELSE IF ((*(*info).detparams).lp_dn GE (*(*info).detparams).lp_up) THEN $
		(*(*info).detparams).lp_dn = (*(*info).detparams).lp_up-1
	WIDGET_CONTROL, (*(*info).ctrlsdet).dlpmin_text, SET_VALUE = STRTRIM((*(*info).detparams).lp_dn,2)
	(*(*info).dispparams).lp_low = (*(*info).detparams).lp_dn
	WIDGET_CONTROL, (*(*info).ctrlscp).lower_lp_text, SET_VALUE = STRTRIM((*(*info).dispparams).lp_low,2)
	CRISPEX_DISPRANGE_LP_RANGE, event
END

PRO CRISPEX_RETRIEVE_DET_LP_UP, event
; Handles the change in upper spectral boundary for the detection extraction
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, (*(*info).ctrlsdet).dlpmax_text, GET_VALUE = textvalue
	(*(*info).detparams).lp_up = FLOAT(textvalue[0])
	IF ((*(*info).detparams).lp_up GT (*(*info).dispparams).lp_last) THEN (*(*info).detparams).lp_up = (*(*info).dispparams).lp_last ELSE IF ((*(*info).detparams).lp_up LE (*(*info).detparams).lp_dn) THEN $
		(*(*info).detparams).lp_up = (*(*info).detparams).lp_dn+1
	WIDGET_CONTROL, (*(*info).ctrlsdet).dlpmax_text, SET_VALUE = STRTRIM((*(*info).detparams).lp_up,2)
	(*(*info).dispparams).lp_upp = (*(*info).detparams).lp_up
	WIDGET_CONTROL, (*(*info).ctrlscp).upper_lp_text, SET_VALUE = STRTRIM((*(*info).dispparams).lp_upp,2)
	CRISPEX_DISPRANGE_LP_RANGE, event
END

PRO CRISPEX_RETRIEVE_DET_LP_REF_DN, event
; Handles the change in lower spectral boundary for the detection extraction
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, (*(*info).ctrlsdet).refdlpmin_text, GET_VALUE = textvalue
	(*(*info).detparams).lp_ref_dn = FLOAT(textvalue[0])
	IF ((*(*info).detparams).lp_ref_dn LT (*(*info).dispparams).lp_ref_first) THEN (*(*info).detparams).lp_ref_dn = (*(*info).dispparams).lp_ref_first ELSE $
		IF ((*(*info).detparams).lp_ref_dn GE (*(*info).detparams).lp_ref_up) THEN (*(*info).detparams).lp_ref_dn = (*(*info).detparams).lp_ref_up-1
	WIDGET_CONTROL, (*(*info).ctrlsdet).refdlpmin_text, SET_VALUE = STRTRIM((*(*info).detparams).lp_ref_dn,2)
	(*(*info).dispparams).lp_ref_low = (*(*info).detparams).lp_ref_dn
END

PRO CRISPEX_RETRIEVE_DET_LP_REF_UP, event
; Handles the change in upper spectral boundary for the detection extraction
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, (*(*info).ctrlsdet).refdlpmax_text, GET_VALUE = textvalue
	(*(*info).detparams).lp_ref_up = FLOAT(textvalue[0])
	IF ((*(*info).detparams).lp_ref_up GT (*(*info).dispparams).lp_ref_last) THEN (*(*info).detparams).lp_ref_up = (*(*info).dispparams).lp_ref_last ELSE $
		IF ((*(*info).detparams).lp_ref_up LE (*(*info).detparams).lp_ref_dn) THEN (*(*info).detparams).lp_ref_up = (*(*info).detparams).lp_ref_dn+1
	WIDGET_CONTROL, (*(*info).ctrlsdet).refdlpmax_text, SET_VALUE = STRTRIM((*(*info).detparams).lp_ref_up,2)
	(*(*info).dispparams).lp_ref_upp = (*(*info).detparams).lp_ref_up
END

PRO CRISPEX_RETRIEVE_DET_GET_SLAB, event, inparams, w_lpts_out, gapresult_out, $
  loopslab_out, crossloc_out, loopsize_out, t_det_out, t_low_out, t_upp_out, $
  SAVE_DET=save_det
; Handles the in-program display of the detection loopslab
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	tmp_loopslab = 0
	delta = FLOOR((*(*info).detparams).width/2.)
  ; Set feedback messages and feedback window titles
  IF KEYWORD_SET(SAVE_DET) THEN BEGIN
    IF (inparams.lp_dn EQ inparams.lp_up) THEN $
      save_message = 'slice' $
    ELSE $
      save_message = 'slab'
    feedb_title = 'Saving retrieved detection loop '+save_message+'(s)'
  ENDIF ELSE BEGIN
    feedb_title='Retrieved detection loop slice'
  ENDELSE
  ; Determine w_lpts
  nw_lpts = 0
	FOR k=((*(*info).detparams).mid-delta),((*(*info).detparams).mid+delta) DO BEGIN
    xlr_det = (inparams.xlr)[*,k]
    ylr_det = (inparams.ylr)[*,k]
   w_lpts_tmp =  $
      WHERE((xlr_det GE 0) AND (xlr_det LT (inparams.nx)) AND $
            (ylr_det GE 0) AND (ylr_det LT (inparams.ny)), $
            nw_lpts_tmp)
    IF (nw_lpts GT 0) THEN BEGIN
      IF (nw_lpts_tmp LT nw_lpts) THEN w_lpts_out = w_lpts_tmp
    ENDIF ELSE $
      w_lpts_out = w_lpts_tmp
  ENDFOR
  ; Save time variables
	t_det_out = (*(*(*info).detparams).t)[inparams.idx]
	t_low_out = t_det_out - (*(*info).detparams).delta_t_dn > $
                (*(*info).dispparams).t_first
	t_upp_out = t_det_out + (*(*info).detparams).delta_t_up < $
                (*(*info).dispparams).t_last
  IF KEYWORD_SET(SAVE_DET) THEN BEGIN
    (*(*info).dispparams).t_low = t_low_out
    (*(*info).dispparams).t_upp = t_upp_out
  ENDIF
  pass = 0L
  ; Loop over detection width
	FOR k=((*(*info).detparams).mid-delta),((*(*info).detparams).mid+delta) DO BEGIN
    xlr_det = (inparams.xlr)[*,k]
    ylr_det = (inparams.ylr)[*,k]
    ; If saving or showing exact time slices in-program, call appropriate
    ; routine
		IF (KEYWORD_SET(SAVE_DET) OR (*(*info).dispswitch).exts) THEN BEGIN
			WIDGET_CONTROL,/HOURGLASS
			lp_orig = (*(*info).dataparams).lp
			FOR i=inparams.lp_dn,inparams.lp_up DO BEGIN
        pass += 1L
        ; Set the wavelength index
        IF (inparams.detimref EQ 1) THEN $
				  (*(*info).dataparams).lp = i $
        ELSE $
				  (*(*info).dataparams).lp_ref = i
				CRISPEX_LOOP_GET_EXACT_SLICE, event, *inparams.data, xlr_det, ylr_det, $
          inparams.xlp, inparams.ylp, w_lpts_out, det_loopslice, $
          det_crossloc, det_loopsize, IM=(inparams.detimref EQ 1), $
          NO_NLP=inparams.no_nlp
				IF (i EQ inparams.lp_dn) THEN $
          loopslab = det_loopslice $
        ELSE $
          loopslab = [[[loopslab]], [[det_loopslice]]]
        ; Re-estimate running time and update feedback
				t_1 = SYSTIME(/SECONDS)
				CRISPEX_ESTIMATE_FULL_TIME_RUNNING, pass, inparams.maxpass, $
          inparams.t_0, t_1, denom, units, accumsectime, totalsectime
				feedback_text = 'Detection '+STRTRIM(inparams.idx,2)+', position '+$
          STRTRIM(k,2)+'/'+STRTRIM((*(*info).detparams).width,2)+$
          ': '+STRTRIM(i-inparams.lp_dn+1,2)+'/'+$
          STRTRIM(inparams.lp_up-inparams.lp_dn+1,2)+$
          '('+STRTRIM(pass,2)+'/'+STRTRIM(inparams.maxpass,2)+')'+$
          ' slices extracted in '+$
          STRTRIM(STRING(accumsectime/denom,FORMAT='(3(F9.2,x))'),2)+'/'+$
          STRTRIM(STRING(totalsectime/denom,FORMAT='(3(F9.2,x))'),2)+units
				CRISPEX_UPDATE_USER_FEEDBACK, event, $
          title=feedb_title, var=pass-1, maxvar=inparams.maxpass, $
          feedback_text=feedback_text, DESTROY_TOP=KEYWORD_SET(SAVE_DET)
			ENDFOR
			(*(*info).dataparams).lp = lp_orig
			IF (~KEYWORD_SET(SAVE_DET) AND $
        (k EQ (*(*info).detparams).mid+delta)) THEN $
        CRISPEX_WINDOW_USER_FEEDBACK_CLOSE, event
		ENDIF ELSE BEGIN
      ; If not saving or showing exact time slice, get approximate slice
			CRISPEX_LOOP_GET_APPROX_SLAB, event, xlr_det, ylr_det, inparams.xlp, $
        inparams.ylp, w_lpts_out, loopslab, det_crossloc, det_loopsize
		ENDELSE
		IF (k EQ (*(*info).detparams).mid) THEN BEGIN
			crossloc_out = det_crossloc
			loopsize_out = det_loopsize
		ENDIF
		tmp_loopslab += loopslab
	ENDFOR
  ; If not saving check whether an empty slice needs to be created
  IF (~KEYWORD_SET(SAVE_DET) AND (nw_lpts NE N_ELEMENTS(xlr_det))) THEN $
    *(*(*info).loopsdata).det_empty_slice = $
      MAKE_ARRAY(N_ELEMENTS(xlr_det), (SIZE(loopslab))[2], $
        TYPE=SIZE(*(*(*info).data).imagedata, /TYPE))
  ; Determine the gaps in the path
  gapresult_out = CRISPEX_ARRAY_GET_GAP(w_lpts_out, N_ELEMENTS(xlr_det))
  ; Divide the space-time diagram values by the width of the path
	loopslab_out = tmp_loopslab/(*(*info).detparams).width
END

PRO CRISPEX_RETRIEVE_DET_CANCEL, event
; Handles the closing of the detection file menu
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).loopswitch).retrieve_detfile = 0
	(*(*info).winswitch).showretrdet = 0
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).loopswitch).retrieve_detfile,(*(*info).winids).detsavetlb], labels=['Retrieving detections','retrdettlb was']
	CRISPEX_DISPRANGE_T_RESET, event
	WIDGET_CONTROL, (*(*info).winids).detsavetlb, /DESTROY
	(*(*info).winids).detsavetlb = 0
	IF ((*(*info).winids).retrdettlb GT 0) THEN WIDGET_CONTROL, (*(*info).winids).retrdettlb, /DESTROY
	(*(*info).winids).retrdettlb = 0
	*(*(*info).detparams).sel_dets = REPLICATE(0,(*(*info).detparams).nr_dets)
	(*(*info).overlayswitch).det_overlay_all = 1
	(*(*info).savswitch).pos_dets = 1
	(*(*info).savswitch).det_imref_only = 1
	(*(*info).detparams).lp_dn = (*(*info).dispparams).lp_first		&	(*(*info).detparams).lp_up = (*(*info).dispparams).lp_last
	(*(*info).detparams).lp_ref_dn = (*(*info).dispparams).lp_ref_first	&	(*(*info).detparams).lp_ref_up = (*(*info).dispparams).lp_ref_last
	WIDGET_CONTROL, (*(*info).ctrlscp).det_file_but, /SENSITIVE
	WIDGET_CONTROL, (*(*info).ctrlscp).lower_t_text, SENSITIVE = 1
	WIDGET_CONTROL, (*(*info).ctrlscp).upper_t_text, SENSITIVE = 1
END

;================================================================================= RETRIEVE FROM SAVED LOOP POINT PROCEDURES
PRO CRISPEX_RETRIEVE_LOOP_MENU, event, set_but_array
; Sets up the retrieved loop points menu and reads in the data from the respective files
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	CRISPEX_FIND_CLSAV, event
	IF ((*(*info).retrparams).clfilecount GT 0) THEN BEGIN
		WIDGET_CONTROL,/HOURGLASS
		WIDGET_CONTROL, (*(*info).ctrlscp).sel_saved_loop, SENSITIVE = 0
		(*(*info).loopswitch).retrieve_loops = 1
		filenames = *(*(*info).retrparams).clfiles
		filecount = (*(*info).retrparams).clfilecount
		IF (N_ELEMENTS(set_but_array) NE filecount) THEN $
      *(*(*info).retrparams).sel_loops = INTARR((*(*info).retrparams).clfilecount)
		eventval = INDGEN(filecount)
		base = WIDGET_BASE(TITLE = 'CRISPEX'+(*(*info).sesparams).instance_label+$
      ': Save from retrieved loop(s)', GROUP_LEADER = (*(*info).winids).root, $
      TLB_FRAME_ATTR = 1, /TLB_KILL_REQUEST_EVENTS)
		disp = WIDGET_BASE(base, /COLUMN)
		disp2 = WIDGET_BASE(disp, /COLUMN, /FRAME)
		sel_allnone = WIDGET_BASE(disp2, /ROW)
		sel_allnone_lab = WIDGET_LABEL(sel_allnone, VALUE = 'Select:', /ALIGN_LEFT)
		sel_allnone_buts = WIDGET_BASE(sel_allnone, /ROW, /EXCLUSIVE)
		(*(*info).ctrlsloop).sel_all = WIDGET_BUTTON(sel_allnone_buts, $
      VALUE = 'All', EVENT_PRO = 'CRISPEX_RETRIEVE_LOOP_SEL_ALL')
		(*(*info).ctrlsloop).sel_none = WIDGET_BUTTON(sel_allnone_buts, $
      VALUE = 'None', EVENT_PRO = 'CRISPEX_RETRIEVE_LOOP_SEL_NONE')
		WIDGET_CONTROL, (*(*info).ctrlsloop).sel_none, /SET_BUTTON
		update_filelist = WIDGET_BUTTON(sel_allnone, VALUE = 'Update filelist', $
      EVENT_PRO = 'CRISPEX_RETRIEVE_LOOP_UPDATE_FILELIST')
    sel_buts = WIDGET_BASE(disp2, /COLUMN, /NONEXCLUSIVE, $
      X_SCROLL_SIZE=(filecount GT 16)*400, Y_SCROLL_SIZE=(filecount GT 16)*425) 
    ; Initialise variables
    *(*(*info).retrparams).xlp = PTRARR(filecount, /ALLOCATE_HEAP)
    *(*(*info).retrparams).ylp = PTRARR(filecount, /ALLOCATE_HEAP)
    *(*(*info).retrparams).xlr = PTRARR(filecount, /ALLOCATE_HEAP)
    *(*(*info).retrparams).ylr = PTRARR(filecount, /ALLOCATE_HEAP)
		FOR i=0,filecount-1 DO BEGIN
			IF (N_ELEMENTS(set_but_array) NE filecount) THEN $
        (*(*(*info).retrparams).sel_loops)[i] = 0
			singlefilename = $
        (STRSPLIT((*(*(*info).retrparams).clfiles)[i], PATH_SEP(), /EXTRACT))[$
        N_ELEMENTS(STRSPLIT((*(*(*info).retrparams).clfiles)[i], PATH_SEP(), $
        /EXTRACT))-1]
			name = 'sel_but_'+STRTRIM(i,2)
			but_val = 'L'+STRTRIM(i,2)+': '+singlefilename
			sel_but = WIDGET_BUTTON(sel_buts, VALUE = but_val, UVALUE = eventval[i], $
        EVENT_PRO = 'CRISPEX_RETRIEVE_LOOP_MENU_EVENT', UNAME = name) 
			IF (N_ELEMENTS(set_but_array) GT 0) THEN $
        WIDGET_CONTROL, sel_but, SET_BUTTON = set_but_array[i]
			RESTORE,(*(*(*info).retrparams).clfiles)[i]
      ; Support for different saving methods of xp and yp points
      IF (SIZE(x_coords,/N_DIMENSIONS) EQ 2) THEN x_coords = REFORM(x_coords[0,*])
      IF (SIZE(y_coords,/N_DIMENSIONS) EQ 2) THEN y_coords = REFORM(y_coords[0,*])
			*(*(*(*info).retrparams).xlp)[i] = x_coords
			*(*(*(*info).retrparams).ylp)[i] = y_coords
			*(*(*(*info).retrparams).xlr)[i] = x_loop_pts
			*(*(*(*info).retrparams).ylr)[i] = y_loop_pts
		ENDFOR
		spectral_pos = WIDGET_BASE(disp, /ROW, /FRAME, /EXCLUSIVE)
		(*(*info).ctrlsloop).all_pos = WIDGET_BUTTON(spectral_pos, $
      VALUE = 'At all spectral positions', EVENT_PRO = 'CRISPEX_RETRIEVE_LOOP_ALL_POS')
		WIDGET_CONTROL, (*(*info).ctrlsloop).all_pos, /SET_BUTTON
		(*(*info).ctrlsloop).saved_pos = WIDGET_BUTTON(spectral_pos, $
      VALUE = 'At saved spectral position')
		del_clsav = WIDGET_BASE(disp, /ROW, /FRAME, /EXCLUSIVE)
		(*(*info).ctrlsloop).del_files = WIDGET_BUTTON(del_clsav, $
      VALUE = 'Delete *clsav file(s) after saving',  $
      EVENT_PRO = 'CRISPEX_RETRIEVE_LOOP_DELETE_CLSAV')
		WIDGET_CONTROL, (*(*info).ctrlsloop).del_files, /SET_BUTTON
		(*(*info).ctrlsloop).keep_files = WIDGET_BUTTON(del_clsav, $
      VALUE = 'Keep *clsav file(s) after saving')
		save_cube = WIDGET_BASE(disp, /ROW, /FRAME)
		save_cube_lab = WIDGET_LABEL(save_cube, VALUE = 'Save from: ')
		save_cube_but = WIDGET_BASE(save_cube, /ROW, /EXCLUSIVE)
		(*(*info).ctrlsloop).save_imonly = WIDGET_BUTTON(save_cube_but, $
      VALUE = 'IMCUBE only', EVENT_PRO = 'CRISPEX_RETRIEVE_LOOP_IMCUBE_ONLY', $
      /NO_RELEASE)
		WIDGET_CONTROL, (*(*info).ctrlsloop).save_imonly, /SET_BUTTON
		refsens = (*(*info).winswitch).showref AND ((*(*info).dataparams).refnt GT 1)
		(*(*info).ctrlsloop).save_refonly = WIDGET_BUTTON(save_cube_but, $
      VALUE = 'REFCUBE only', EVENT_PRO = 'CRISPEX_RETRIEVE_LOOP_REFCUBE_ONLY',$
      SENSITIVE = refsens, /NO_RELEASE)
		(*(*info).ctrlsloop).save_imref = WIDGET_BUTTON(save_cube_but, $
      VALUE = 'both cubes', EVENT_PRO = 'CRISPEX_RETRIEVE_LOOP_IMREF', $
      SENSITIVE = refsens, /NO_RELEASE)
		dec_buts = WIDGET_BASE(disp, COLUMN=3, /GRID_LAYOUT, /ALIGN_CENTER)
		change_path_but = WIDGET_BUTTON(dec_buts, VALUE = 'Change path', $
      EVENT_PRO = 'CRISPEX_SAVE_SET_OPATH')
		cancel = WIDGET_BUTTON(dec_buts, VALUE = 'Cancel', $
      EVENT_PRO = 'CRISPEX_RETRIEVE_LOOP_MENU_CANCEL')
		get_loops = WIDGET_BUTTON(dec_buts, VALUE = 'Retrieve and save', $
      EVENT_PRO = 'CRISPEX_RETRIEVE_LOOP_MENU_CONTINUE', SENSITIVE = 0)
		(*(*info).ctrlsloop).get_loops = get_loops
		WIDGET_CONTROL, base, /REALIZE, $
      TLB_SET_XOFFSET=(*(*info).winsizes).spxoffset, TLB_SET_YOFFSET = 0
		WIDGET_CONTROL, base, SET_UVALUE = info
		XMANAGER, 'CRISPEX', base, /NO_BLOCK
		(*(*info).winids).savetlb = base
		IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
      CRISPEX_VERBOSE_GET, event, [(*(*info).winids).savetlb,filecount,$
      (*(*info).loopswitch).restore_loops],$
      labels=['savetlb','Retrieved loops','Was restoring loops']
	ENDIF ELSE BEGIN
		CRISPEX_WINDOW_OK, event,'ERROR!','No saved loop points (*.clsav) files found.', $
      OK_EVENT='CRISPEX_CLOSE_EVENT_WINDOW', BASE=tlb
		(*(*info).winids).errtlb = tlb
	ENDELSE
	IF (*(*info).loopswitch).restore_loops THEN BEGIN
		(*(*info).loopswitch).was_restore_loops = (*(*info).loopswitch).restore_loops
		(*(*info).loopswitch).restore_loops = 0
	ENDIF
END

PRO CRISPEX_RETRIEVE_LOOP_MENU_EVENT, event
; Handles the selection of a certain retrieved loop point file
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, event.ID, GET_UVALUE = eventval
	(*(*(*info).retrparams).sel_loops)[eventval] = ( (*(*(*info).retrparams).sel_loops)[eventval] EQ 0)
	condition = WHERE(*(*(*info).retrparams).sel_loops EQ 1, count)
	WIDGET_CONTROL, (*(*info).ctrlsloop).get_loops, SENSITIVE = (count GT 0)
	WIDGET_CONTROL, (*(*info).ctrlsloop).sel_all, SET_BUTTON = (count EQ (*(*info).retrparams).clfilecount) 
	WIDGET_CONTROL, (*(*info).ctrlsloop).sel_none, SET_BUTTON = ABS((count GT 0)-1)
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [eventval,(*(*(*info).retrparams).sel_loops)[eventval],$
		(((N_ELEMENTS(condition) GT 0) AND (TOTAL(condition) NE -1)) AND (N_ELEMENTS(condition) EQ (*(*info).retrparams).clfilecount)),ABS(((N_ELEMENTS(condition) GT 0) AND (TOTAL(condition) NE -1))-1),$
		N_ELEMENTS(condition)-(TOTAL(condition) EQ -1)], labels=['Retrieved loop ID','Retreived loop selected','All selected','None selected','Total selected']
	CRISPEX_DRAW_IMREF, event
END

PRO CRISPEX_RETRIEVE_LOOP_MENU_CANCEL, event
; Handles the closing of the retrieved loop menu
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, (*(*info).ctrlscp).sel_saved_loop, SENSITIVE = 1
	(*(*info).loopswitch).retrieve_loops = 0
	(*(*info).loopswitch).restore_loops = (*(*info).loopswitch).was_restore_loops
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).loopswitch).retrieve_loops,(*(*info).winids).savetlb,(*(*info).loopswitch).restore_loops], $
		labels=['Retrieving loops','savetlb was','Restoring loops']
	CRISPEX_UPDATE_T, event
	CRISPEX_DRAW_IMREF, event
	WIDGET_CONTROL, (*(*info).winids).savetlb, /DESTROY
	(*(*info).winids).savetlb = 0
END

PRO CRISPEX_RETRIEVE_LOOP_MENU_CONTINUE, event
; Opens the warning windows giving the saving time estimates of the chosen saving procedure, intermediate step towards saving selected retrieved loopslabs
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	CRISPEX_SAVE_CHECK_PATH_WRITE, event
	IF ((*(*info).paths).opath_write EQ 1) THEN BEGIN
    whereretr = WHERE(*(*(*info).retrparams).sel_loops EQ 1, count)
    IF (count GT 0) THEN BEGIN
  		*(*(*info).retrparams).retrieve_files = (*(*(*info).retrparams).clfiles)[whereretr]
  		(*(*info).retrparams).retrieve_filecount = N_ELEMENTS(*(*(*info).retrparams).retrieve_files)
  		IF ((*(*info).savswitch).all_pos_loops EQ 0) THEN BEGIN
  			IF ((*(*info).feedbparams).estimate_run EQ 0) THEN BEGIN
  				CRISPEX_ESTIMATE_TIME_WINDOW, event
  				CRISPEX_ESTIMATE_TIME_CALCULATION, event
  			ENDIF
  			time = 0
  			FOR i=0,(*(*info).retrparams).retrieve_filecount-1 DO BEGIN
  				RESTORE,(*(*(*info).retrparams).retrieve_files)[i]
  				sub_time = (*(*info).feedbparams).estimate_time * N_ELEMENTS(w_loop_pts)/FLOAT((*(*info).feedbparams).estimate_lx) * (*(*info).dispparams).t_range * CEIL((*(*info).savswitch).imref_only/2.)
  				time += sub_time
  			ENDFOR
  			CRISPEX_ESTIMATE_FULL_TIME, time, denom, units
  			(*(*info).savswitch).cont = 1
  			CRISPEX_SAVE_WARNING_YESNO, event, STRTRIM((*(*info).retrparams).retrieve_filecount,2)+' *clsav file(s) selected. Saving the exact loop slice(s) may take',$
  				'up to about '+STRTRIM(CEIL(time/denom),2)+units+' and equally named (approximated) loop','slice(s) may be overwritten. Do you wish to continue saving?', $
  				OK_EVENT='CRISPEX_SAVE_LOOPSL_CONTINUE', CANCEL_EVENT='CRISPEX_SAVE_LOOPSL_ABORT'
  			IF ((*(*info).winswitch).estimate_win EQ 1) THEN BEGIN
  				WIDGET_CONTROL, (*(*info).winids).estimatetlb, /DESTROY
  				(*(*info).winids).estimatetlb = 0
  				(*(*info).winswitch).estimate_win = 0
  			ENDIF
  		ENDIF ELSE IF (*(*info).savswitch).all_pos_loops THEN BEGIN
  			IF ((*(*info).feedbparams).estimate_run EQ 0) THEN BEGIN
  				CRISPEX_ESTIMATE_TIME_WINDOW, event
  				CRISPEX_ESTIMATE_TIME_CALCULATION, event
  			ENDIF
  			time = 0
  			FOR i=0,(*(*info).retrparams).retrieve_filecount-1 DO BEGIN
  				RESTORE,(*(*(*info).retrparams).retrieve_files)[i]
  				sub_im_time = (*(*info).feedbparams).estimate_time * N_ELEMENTS(w_loop_pts)/FLOAT((*(*info).feedbparams).estimate_lx) * (*(*info).dataparams).nlp * (*(*info).dispparams).t_range
  				IF ((*(*info).dataparams).refnt EQ (*(*info).dataparams).nt) THEN sub_ref_time = (*(*info).feedbparams).estimate_time * N_ELEMENTS(w_loop_pts)/FLOAT((*(*info).feedbparams).estimate_lx) * $
  					(*(*info).dispparams).t_range ELSE sub_ref_time = sub_im_time
  				IF ((*(*info).savswitch).imref_only EQ 1) THEN sub_time = sub_im_time ELSE IF ((*(*info).savswitch).imref_only EQ 2) THEN sub_time = sub_ref_time ELSE sub_time = sub_im_time + sub_ref_time
  				time += sub_time
  			ENDFOR
  			CRISPEX_ESTIMATE_FULL_TIME, time, denom, units
  			(*(*info).savswitch).cont = 2
  			CRISPEX_SAVE_WARNING_YESNO, event, STRTRIM((*(*info).retrparams).retrieve_filecount,2)+' *clsav file(s) selected. Saving the exact loop slab(s) may take',$
  				'up to about '+STRTRIM(CEIL(time/denom),2)+units+' and equally named (approximated) loop','slab(s) may be overwritten. Do you wish to continue saving?',$
  				OK_EVENT='CRISPEX_SAVE_LOOPSL_CONTINUE', CANCEL_EVENT='CRISPEX_SAVE_LOOPSL_ABORT'
  			IF ((*(*info).winswitch).estimate_win EQ 1) THEN BEGIN
  				WIDGET_CONTROL, (*(*info).winids).estimatetlb, /DESTROY
  				(*(*info).winids).estimatetlb = 0
  				(*(*info).winswitch).estimate_win = 0
  			ENDIF
  		ENDIF ELSE RETURN
    ENDIF
		IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).retrparams).retrieve_filecount,(*(*info).savswitch).cont],labels=['Number of retrieved loops','Saving procedure']
	ENDIF
END

PRO CRISPEX_RETRIEVE_LOOP_SEL_ALL, event
; Handles the selection of all retrieved loop files
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	*(*(*info).retrparams).sel_loops = REPLICATE(1,(*(*info).retrparams).clfilecount)
	WIDGET_CONTROL, (*(*info).ctrlsloop).get_loops, SENSITIVE = 1
	FOR i=0,(*(*info).retrparams).clfilecount-1 DO BEGIN
		name = 'sel_but_'+STRTRIM(i,2)
		WIDGET_CONTROL, WIDGET_INFO(event.TOP, FIND_BY_UNAME = name), SET_BUTTON = 1
	ENDFOR		
	CRISPEX_DRAW_IMREF, event
END

PRO CRISPEX_RETRIEVE_LOOP_SEL_NONE, event
; Handles the selection of no retrieved loop files
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	*(*(*info).retrparams).sel_loops = REPLICATE(0,(*(*info).retrparams).clfilecount)
	WIDGET_CONTROL, (*(*info).ctrlsloop).get_loops, SENSITIVE = 0
	FOR i=0,(*(*info).retrparams).clfilecount-1 DO BEGIN
		name = 'sel_but_'+STRTRIM(i,2)
		WIDGET_CONTROL, WIDGET_INFO(event.TOP, FIND_BY_UNAME = name), SET_BUTTON = 0
	ENDFOR		
	CRISPEX_DRAW_IMREF, event
END

PRO CRISPEX_RETRIEVE_LOOP_UPDATE_FILELIST, event
; Handles the update of the retrieved file list
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, (*(*info).winids).root, SET_UVALUE = info
	WIDGET_CONTROL, event.TOP, /DESTROY
	event.TOP = (*(*info).winids).root
	CRISPEX_RETRIEVE_LOOP_MENU, event
	CRISPEX_DRAW_IMREF, event
END

PRO CRISPEX_RETRIEVE_LOOP_DELETE_CLSAV, event
; Enables or disables the deletion of CLSAV files after saving the respective loopslabs
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savswitch).delete_clsav = event.SELECT
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).savswitch).delete_clsav],labels=['Delete loop path file']
END

PRO CRISPEX_RETRIEVE_LOOP_ALL_POS, event
; Enables the extraction of the retrieved loop at all or only the saved spectral positions
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savswitch).all_pos_loops = event.SELECT
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).savswitch).all_pos_loops],labels=['Saving spectral position setting']
END

PRO CRISPEX_RETRIEVE_LOOP_IMCUBE_ONLY, event
; Enables the retreival of loop paths from the image cube only
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savswitch).imref_only = 1
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).savswitch).imref_only],labels=['Saving from cube setting']
END

PRO CRISPEX_RETRIEVE_LOOP_REFCUBE_ONLY, event
; Enables the retreival of loop paths from the reference cube only
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savswitch).imref_only = 2
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).savswitch).imref_only],labels=['Saving from cube setting']
END

PRO CRISPEX_RETRIEVE_LOOP_IMREF, event
; Enables the retreival of loop paths from both the image and reference cube
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savswitch).imref_only = 3
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).savswitch).imref_only],labels=['Saving from cube setting']
END

PRO CRISPEX_RETRIEVE_LOOP_ALL_LOOPSLAB, event
; Opens the warning windows giving the saving time estimate of the procedure, intermediate step towards saving all retrieved loopslabs (i.e. at all spectral positions)
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF ((*(*info).retrparams).clfilecount GT 0) THEN BEGIN
		CRISPEX_SAVE_CHECK_PATH_WRITE, event
		IF ((*(*info).paths).opath_write EQ 1) THEN BEGIN
			(*(*info).savparams).lp_orig = (*(*info).dataparams).lp
			(*(*info).retrparams).retrieve_filecount = (*(*info).retrparams).clfilecount
			*(*(*info).retrparams).retrieve_files = *(*(*info).retrparams).clfiles
			IF ((*(*info).feedbparams).estimate_run EQ 0) THEN BEGIN
				CRISPEX_ESTIMATE_TIME_WINDOW, event
				CRISPEX_ESTIMATE_TIME_CALCULATION, event
			ENDIF
			time = 0
			FOR i=0,(*(*info).retrparams).retrieve_filecount-1 DO BEGIN
				RESTORE,(*(*(*info).retrparams).retrieve_files)[i]
				sub_time = (*(*info).feedbparams).estimate_time * N_ELEMENTS(w_loop_pts)/FLOAT((*(*info).feedbparams).estimate_lx) * (*(*info).dataparams).nlp * (*(*info).dispparams).t_range
				time += sub_time
			ENDFOR
			(*(*info).savswitch).cont = 2
			CRISPEX_ESTIMATE_FULL_TIME, time, denom, units
			CRISPEX_SAVE_WARNING_YESNO, event, STRTRIM((*(*info).retrparams).retrieve_filecount,2)+' *clsav file(s) found. Saving the exact loop slab(s) may take',$
				'up to about '+STRTRIM(CEIL(time/denom),2)+units+' and equally named (approximated) loop','slab(s) may be overwritten. Do you wish to continue saving?',$
				OK_EVENT='CRISPEX_SAVE_LOOPSL_CONTINUE', CANCEL_EVENT='CRISPEX_SAVE_LOOPSL_ABORT'
			IF ((*(*info).winswitch).estimate_win EQ 1) THEN BEGIN
				WIDGET_CONTROL, (*(*info).winids).estimatetlb, /DESTROY
				(*(*info).winids).estimatetlb = 0
				(*(*info).winswitch).estimate_win = 0
			ENDIF
			(*(*info).dataparams).lp = (*(*info).savparams).lp_orig
		ENDIF
		IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).retrparams).retrieve_filecount,(*(*info).savswitch).cont],labels=['Number of retrieved loops','Saving procedure']
	ENDIF
END

PRO CRISPEX_RETRIEVE_LOOP_ALL_LOOPSLICE, event
; Opens the warning windows giving the saving time estimate of the procedure, intermediate step towards saving all retrieved loopslices (i.e. at saved spectral positions)
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	CRISPEX_FIND_CLSAV, event
	IF ((*(*info).retrparams).clfilecount GT 0) THEN BEGIN
		CRISPEX_SAVE_CHECK_PATH_WRITE, event
		IF ((*(*info).paths).opath_write EQ 1) THEN BEGIN
			(*(*info).retrparams).retrieve_filecount = (*(*info).retrparams).clfilecount
			*(*(*info).retrparams).retrieve_files = *(*(*info).retrparams).clfiles
			IF ((*(*info).feedbparams).estimate_run EQ 0) THEN BEGIN
				CRISPEX_ESTIMATE_TIME_WINDOW, event
				CRISPEX_ESTIMATE_TIME_CALCULATION, event
			ENDIF
			time = 0
			FOR i=0,(*(*info).retrparams).retrieve_filecount-1 DO BEGIN
				RESTORE,(*(*(*info).retrparams).retrieve_files)[i]
				sub_time = (*(*info).feedbparams).estimate_time * N_ELEMENTS(w_loop_pts)/FLOAT((*(*info).feedbparams).estimate_lx) * (*(*info).dispparams).t_range
				time += sub_time
			ENDFOR
			(*(*info).savswitch).cont = 1
			CRISPEX_ESTIMATE_FULL_TIME, time, denom, units
			CRISPEX_SAVE_WARNING_YESNO, event, STRTRIM((*(*info).retrparams).retrieve_filecount,2)+' *clsav file(s) found. Saving the exact loop slice(s) may take',$
				'up to about '+STRTRIM(CEIL(time/denom),2)+units+' and equally named (approximated) loop','slice(s) may be overwritten. Do you wish to continue saving?',$
				OK_EVENT='CRISPEX_SAVE_LOOPSL_CONTINUE', CANCEL_EVENT='CRISPEX_SAVE_LOOPSL_ABORT'
			IF ((*(*info).winswitch).estimate_win EQ 1) THEN BEGIN
				WIDGET_CONTROL, (*(*info).winids).estimatetlb, /DESTROY
				(*(*info).winids).estimatetlb = 0
				(*(*info).winswitch).estimate_win = 0
			ENDIF
		ENDIF
		IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).retrparams).retrieve_filecount,(*(*info).savswitch).cont],labels=['Number of retrieved loops','Saving procedure']
	ENDIF
END

;========================= IMAGE SCALING PROCEDURES
PRO CRISPEX_SCALING_SELECT_DATA, event
; Handles the selection of scaling 
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  ;index = {0,1,2,3} -> Main, reference, Doppler, slit-jaw
  (*(*info).scaling).imrefscaling = event.INDEX
  (*(*info).scaling).idx = $
    (((*(*info).scaling).imrefscaling EQ 0) OR ((*(*info).scaling).imrefscaling EQ 2)) * $
    (*(*info).intparams).lp_diag_all + $
    (((*(*info).scaling).imrefscaling GT 0) + ((*(*info).scaling).imrefscaling GT 2)) * $
    (*(*info).intparams).ndiagnostics + $
    ((*(*info).scaling).imrefscaling EQ 1) * (*(*info).intparams).lp_ref_diag_all + $
    ((*(*info).scaling).imrefscaling GT 1) * (*(*info).intparams).nrefdiagnostics 
	CRISPEX_SCALING_SET_BOXBUTTONS, event
	CRISPEX_SCALING_SET_SLIDERS, event
END

PRO CRISPEX_SCALING_SELECT_TYPE, event
; Handles the selection of scaling 
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  ;index = {0,1,2} -> Based on first, based on current, per time step
  (*(*(*info).scaling).imagescale)[(*(*info).scaling).imrefscaling] = event.INDEX
  CRISPEX_SCALING_APPLY_SELECTED, event
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).scaling).imrefscaling,$
    (*(*(*info).scaling).imagescale)[(*(*info).scaling).imrefscaling]],$
		labels=['Scaling image','Scaling setting']
	CRISPEX_SCALING_REDRAW, event
END

PRO CRISPEX_SCALING_APPLY_SELECTED, event
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  ; Main image
  idx = (*(*info).intparams).lp_diag_all
  IF ((*(*(*info).scaling).imagescale)[0] EQ 0) THEN BEGIN
    minmax_data = (*(*(*info).data).imagedata)[$
      (*(*info).dataparams).s * (*(*info).dataparams).nlp + (*(*info).dataparams).lp]
    minmax = CRISPEX_SCALING_SLICES(minmax_data, (*(*info).scaling).gamma[idx], $
      (*(*info).scaling).histo_opt_val[idx], /FORCE_HISTO)
    (*(*info).scaling).imagemin = minmax[0]
    (*(*info).scaling).imagemax = minmax[1]
  ENDIF ELSE IF ((*(*(*info).scaling).imagescale)[0] EQ 1) THEN BEGIN
    minmax_data = *(*(*info).data).xyslice
    minmax = CRISPEX_SCALING_SLICES(minmax_data, (*(*info).scaling).gamma[idx], $
      (*(*info).scaling).histo_opt_val[idx], /FORCE_HISTO)
    (*(*info).scaling).imagemin_curr = minmax[0]
    (*(*info).scaling).imagemax_curr = minmax[1]
  ENDIF
  ; Reference image
  IF (*(*info).winswitch).showref THEN BEGIN
    idx = (*(*info).intparams).ndiagnostics + (*(*info).intparams).lp_ref_diag_all
    IF ((*(*(*info).scaling).imagescale)[1] EQ 0) THEN BEGIN
      minmax_data = (*(*(*info).data).refdata)[(*(*info).dataparams).lp_ref]
      minmax = CRISPEX_SCALING_SLICES(minmax_data, (*(*info).scaling).gamma[idx], $
        (*(*info).scaling).histo_opt_val[idx], /FORCE_HISTO)
      (*(*info).scaling).refmin = minmax[0]
      (*(*info).scaling).refmax = minmax[1]
    ENDIF ELSE IF ((*(*(*info).scaling).imagescale)[1] EQ 1) THEN BEGIN
      minmax_data = *(*(*info).data).refslice
      minmax = CRISPEX_SCALING_SLICES(minmax_data, (*(*info).scaling).gamma[idx], $
        (*(*info).scaling).histo_opt_val[idx], /FORCE_HISTO)
      (*(*info).scaling).refmin_curr = minmax[0]
      (*(*info).scaling).refmax_curr = minmax[1]
    ENDIF
  ENDIF
  ; Doppler image
  IF (*(*info).winswitch).showdop THEN BEGIN
    idx = (*(*info).intparams).ndiagnostics + $
      (*(*info).intparams).nrefdiagnostics + (*(*info).intparams).lp_diag_all
    IF ((*(*(*info).scaling).imagescale)[2] EQ 0) THEN BEGIN
      minmax_data = (*(*info).data).dopplerscan[*,*,$
        (*(*info).dataparams).s * (*(*info).dataparams).nlp + (*(*info).dataparams).lp]
      minmax = CRISPEX_SCALING_SLICES(minmax_data, (*(*info).scaling).gamma[idx], $
        (*(*info).scaling).histo_opt_val[idx], /FORCE_HISTO)
      (*(*info).scaling).dopmin = minmax[0]
      (*(*info).scaling).dopmax = minmax[1]
    ENDIF ELSE IF ((*(*(*info).scaling).imagescale)[2] EQ 1) THEN BEGIN
      minmax_data = *(*(*info).data).dopslice
      minmax = CRISPEX_SCALING_SLICES(minmax_data, (*(*info).scaling).gamma[idx], $
        (*(*info).scaling).histo_opt_val[idx], /FORCE_HISTO)
      (*(*info).scaling).dopmin_curr = minmax[0]
      (*(*info).scaling).dopmax_curr = minmax[1]
    ENDIF
  ENDIF
  ; SJI image
  IF (*(*info).winswitch).showsji THEN BEGIN
    idx = 2*(*(*info).intparams).ndiagnostics + (*(*info).intparams).nrefdiagnostics
    IF ((*(*(*info).scaling).imagescale)[3] EQ 0) THEN BEGIN
      minmax_data = (*(*(*info).data).sjidata)[0]
    ; If SJI data is scaled integer, descale and convert to float
    IF (*(*info).dispswitch).sjiscaled THEN $
      minmax_data = CRISPEX_SCALING_DESCALE(minmax_data, (*(*info).dispparams).sjibscale, $
        (*(*info).dispparams).sjibzero)
      minmax = CRISPEX_SCALING_SLICES(minmax_data, (*(*info).scaling).gamma[idx], $
        (*(*info).scaling).histo_opt_val[idx], /FORCE_HISTO)
      (*(*info).scaling).sjimin = minmax[0]
      (*(*info).scaling).sjimax = minmax[1]
    ENDIF ELSE IF ((*(*(*info).scaling).imagescale)[3] EQ 1) THEN BEGIN
      minmax_data = *(*(*info).data).sjislice
      minmax = CRISPEX_SCALING_SLICES(minmax_data, (*(*info).scaling).gamma[idx], $
        (*(*info).scaling).histo_opt_val[idx], /FORCE_HISTO)
      (*(*info).scaling).sjimin_curr = minmax[0]
      (*(*info).scaling).sjimax_curr = minmax[1]
    ENDIF
  ENDIF
END

PRO CRISPEX_SCALING_HISTO_OPT_VALUE, event
; Handles the setting of the HISTO_OPT parameter
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, (*(*info).ctrlscp).histo_opt_txt, GET_VALUE = textvalue
  textvalue = FLOAT(textvalue[0])
	(*(*info).scaling).histo_opt_val[(*(*info).scaling).idx] = FLOAT(textvalue[0])
  CRISPEX_SCALING_APPLY_SELECTED, event
  CRISPEX_SCALING_REDRAW, event
END

PRO CRISPEX_SCALING_SLIDER_MIN, event
; Handles events from the minimum scaling value slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  idx = (*(*info).scaling).idx
  (*(*info).scaling).minimum[idx] = event.VALUE
  IF ((*(*info).scaling).minimum[idx] GE (*(*info).scaling).maximum[idx]) THEN BEGIN
    (*(*info).scaling).maximum[idx] = (*(*info).scaling).minimum[idx] + 1
    CRISPEX_SCALING_SET_SLIDERS, event
  ENDIF
  CRISPEX_SCALING_APPLY_SELECTED, event
  CRISPEX_SCALING_REDRAW, event
  ; CRISPEX_DRAW, event
END

PRO CRISPEX_SCALING_SLIDER_MAX, event
; Handles events from the minimum scaling value slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  idx = (*(*info).scaling).idx
  (*(*info).scaling).maximum[idx] = event.VALUE
  IF ((*(*info).scaling).maximum[idx] LE (*(*info).scaling).minimum[idx]) THEN BEGIN
    (*(*info).scaling).minimum[idx] = (*(*info).scaling).maximum[idx] - 1
    CRISPEX_SCALING_SET_SLIDERS, event
  ENDIF
  CRISPEX_SCALING_APPLY_SELECTED, event
  CRISPEX_SCALING_REDRAW, event
  ; CRISPEX_DRAW, event
END

PRO CRISPEX_SCALING_GAMMA_SLIDER, event
; Handles events from the minimum scaling value slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  (*(*info).scaling).gamma[(*(*info).scaling).idx] = 10.^((FLOAT(event.VALUE)/500.) - 1.)
  WIDGET_CONTROL, (*(*info).ctrlscp).gamma_label, $
    SET_VALUE=STRING((*(*info).scaling).gamma[(*(*info).scaling).idx],FORMAT='(F6.3)')
  CRISPEX_SCALING_APPLY_SELECTED, event
  CRISPEX_SCALING_REDRAW, event
END

PRO CRISPEX_SCALING_RESET_DEFAULTS, event, IDX=idx, NO_DRAW=no_draw
; Handles events from the minimum scaling value slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  IF (N_ELEMENTS(IDX) NE 1) THEN idx = (*(*info).scaling).idx
  ; Reset contrast value
  (*(*info).scaling).minimum[idx] = 0
  (*(*info).scaling).maximum[idx] = 100
  (*(*info).scaling).gamma[idx] = (*(*info).prefs).default_gamma_val
  (*(*info).scaling).histo_opt_val[idx] = (*(*info).prefs).default_histo_opt_val
  IF ~KEYWORD_SET(NO_DRAW) THEN BEGIN
    CRISPEX_SCALING_APPLY_SELECTED, event
    CRISPEX_SCALING_SET_BOXBUTTONS, event
    CRISPEX_SCALING_SET_SLIDERS, event
    CRISPEX_SCALING_REDRAW, event
  ENDIF
END 

PRO CRISPEX_SCALING_RESET_ALL_DEFAULTS, event
; Handles events from the minimum scaling value slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  FOR i=0,N_ELEMENTS((*(*info).scaling).gamma)-1 DO $
    CRISPEX_SCALING_RESET_DEFAULTS, event, IDX=i, $
    NO_DRAW=(i NE (N_ELEMENTS((*(*info).scaling).gamma)-1))
END 

PRO CRISPEX_SCALING_REDRAW, event
; Handles the redrawing of window contents after adjustment of scaling
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF ((*(*info).scaling).imrefscaling EQ 0) THEN BEGIN
		CRISPEX_DRAW_XY, event 
		IF (*(*info).winswitch).showsp THEN BEGIN
      CRISPEX_UPDATE_SPSLICE, event
      CRISPEX_DRAW_SPECTRAL_MAIN, event, /SP_ONLY
    ENDIF
		IF (*(*info).winswitch).showphis THEN BEGIN
      CRISPEX_UPDATE_PHISLICE, event, /NO_DRAW
      CRISPEX_DRAW_PHIS, event 
    ENDIF
	ENDIF ELSE BEGIN
		IF (*(*info).winswitch).showref THEN CRISPEX_DRAW_REF, event
		IF (*(*info).winswitch).showrefsp THEN BEGIN
      CRISPEX_UPDATE_REFSPSLICE, event
      CRISPEX_DRAW_SPECTRAL_REF, event, /SP_ONLY
    ENDIF
		IF (*(*info).winswitch).showdop THEN CRISPEX_DRAW_DOPPLER, event
    IF (*(*info).winswitch).showsji THEN CRISPEX_DRAW_SJI, event
	ENDELSE
;	IF ((*(*info).dispparams).slices_imscale AND (*(*info).winswitch).showrestloop) THEN $
	IF (*(*info).winswitch).showrestloop THEN $
    CRISPEX_DRAW_REST_LOOP, event
	IF (*(*info).winswitch).showloop THEN CRISPEX_DRAW_LOOPSLAB, event 
	IF (*(*info).winswitch).showrefloop THEN CRISPEX_DRAW_REFLOOPSLAB, event 
END

PRO CRISPEX_SCALING_SET_BOXBUTTONS, event, SENSITIVITY_OVERRIDE=sensitivity_override
; Handles the setting of scaling buttons
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  showarr = [1,(*(*info).winswitch).showref,(*(*info).dispswitch).drawdop,$
    (*(*info).winswitch).showsji]
  WIDGET_CONTROL, (*(*info).ctrlscp).imagescale_cbox, $
    SET_COMBOBOX_SELECT=(*(*(*info).scaling).imagescale)[(*(*info).scaling).imrefscaling], $
    SENSITIVE=showarr[(*(*info).scaling).imrefscaling]
  WIDGET_CONTROL, (*(*info).ctrlscp).scaling_reset_button, $
      SENSITIVE=showarr[(*(*info).scaling).imrefscaling]
  WIDGET_CONTROL, (*(*info).ctrlscp).diagscale_label, $
    SET_VALUE=(*(*info).scaling).diagscale_label_vals[(*(*info).scaling).idx]
  ; HISTO_OPT controls
  WIDGET_CONTROL, (*(*info).ctrlscp).histo_opt_txt, $
    SET_VALUE=STRTRIM((*(*info).scaling).histo_opt_val[(*(*info).scaling).idx],2), $
    SENSITIVE=showarr[(*(*info).scaling).imrefscaling]
  ; Multiply controls
  update_constraint = (((*(*info).scaling).idx GE 0) AND $
    ((*(*info).scaling).idx LT N_ELEMENTS((*(*info).scaling).mult_val)))
	WIDGET_CONTROL, (*(*info).ctrlscp).ls_mult_cbox, $
    SET_COMBOBOX_SELECT=(*(*info).scaling).idx, $
    SENSITIVE=(showarr[(*(*info).scaling).imrefscaling] AND update_constraint)
  IF update_constraint THEN $
  	WIDGET_CONTROL, (*(*info).ctrlscp).ls_mult_txt, $
      SET_VALUE=STRTRIM((*(*info).scaling).mult_val[(*(*info).scaling).idx],2), $
      SENSITIVE=showarr[(*(*info).scaling).imrefscaling] $
  ELSE $
  	WIDGET_CONTROL, (*(*info).ctrlscp).ls_mult_txt, $
      SENSITIVE=(showarr[(*(*info).scaling).imrefscaling] AND update_constraint)
END

PRO CRISPEX_SCALING_SET_SLIDERS, event, GAMMA_ONLY=gamma_only, SET_GAMMA=set_gamma, $
  SENSITIVITY_OVERRIDE=sensitivity_override
; Handles the setting of scaling sliders
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  showarr = [1,(*(*info).winswitch).showref,(*(*info).dispswitch).drawdop,$
    (*(*info).winswitch).showsji]
  IF ~KEYWORD_SET(GAMMA_ONLY) THEN BEGIN
    WIDGET_CONTROL, (*(*info).ctrlscp).scalemin_slider,$
      SET_VALUE=(*(*info).scaling).minimum[(*(*info).scaling).idx], $
      SENSITIVE=showarr[(*(*info).scaling).imrefscaling]
    WIDGET_CONTROL, (*(*info).ctrlscp).scalemax_slider,$
      SET_VALUE=(*(*info).scaling).maximum[(*(*info).scaling).idx], $
      SENSITIVE=showarr[(*(*info).scaling).imrefscaling]
  ENDIF
  IF (N_ELEMENTS(SET_GAMMA) EQ 1) THEN BEGIN
    gamma_slider_val = set_gamma
    gamma_val = 10.^((FLOAT(gamma_slider_val)/500.) - 1.)
    (*(*info).scaling).gamma[(*(*info).scaling).idx] = gamma_val
  ENDIF ELSE BEGIN
    gamma_val = (*(*info).scaling).gamma[(*(*info).scaling).idx]
    gamma_slider_val = 500 * (ALOG10(gamma_val) + 1)
  ENDELSE
  WIDGET_CONTROL, (*(*info).ctrlscp).gamma_slider, SET_VALUE=gamma_slider_val, $
    SENSITIVE=showarr[(*(*info).scaling).imrefscaling]
  WIDGET_CONTROL, (*(*info).ctrlscp).gamma_label, SET_VALUE=STRING(gamma_val,FORMAT='(F6.3)')
END

PRO CRISPEX_SCALING_MULTIPLY_LS_SELECT, event
; Handles the selection of diagnostic for multiplying detailed spectrum
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  (*(*info).scaling).idx = event.INDEX
  WIDGET_CONTROL, (*(*info).ctrlscp).ls_mult_txt, $
    SET_VALUE=STRTRIM((*(*info).scaling).mult_val[(*(*info).scaling).idx],2)
END  

PRO CRISPEX_SCALING_MULTIPLY_LS_VALUE, event
; Handles the selection of diagnostic for multiplying detailed spectrum
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, (*(*info).ctrlscp).ls_mult_txt, GET_VALUE = textvalue
  textvalue = FLOAT(textvalue[0])
  IF (textvalue EQ 0) THEN BEGIN
    textvalue = 1.
	  WIDGET_CONTROL, (*(*info).ctrlscp).ls_mult_txt, SET_VALUE=STRTRIM(textvalue,2)
  ENDIF
	(*(*info).scaling).mult_val[(*(*info).scaling).idx] = FLOAT(textvalue[0])
  CRISPEX_DRAW_SPECTRAL, event
  CRISPEX_DRAW_TIMESLICES, event
END

;================================================================================= SESSION SAVE/RESTORE PROCEDURES
PRO CRISPEX_SESSION_SAVE_WINDOW, event
; Gets the filename for the session save routine
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	CRISPEX_SAVE_CHECK_PATH_WRITE, event
	CRISPEX_SAVE_GET_FILENAME, event, 'Save session', 'crispex_session',$
    'CRISPEX_SESSION_SAVE_CONTINUE', /SESSION_SAVE
END

PRO CRISPEX_SESSION_SAVE_CONTINUE, event
; Checks the session save filename for validity and overwrite problems
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savparams).savpro = 'SESSION'
	CRISPEX_SAVE_CHECK_FILENAME, event, 'cses', 'CRISPEX_SESSION_SAVE_OVER_CONTINUE'
END

PRO CRISPEX_SESSION_SAVE_OVER_CONTINUE, event
; Handles the overwriting and activates the subsequent saving of the session
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, (*(*info).savparams).filename_text, GET_VALUE = session_filename
	CRISPEX_SESSION_SAVE, event, session_filename
	WIDGET_CONTROL, event.TOP, /DESTROY
END

PRO CRISPEX_SESSION_SAVE, event, sesfilename
; Handles the actual saving of the session
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	WIDGET_CONTROL, /HOURGLASS
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  ; Get current window positions
  CRISPEX_WINDOWS_GET_OFFSETS, event
  ; Save all pointers
	ctrlsswitch = *(*info).ctrlsswitch	    &	curs = *(*info).curs
	dataparams = *(*info).dataparams	      &	dataswitch = *(*info).dataswitch		
  detparams = *(*info).detparams          & dispparams = *(*info).dispparams	
  dispswitch = *(*info).dispswitch		    &	intparams = *(*info).intparams
  ioparams = *(*info).ioparams            &	loopparams = *(*info).loopparams	
  loopswitch = *(*info).loopswitch		    &	meas = *(*info).meas
	overlayparams = *(*info).overlayparams	&	overlayswitch = *(*info).overlayswitch		
  paramswitch = *(*info).paramswitch      & pbparams = *(*info).pbparams
  phiparams = *(*info).phiparams          & plotaxes = *(*info).plotaxes
  plotparams = *(*info).plotparams        & plotpos = *(*info).plotpos		
  plotswitch = *(*info).plotswitch		    & plottitles = *(*info).plottitles
	restoreparams = *(*info).restoreparams	&	retrparams = *(*info).retrparams		
  savswitch = *(*info).savswitch          & scaling = *(*info).scaling		
  stokesparams = *(*info).stokesparams		& versioninfo = *(*info).versioninfo
	winsizes = *(*info).winsizes		        &	winswitch = *(*info).winswitch			
  zooming = *(*info).zooming
	SAVE, ctrlsswitch, curs, dataparams, dataswitch, detparams, dispparams, dispswitch, intparams, $
        ioparams, loopparams, loopswitch, meas, overlayparams, overlayswitch, paramswitch, $
        pbparams, phiparams, plotaxes, plotparams, plotpos, plotswitch, plottitles, restoreparams,$
        retrparams, savswitch, scaling, stokesparams, versioninfo, winsizes, winswitch, zooming, $
		    FILENAME = (*(*info).paths).opath+sesfilename+'.cses'
	PRINT,'Written: '+(*(*info).paths).opath+sesfilename+'.cses'
	WIDGET_CONTROL, (*(*info).winids).savewintlb, /DESTROY
	(*(*info).winids).savewintlb = 0
END

PRO CRISPEX_SESSION_RESTORE_READ_POINTER, event, currpointer, restpointer, NO_RESTORE=no_restore
; Handles the actual restoration of the session
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	currtags = TAG_NAMES(currpointer)	&	resttags = TAG_NAMES(restpointer)
	ncurr = N_ELEMENTS(currtags)		  &	nrest = N_ELEMENTS(resttags)
	no_rest = N_ELEMENTS(NO_RESTORE)
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [ncurr,nrest,no_rest-1],labels=['Current tags','Restored tags',$
                          'Prevent replace tag']
  ; Both the restored and current pointer have the same number of tags
	IF (ncurr EQ nrest) THEN BEGIN											
		IF (no_rest EQ 0) THEN BEGIN										; Pointer to be restored without skipping tags
      ; If all tagnames are equal, then just replace the pointer
			IF (WHERE((resttags EQ currtags) EQ 0) EQ -1) THEN currpointer = restpointer ELSE BEGIN		
        ; Else go through all tags and replace only where tagnames are the same
				FOR i=0,nrest-1 DO (currpointer).(WHERE(currtags EQ resttags[i])) = restpointer.(i)	
			ENDELSE
		ENDIF ELSE BEGIN											; Pointer to be restored while skipping tags
			no_replace = WHERE((STRLOWCASE(resttags) EQ STRLOWCASE(no_restore)) EQ 1)
			FOR i=0,nrest-1 DO BEGIN
        ; If pointer tag is not the one to be skipped, replace its value
				IF (no_replace NE i) THEN (currpointer).(i) = restpointer.(i)				
			ENDFOR
		ENDELSE
	ENDIF ELSE BEGIN												; Unequal number of tags between current and restored pointer
		FOR i=0,nrest-1 DO BEGIN
      ; Go through all tags and replace only where tagnames are the same
			IF (WHERE(currtags EQ resttags[i]) NE -1) THEN $
        (currpointer).(WHERE(currtags EQ resttags[i])) = restpointer.(i)			
		ENDFOR
	ENDELSE
END

PRO CRISPEX_SESSION_RESTORE, event
; Handles the actual restoration of the session
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  csesfile = $
    DIALOG_PICKFILE(/READ,/MUST_EXIST,PATH=(*(*info).paths).ipath,$
    TITLE='CRISPEX'+(*(*info).sesparams).instance_label+': Restore session', $
    FILTER='*cses')
  IF (STRCOMPRESS(csesfile) NE '') THEN BEGIN
  	WIDGET_CONTROL, /HOURGLASS
  	CRISPEX_UPDATE_USER_FEEDBACK, event, title='Restoring session...', var=0, $
      feedback_text='Restoring session file and checking version...', /SESSION
  	RESTORE, csesfile
  	; Check revision number
  	IF (N_ELEMENTS(versioninfo) GT 0) THEN cont = (versioninfo.revision_number GE '546') ELSE cont = 0
  	IF cont THEN BEGIN
  		IF (((*(*info).dataparams).imfilename EQ dataparams.imfilename) AND ((*(*info).dataparams).spfilename EQ dataparams.spfilename) AND $
  			((*(*info).dataparams).refimfilename EQ dataparams.refimfilename) AND ((*(*info).dataparams).refspfilename EQ dataparams.refspfilename)) THEN BEGIN
  			; Kill all open windows (except control panel and main image window)
  			CRISPEX_UPDATE_USER_FEEDBACK, event, title='Restoring session...', var=1, feedback_text='Closing open windows...'
  			IF ((*(*info).winids).sptlb NE 0) THEN BEGIN 
  				WIDGET_CONTROL, (*(*info).winids).sptlb, /DESTROY 
  				(*(*info).winids).sptlb = 0 
  			ENDIF
  			IF ((*(*info).winids).lstlb NE 0) THEN BEGIN 
  				WIDGET_CONTROL, (*(*info).winids).lstlb, /DESTROY
  				(*(*info).winids).lstlb = 0 
  			ENDIF
  			IF ((*(*info).winids).phistlb NE 0) THEN BEGIN 
  				WIDGET_CONTROL, (*(*info).winids).phistlb, /DESTROY 
  				(*(*info).winids).phistlb = 0 
  			ENDIF
  			IF ((*(*info).winids).reftlb NE 0) THEN BEGIN 
  				WIDGET_CONTROL, (*(*info).winids).reftlb, /DESTROY 
  				(*(*info).winids).reftlb = 0 
  			ENDIF
  			IF ((*(*info).winids).doptlb NE 0) THEN BEGIN 
  				WIDGET_CONTROL, (*(*info).winids).doptlb, /DESTROY 
  				(*(*info).winids).doptlb = 0 
  			ENDIF
  			IF ((*(*info).winids).imreftlb NE 0) THEN BEGIN 
  				WIDGET_CONTROL, (*(*info).winids).imreftlb, /DESTROY 
  				(*(*info).winids).imreftlb = 0 
  			ENDIF
  			IF (TOTAL(*(*(*info).winids).restlooptlb) NE 0) THEN BEGIN 
  				FOR i=0,N_ELEMENTS(*(*(*info).winids).restlooptlb)-1 DO WIDGET_CONTROL, (*(*(*info).winids).restlooptlb)[i], /DESTROY
  				(*(*info).winids).restlooptlb = PTR_NEW(0) 
  			ENDIF
  			IF ((*(*info).winids).retrdettlb NE 0) THEN BEGIN 
  				WIDGET_CONTROL, (*(*info).winids).retrdettlb, /DESTROY 
  				(*(*info).winids).retrdettlb = 0 
  			ENDIF
  			IF ((*(*info).winids).looptlb NE 0) THEN BEGIN 
  				WIDGET_CONTROL, (*(*info).winids).looptlb, /DESTROY 
  				(*(*info).winids).looptlb = 0 
  			ENDIF
  			IF ((*(*info).winids).reflooptlb NE 0) THEN BEGIN 
  				WIDGET_CONTROL, (*(*info).winids).reflooptlb, /DESTROY 
  				(*(*info).winids).reflooptlb = 0 
  			ENDIF
  			IF ((*(*info).winids).refsptlb NE 0) THEN BEGIN 
  				WIDGET_CONTROL, (*(*info).winids).refsptlb, /DESTROY 
  				(*(*info).winids).refsptlb = 0 
  			ENDIF
  			IF ((*(*info).winids).reflstlb NE 0) THEN BEGIN 
  				WIDGET_CONTROL, (*(*info).winids).reflstlb, /DESTROY 
  				(*(*info).winids).reflstlb = 0 
  			ENDIF
  			IF ((*(*info).winids).inttlb NE 0) THEN BEGIN 
  				WIDGET_CONTROL, (*(*info).winids).inttlb, /DESTROY 
  				(*(*info).winids).inttlb = 0 
  			ENDIF
  			IF ((*(*info).winids).paramtlb NE 0) THEN BEGIN 
  				WIDGET_CONTROL, (*(*info).winids).paramtlb, /DESTROY 
  				(*(*info).winids).paramtlb = 0 
  			ENDIF
  			; Restore all parameters, for each parameter checking whether the number of subparameters has changed (if revision_number on session file differs from current CRISPEX)
  			CRISPEX_UPDATE_USER_FEEDBACK, event, title='Restoring session...', var=1, feedback_text='Restoring session variables...'
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).ctrlsswitch, ctrlsswitch
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).curs, curs
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).dataparams, dataparams
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).dataswitch, dataswitch
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).detparams, detparams
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).dispparams, dispparams
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).dispswitch, dispswitch
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).intparams, intparams
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).ioparams, ioparams
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).loopparams, loopparams
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).loopswitch, loopswitch
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).meas, meas
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).overlayparams, overlayparams
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).overlayswitch, overlayswitch
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).paramswitch, paramswitch
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).pbparams, pbparams, NO_RESTORE='BG'
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).phiparams, phiparams
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).plotaxes, plotaxes
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).plotparams, plotparams
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).plotpos, plotpos
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).plotswitch, plotswitch
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).plottitles, plottitles
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).restoreparams, restoreparams
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).retrparams, retrparams
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).scaling, scaling
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).savswitch, savswitch
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).stokesparams, stokesparams
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).winsizes, winsizes
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).winswitch, winswitch
  			CRISPEX_SESSION_RESTORE_READ_POINTER, event, *(*info).zooming, zooming
  			; Reset controls on control panel given the control switches and other parameters
  			CRISPEX_UPDATE_USER_FEEDBACK, event, title='Restoring session...', var=1, $
          feedback_text='Resetting control panel controls...'
        ; ==================== Always visible controls ====================
        ; Playback controls
  			WIDGET_CONTROL, (*(*info).ctrlscp).t_slider, SET_VALUE = (*(*info).dispparams).t, $
          SET_SLIDER_MIN=(*(*info).dispparams).t_low, $
          SET_SLIDER_MAX=(*(*info).dispparams).t_upp, $
  				SENSITIVE = ((*(*info).dataparams).nt GT 1)
  			CRISPEX_PB_BUTTONS_SET, event, $
          bwd_set=((*(*info).pbparams).direction EQ -1), $
          pause_set=((*(*info).pbparams).mode EQ 'PAUSE'), $
          fwd_set=((*(*info).pbparams).direction EQ 1), $
  				loop_set=((*(*info).pbparams).lmode EQ 'LOOP'),	$
          cycle_set=((*(*info).pbparams).lmode EQ 'CYCLE'), $
          blink_set=((*(*info).pbparams).lmode EQ 'BLINK')
        ; Spectral control
  			WIDGET_CONTROL, (*(*info).ctrlscp).lp_slider, SET_VALUE = (*(*info).dataparams).lp, $
          SET_SLIDER_MIN = (*(*info).dispparams).lp_low, $
          SET_SLIDER_MAX = (*(*info).dispparams).lp_upp, $
  				SENSITIVE = ((*(*info).dataparams).nlp GT 1)
        ; Cursor lock controls
  			WIDGET_CONTROL, (*(*info).ctrlscp).lock_button, SET_BUTTON = (*(*info).curs).lockset
  			WIDGET_CONTROL, (*(*info).ctrlscp).unlock_button, $
          SET_BUTTON = ABS((*(*info).curs).lockset-1)
        ; ==================== Playback Tab ====================
  			WIDGET_CONTROL, (*(*info).ctrlscp).lower_t_text, $
          SET_VALUE = STRTRIM((*(*info).dispparams).t_low,2), $
          SENSITIVE = ((*(*info).dataparams).nt GT 1)
  			WIDGET_CONTROL, (*(*info).ctrlscp).upper_t_text, $
          SET_VALUE = STRTRIM((*(*info).dispparams).t_upp,2), $
          SENSITIVE = ((*(*info).dataparams).nt GT 1)
  			WIDGET_CONTROL, (*(*info).ctrlscp).reset_trange_but, $
          SENSITIVE = ((*(*info).dispparams).t_range NE (*(*info).dataparams).nt)
  			WIDGET_CONTROL, (*(*info).ctrlscp).t_speed_slider, $
          SET_VALUE = (*(*info).pbparams).t_speed, SENSITIVE = ((*(*info).dataparams).nt GT 1)
  			WIDGET_CONTROL, (*(*info).ctrlscp).t_step_slider, $
          SET_SLIDER_MAX = (*(*info).dispparams).t_range - 1, $
          SET_VALUE = (*(*info).pbparams).t_step, $
  				SENSITIVE = (((*(*info).dispparams).t_range - 1 NE 1) AND $
                        (*(*info).dataparams).nt GT 1)
  			WIDGET_CONTROL, (*(*info).ctrlscp).imref_blink_but, $
          SET_BUTTON = (*(*info).winswitch).showimref, $
          SENSITIVE = (*(*info).dataswitch).reffile
        ; Master timing
        showdata = [((*(*info).dataswitch).reffile OR (*(*info).dataswitch).sjifile), $
          (*(*info).dataswitch).reffile, (*(*info).dataswitch).sjifile]
        nrasterdims = [SIZE((*(*info).dataparams).tarr_raster_main,/N_DIMENSIONS), $
                        SIZE((*(*info).dataparams).tarr_raster_ref,/N_DIMENSIONS), 1]
        FOR i=0,N_ELEMENTS((*(*info).ctrlscp).master_time_ids)-1 DO $
          WIDGET_CONTROL, (*(*info).ctrlscp).master_time_ids[i], $
          SET_BUTTON=(i EQ (*(*info).dispparams).master_time), $
          SENSITIVE=(showdata[i] AND (nrasterdims[i] GE 1))
        WIDGET_CONTROL, (*(*info).ctrlscp).time_offset_slider, $
          SENSITIVE=(((nrasterdims[(*(*info).dispparams).master_time] EQ 1) AND $
            ((*(*info).dataparams).nt EQ 1) AND ((*(*info).dataparams).nx GT 1)) OR $
            (nrasterdims[(*(*info).dispparams).master_time] EQ 2)), $
          SET_VALUE=([(*(*info).dispparams).toffset_main, $
            (*(*info).dispparams).toffset_ref, 0])[(*(*info).dispparams).master_time]
        ; ==================== Spectral Tab ====================
        ; Spectral range
  			WIDGET_CONTROL, (*(*info).ctrlscp).lower_lp_text, $
          SET_VALUE = STRTRIM((*(*info).dispparams).lp_low,2), $
          SENSITIVE = ((*(*info).dataparams).nlp GT 1)
  			WIDGET_CONTROL, (*(*info).ctrlscp).upper_lp_text, $
          SET_VALUE = STRTRIM((*(*info).dispparams).lp_upp,2), $
          SENSITIVE = ((*(*info).dataparams).nlp GT 1)
  			WIDGET_CONTROL, (*(*info).ctrlscp).reset_lprange_but, $
          SENSITIVE = ((*(*info).dispparams).lp_range NE (*(*info).dataparams).nlp)
        ; Spectral blink
      	WIDGET_CONTROL, (*(*info).ctrlscp).lp_blink_slider, $
          SET_SLIDER_MIN=(*(*info).dispparams).lp_low, $
          SET_SLIDER_MAX=(*(*info).dispparams).lp_upp, SET_VALUE=(*(*info).dataparams).lp, $
          SENSITIVE=(((*(*info).dispparams).lp_range-1) NE 1)
  			WIDGET_CONTROL, (*(*info).ctrlscp).lp_blink_but, $
          SET_BUTTON=(*(*info).pbparams).spmode, $
          SENSITIVE=(((*(*info).dataparams).nlp GT 1) AND $
                     ((*(*info).winswitch).showimref EQ 0))
        ; Reference spectrum
  			WIDGET_CONTROL, (*(*info).ctrlscp).lp_ref_but, $
          SET_BUTTON=((*(*info).ctrlsswitch).lp_ref_lock AND $
                     ((*(*info).dataparams).refnlp GT 1)), $
  				SENSITIVE=(((*(*info).dataparams).nlp EQ (*(*info).dataparams).refnlp) AND $
                     ((*(*info).dataparams).refnlp GT 1))
  			WIDGET_CONTROL, (*(*info).ctrlscp).lp_ref_slider, $
          SET_VALUE = (*(*info).dataparams).lp_ref, $
          SENSITIVE = ((*(*info).dataswitch).refspfile AND $
                      ABS((*(*info).ctrlsswitch).lp_ref_lock-1))
        ; Spectrum along slit
  			WIDGET_CONTROL, (*(*info).ctrlscp).phi_slider, $
          SET_VALUE = (*(*info).phiparams).angle, SENSITIVE = (*(*info).winswitch).showphis
  			WIDGET_CONTROL, (*(*info).ctrlscp).nphi_slider, $
          SET_VALUE = (*(*info).phiparams).nphi_set, $
          SENSITIVE = (*(*info).winswitch).showphis
  			; ==================== Spatial Tab ====================
        ; Set cursor sliders and lock/unlock buttons
  			CRISPEX_COORDSLIDERS_SET, 1, 1, event
        ; Set zooming buttons
  			IF ((*(*info).zooming).factor NE 1) THEN CRISPEX_ZOOM, event, /NO_DRAW
        set_zoomfac = CRISPEX_BGROUP_ZOOMFAC_SET(event, /NO_DRAW, /NO_UPDATE_SLIDERS, $
          SET_FACTOR=WHERE((*(*info).zooming).factors EQ (*(*info).zooming).factor))
        ; Set scrolling sliders
  			WIDGET_CONTROL, (*(*info).ctrlscp).xpos_slider, SET_VALUE = (*(*info).zooming).xpos, $
          SENSITIVE = ((*(*info).zooming).factor NE 1)
  			WIDGET_CONTROL, (*(*info).ctrlscp).ypos_slider, SET_VALUE = (*(*info).zooming).ypos, $
          SENSITIVE = ((*(*info).zooming).factor NE 1)
  			; ==================== Diagnostics Tab ====================
        FOR i=0,N_ELEMENTS((*(*info).stokesparams).button_labels)-1 DO BEGIN
          ; Stokes parameter available in data?
          stokes_enabled = (WHERE(((*(*info).stokesparams).labels) EQ $
                                   (*(*info).stokesparams).button_labels[i]) GE 0)
          ; Stokes parameter selected for detailed spectrum plot?
          wherestokes_sp = WHERE((*(*info).stokesparams).select_sp EQ 1, count)
          IF (count GT 0) THEN $
  			    stokes_sp_select = (*(*info).stokesparams).labels[wherestokes_sp] $
          ELSE $
  			    stokes_sp_select = ''
          ; Determine setting of buttons accordingly
          stokes_sp_set = (WHERE(stokes_sp_select EQ (*(*info).stokesparams).button_labels[i]) GE 0)
          ; Total number of selected Stokes parameters for detailed spectrum plot?
          total_sp_select = TOTAL((*(*info).stokesparams).select_sp)
          ; Set Stokes image buttons
          WIDGET_CONTROL, (*(*info).ctrlscp).stokes_button_ids[i], SENSITIVE=stokes_enabled, $
            SET_BUTTON = (((*(*info).stokesparams).labels)[(*(*info).dataparams).s] EQ $
                           (*(*info).stokesparams).button_labels[i])
          ; Set Stokes detailed spectrum buttons
          WIDGET_CONTROL, (*(*info).ctrlscp).stokes_spbutton_ids[i], SET_BUTTON=stokes_sp_set, $
            SENSITIVE=(stokes_enabled AND ((total_sp_select GT 1) OR $
                                           (total_sp_select AND ABS(stokes_sp_set-1))))
        ENDFOR
  			IF ((*(*info).dataparams).nlp EQ 1) THEN $
          WIDGET_CONTROL, (*(*info).ctrlscp).stokes_spbutton_ids[0], SET_BUTTON = 0
        ; Spectral window settings
        IF ((*(*info).intparams).ndiagnostics GT 1) THEN BEGIN
          set = [((*(*info).intparams).ndisp_diagnostics EQ $
                  (*(*info).intparams).ndiagnostics),$
                  ((*(*info).intparams).disp_diagnostics EQ $
                    REPLICATE(1,(*(*info).intparams).ndiagnostics))]
          sens = [((*(*info).intparams).ndisp_diagnostics NE $
                  (*(*info).intparams).ndiagnostics),$
                  (((*(*info).intparams).disp_diagnostics NE $
                    REPLICATE(1,(*(*info).intparams).ndiagnostics)) OR $
                  (((*(*info).intparams).disp_diagnostics EQ $
                    REPLICATE(1,(*(*info).intparams).ndiagnostics)) AND $
                   ((*(*info).intparams).ndisp_diagnostics NE 1)))]
          FOR i=0,(*(*info).intparams).ndiagnostics DO $
            WIDGET_CONTROL, (*(*info).ctrlscp).specwin_button_ids[i], SENSITIVE=sens[i], $
              SET_BUTTON=set[i]
        ENDIF
        IF ((*(*info).intparams).nrefdiagnostics GT 1) THEN BEGIN
          refset = [((*(*info).intparams).ndisp_refdiagnostics EQ $
                      (*(*info).intparams).nrefdiagnostics),$
                  ((*(*info).intparams).disp_refdiagnostics EQ $
                    REPLICATE(1,(*(*info).intparams).nrefdiagnostics))]
          refsens = [((*(*info).intparams).ndisp_refdiagnostics NE $
                      (*(*info).intparams).nrefdiagnostics),$
                  (((*(*info).intparams).disp_refdiagnostics NE $
                    REPLICATE(1,(*(*info).intparams).nrefdiagnostics)) OR $
                  (((*(*info).intparams).disp_refdiagnostics EQ $
                    REPLICATE(1,(*(*info).intparams).nrefdiagnostics)) AND $
                   ((*(*info).intparams).ndisp_refdiagnostics NE 1)))]
          FOR i=0,(*(*info).intparams).nrefdiagnostics DO $
            WIDGET_CONTROL, (*(*info).ctrlscp).refspecwin_button_ids[i], $
              SENSITIVE=refsens[i], SET_BUTTON=refset[i]
        ENDIF
  			; ==================== Displays Tab ====================
  			WIDGET_CONTROL, (*(*info).ctrlscp).detspect_im_but, $
          SET_BUTTON = ABS((*(*info).ctrlsswitch).imrefdetspect-1)
  			WIDGET_CONTROL, (*(*info).ctrlscp).detspect_ref_but, $
          SET_BUTTON = (*(*info).ctrlsswitch).imrefdetspect, $
          SENSITIVE = (*(*info).dataswitch).refspfile
  			CRISPEX_DISPLAYS_DETSPECT_SET_BUTTONS, event
  			WIDGET_CONTROL, (*(*info).ctrlscp).sp_toggle_but, $
          SET_BUTTON = (*(*info).winswitch).showsp
  			WIDGET_CONTROL, (*(*info).ctrlscp).phis_toggle_but, $
          SET_BUTTON = (*(*info).winswitch).showphis
  			WIDGET_CONTROL, (*(*info).ctrlscp).refsp_toggle_but, $
          SET_BUTTON = (*(*info).winswitch).showrefsp, $
          SENSITIVE = (*(*info).dataswitch).refspfile
  			WIDGET_CONTROL, (*(*info).ctrlscp).int_toggle_but, $
          SET_BUTTON = (*(*info).winswitch).showint, $
          SENSITIVE = (*(*info).dataswitch).spfile
  			WIDGET_CONTROL, (*(*info).ctrlscp).reference_but, $
          SET_BUTTON = (*(*info).winswitch).showref, SENSITIVE = (*(*info).dataswitch).reffile
  			WIDGET_CONTROL, (*(*info).ctrlscp).doppler_but, $
          SET_BUTTON = (*(*info).winswitch).showdop, $
          SENSITIVE = ((*(*info).dataparams).nlp GT 1)
  			; ==================== Scaling Tab ====================
        WIDGET_CONTROL, (*(*info).ctrlscp).scaling_cbox, $
          SET_COMBOBOX_SELECT=(*(*info).scaling).imrefscaling
  			CRISPEX_SCALING_SET_BOXBUTTONS, event
  			CRISPEX_SCALING_SET_SLIDERS, event
  			; ==================== Analysis Tab ====================
  			; Space-time diagram
  			WIDGET_CONTROL, (*(*info).ctrlscp).loop_slit_but, $
          SET_BUTTON = ((*(*info).loopparams).np GE 2), $
          SENSITIVE = ABS((*(*info).meas).spatial_measurement-1)
  			WIDGET_CONTROL, (*(*info).ctrlscp).loop_feedb_but, $
          SET_BUTTON = (*(*info).overlayswitch).looppath_feedback
  			WIDGET_CONTROL, (*(*info).ctrlscp).rem_loop_pt_but, $
          SENSITIVE = ((*(*info).loopparams).np GE 3)
  			WIDGET_CONTROL, (*(*info).ctrlscp).loop_slice_but, $
          SENSITIVE = (ABS((*(*info).winswitch).showloop-1) AND $
          ABS((*(*info).meas).spatial_measurement-1) AND ((*(*info).loopparams).np GE 2))
        ; Measurement
  			WIDGET_CONTROL, (*(*info).ctrlscp).measure_but, $
          SET_BUTTON = (*(*info).meas).spatial_measurement
  			WIDGET_CONTROL, (*(*info).ctrlscp).apix_label, $
          SENSITIVE = (*(*info).meas).spatial_measurement
  	    WIDGET_CONTROL, (*(*info).ctrlscp).apix_unit, $
          SENSITIVE = (*(*info).meas).spatial_measurement
  			WIDGET_CONTROL, (*(*info).ctrlscp).dx_text, $
          SET_VALUE = STRTRIM((*(*info).dataparams).dx,2), $
          SENSITIVE = (*(*info).meas).spatial_measurement
  			WIDGET_CONTROL, (*(*info).ctrlscp).x_label, $
          SENSITIVE = (*(*info).meas).spatial_measurement
  			WIDGET_CONTROL, (*(*info).ctrlscp).dy_text, $
          SET_VALUE = STRTRIM((*(*info).dataparams).dy,2), $
          SENSITIVE = (*(*info).meas).spatial_measurement
  			WIDGET_CONTROL, (*(*info).ctrlscp).measure_asec_lab, $
          SENSITIVE = (*(*info).meas).spatial_measurement
  			WIDGET_CONTROL, (*(*info).ctrlscp).measure_asec_text, $
          SENSITIVE = (*(*info).meas).spatial_measurement
  			WIDGET_CONTROL, (*(*info).ctrlscp).measure_km_lab, $
          SENSITIVE = (*(*info).meas).spatial_measurement
  			WIDGET_CONTROL, (*(*info).ctrlscp).measure_km_text, $
          SENSITIVE = (*(*info).meas).spatial_measurement
  			; ==================== Overlays Tab ====================
  			; Mask
  			WIDGET_CONTROL, (*(*info).ctrlscp).masks_overlay_ct_cbox, $
          SET_COMBOBOX_SELECT = (*(*info).overlayparams).maskct, $
          SENSITIVE = (*(*info).overlayswitch).mask
  			WIDGET_CONTROL, (*(*info).ctrlscp).masks_overlay_col_slid, $
          SET_VALUE = (*(*info).overlayparams).maskcolor, $
          SENSITIVE = (*(*info).overlayswitch).mask
  			CRISPEX_MASK_BUTTONS_SET, event
        ; Loop overlays
  			WIDGET_CONTROL, (*(*info).ctrlscp).overlay_but, $
          SET_BUTTON = (*(*info).loopswitch).restore_loops
  			WIDGET_CONTROL, (*(*info).ctrlscp).loop_overlay_all, $
          SET_BUTTON = (*(*info).overlayswitch).overlalways, $
          SENSITIVE = (*(*info).loopswitch).restore_loops
  			WIDGET_CONTROL, (*(*info).ctrlscp).loop_overlay_sav, $
          SET_BUTTON = ABS((*(*info).overlayswitch).overlalways-1), $
          SENSITIVE = (*(*info).loopswitch).restore_loops
  			WIDGET_CONTROL, (*(*info).ctrlscp).linestyle_0, $
          SET_BUTTON = ((*(*info).overlayparams).loop_linestyle EQ 0)
  			WIDGET_CONTROL, (*(*info).ctrlscp).linestyle_1, $
          SET_BUTTON = ((*(*info).overlayparams).loop_linestyle EQ 1)
  			WIDGET_CONTROL, (*(*info).ctrlscp).linestyle_2, $
          SET_BUTTON = ((*(*info).overlayparams).loop_linestyle EQ 2)
        ; Raster overlays
        WIDGET_CONTROL, (*(*info).ctrlscp).raster_button_ids[0], $
          SENSITIVE=((*(*info).dataswitch).reffile AND $
          ((nrasterdims[0] GT 1) OR ((*(*info).dataparams).nx EQ 1))), $
          SET_BUTTON=((*(*info).overlayswitch).refraster AND $
          ((nrasterdims[0] GT 1) OR ((*(*info).dataparams).nx EQ 1)))
        WIDGET_CONTROL, (*(*info).ctrlscp).raster_button_ids[1], $
          SENSITIVE=((*(*info).dataswitch).sjifile AND $
          ((nrasterdims[0] GT 1) OR ((*(*info).dataparams).nx EQ 1))), $
          SET_BUTTON=((*(*info).overlayswitch).sjiraster AND $
          ((nrasterdims[0] GT 1) OR ((*(*info).dataparams).nx EQ 1)))
  			IF (*(*info).meas).spatial_measurement THEN CRISPEX_MEASURE_CALC, event
  			; Open windows for replotting and replot
  			CRISPEX_UPDATE_USER_FEEDBACK, event, title='Restoring session...', var=1, feedback_text='Opening windows and refreshing displays...'
  			IF (*(*info).winswitch).showref THEN BEGIN
  				(*(*info).winswitch).showref = 0
  				CRISPEX_DISPLAYS_REF_TOGGLE, event, /NO_DRAW
  				WIDGET_CONTROL, (*(*info).winids).restsesfeedbtlb, /SHOW
  			ENDIF
  			IF (*(*info).winswitch).showdop THEN BEGIN
  				(*(*info).winswitch).showdop = 0
  				CRISPEX_DISPLAYS_DOPPLER_TOGGLE, event, /NO_DRAW
  				WIDGET_CONTROL, (*(*info).winids).restsesfeedbtlb, /SHOW
  			ENDIF
  			IF (*(*info).winswitch).showimref THEN BEGIN
  				(*(*info).winswitch).showimref = 0
  				CRISPEX_DISPLAYS_IMREFBLINK_TOGGLE, event
  				WIDGET_CONTROL, (*(*info).winids).restsesfeedbtlb, /SHOW
  			ENDIF
  			IF (*(*info).winswitch).showsp THEN BEGIN
  				(*(*info).winswitch).showsp = 0
  				CRISPEX_DISPLAYS_SP_TOGGLE, event, /NO_DRAW
  				WIDGET_CONTROL, (*(*info).winids).restsesfeedbtlb, /SHOW
  			ENDIF
  			IF (*(*info).winswitch).showrefsp THEN BEGIN
  				(*(*info).winswitch).showrefsp = 0
  				CRISPEX_DISPLAYS_REFSP_TOGGLE, event, /NO_DRAW
  				WIDGET_CONTROL, (*(*info).winids).restsesfeedbtlb, /SHOW
  			ENDIF
  			showimref_ls = [(*(*info).winswitch).showls, (*(*info).winswitch).showrefls]
  			FOR i = 0,1 DO BEGIN
  				IF showimref_ls[i] THEN BEGIN
  					set_imrefdetspect = (*(*info).ctrlsswitch).imrefdetspect
  					(*(*info).ctrlsswitch).imrefdetspect = i
  					IF (i EQ 0) THEN (*(*info).winswitch).showls = 0 ELSE (*(*info).winswitch).showrefls = 0
  					CRISPEX_DISPLAYS_IMREF_LS_TOGGLE, event, /NO_DRAW
  					WIDGET_CONTROL, (*(*info).winids).restsesfeedbtlb, /SHOW
  					(*(*info).ctrlsswitch).imrefdetspect = set_imrefdetspect
  				ENDIF
  			ENDFOR
  			IF (*(*info).winswitch).showint THEN BEGIN
  				(*(*info).winswitch).showint = 0
  				CRISPEX_DISPLAYS_INT_TOGGLE, event, /NO_DRAW
  				WIDGET_CONTROL, (*(*info).winids).restsesfeedbtlb, /SHOW
  			ENDIF
  			old_cfilecount = (*(*info).restoreparams).cfilecount
  			CRISPEX_FIND_CSAV, event
  			IF ((*(*info).loopswitch).restore_loops AND ((*(*info).restoreparams).cfilecount EQ old_cfilecount)) THEN BEGIN
  				CRISPEX_RESTORE_LOOPS_MENU, event, *(*(*info).restoreparams).sel_loops
  				WIDGET_CONTROL, (*(*info).winids).restsesfeedbtlb, /SHOW
  				WIDGET_CONTROL, (*(*info).ctrlsrestore).sel_all, SET_BUTTON = (TOTAL(*(*(*info).restoreparams).sel_loops) EQ N_ELEMENTS(*(*(*info).restoreparams).sel_loops))
  				WIDGET_CONTROL, (*(*info).ctrlsrestore).sel_none, SET_BUTTON = (TOTAL(*(*(*info).restoreparams).sel_loops) EQ 0)
  				WIDGET_CONTROL, (*(*info).ctrlsrestore).disp_list, GET_VALUE = list_values
  				IF (*(*info).winswitch).showrestloop THEN BEGIN
  					FOR i=0,N_ELEMENTS(*(*(*info).restoreparams).disp_loopnr)-1 DO BEGIN
  						list_values[(*(*(*info).restoreparams).disp_loopnr)[i]+1] = 'Hide time slice '+STRTRIM((*(*(*info).restoreparams).disp_loopnr)[i],2)
  						(*(*info).restoreparams).disp_loopfile = (*(*(*info).restoreparams).cfiles)[(*(*(*info).restoreparams).disp_loopnr)[i]]
  						CRISPEX_DISPLAYS_RESTORE_LOOPSLAB, event, /NO_DRAW, INDEX=i
  					ENDFOR
  				ENDIF ELSE FOR i=1,N_ELEMENTS(list_values)-1 DO list_values[i] = 'Display time slice '+STRTRIM(i-1,2)
  				WIDGET_CONTROL, (*(*info).ctrlsrestore).disp_list, SET_VALUE = list_values, SET_COMBOBOX_SELECT = (*(*(*info).restoreparams).disp_loopnr)[0]+1
  			ENDIF ELSE BEGIN			; Add error message
  				(*(*info).loopswitch).restore_loops = 0	
  				(*(*info).winswitch).showrestloop = 0
  			ENDELSE
  			old_clfilecount = (*(*info).retrparams).clfilecount
  			CRISPEX_FIND_CLSAV, event
  			IF ((*(*info).loopswitch).retrieve_loops AND ((*(*info).retrparams).clfilecount EQ old_clfilecount)) THEN BEGIN
  				CRISPEX_RETRIEVE_LOOP_MENU, event, *(*(*info).retrparams).sel_loops
  				WIDGET_CONTROL, (*(*info).winids).restsesfeedbtlb, /SHOW
  				WIDGET_CONTROL, (*(*info).ctrlsloop).sel_all, SET_BUTTON = (TOTAL(*(*(*info).retrparams).sel_loops) EQ N_ELEMENTS(*(*(*info).retrparams).sel_loops))
  				WIDGET_CONTROL, (*(*info).ctrlsloop).sel_none, SET_BUTTON = (TOTAL(*(*(*info).retrparams).sel_loops) EQ 0)
  				WIDGET_CONTROL, (*(*info).ctrlsloop).all_pos, SET_BUTTON = (*(*info).savswitch).all_pos_loops
  				WIDGET_CONTROL, (*(*info).ctrlsloop).saved_pos, SET_BUTTON = ABS((*(*info).savswitch).all_pos_loops-1)
  				WIDGET_CONTROL, (*(*info).ctrlsloop).del_files, SET_BUTTON = (*(*info).savswitch).delete_clsav
  				WIDGET_CONTROL, (*(*info).ctrlsloop).keep_files, SET_BUTTON = ABS((*(*info).savswitch).delete_clsav-1)
  				WIDGET_CONTROL, (*(*info).ctrlsloop).save_imonly, SET_BUTTON = ((*(*info).savswitch).imref_only EQ 1)
  				WIDGET_CONTROL, (*(*info).ctrlsloop).save_refonly, SET_BUTTON = ((*(*info).savswitch).imref_only EQ 2)
  				WIDGET_CONTROL, (*(*info).ctrlsloop).save_imref, SET_BUTTON = ((*(*info).savswitch).imref_only EQ 3)
  			ENDIF ELSE (*(*info).loopswitch).retrieve_loops = 0	; Add error message
  			detfile = FILE_SEARCH((*(*info).detparams).detfilename, COUNT=detcount)
  			IF ((*(*info).loopswitch).retrieve_detfile AND (detcount EQ 1)) THEN BEGIN
  				CRISPEX_RETRIEVE_DET_FILE_MENU, event, *(*(*info).detparams).sel_dets, DETFILENAME=(*(*info).detparams).detfilename, /NO_DRAW
  				WIDGET_CONTROL, (*(*info).winids).restsesfeedbtlb, /SHOW
  				WIDGET_CONTROL, (*(*info).ctrlsdet).sel_all, SET_BUTTON = (TOTAL(*(*(*info).detparams).sel_dets) EQ N_ELEMENTS(*(*(*info).detparams).sel_dets))
  				WIDGET_CONTROL, (*(*info).ctrlsdet).sel_none, SET_BUTTON = (TOTAL(*(*(*info).detparams).sel_dets) EQ 0)
  				WIDGET_CONTROL, (*(*info).ctrlsdet).disp_list, SET_COMBOBOX_SELECT = (*(*info).detparams).idx+1
  				WIDGET_CONTROL, (*(*info).ctrlsdet).overlay_all, SET_BUTTON = (*(*info).overlayswitch).det_overlay_all
  				WIDGET_CONTROL, (*(*info).ctrlsdet).overlay_sel, SET_BUTTON = ABS((*(*info).overlayswitch).det_overlay_all-1)
  				WIDGET_CONTROL, (*(*info).ctrlsdet).width_slider, SET_VALUE = (*(*info).detparams).width
  				WIDGET_CONTROL, (*(*info).ctrlsdet).all_pos, SET_BUTTON = ((*(*info).savswitch).pos_dets EQ 1)
  				WIDGET_CONTROL, (*(*info).ctrlsdet).saved_pos, SET_BUTTON = ((*(*info).savswitch).pos_dets EQ 2)
  				WIDGET_CONTROL, (*(*info).ctrlsdet).sel_range_pos, SET_BUTTON = ((*(*info).savswitch).pos_dets EQ 3)
  				WIDGET_CONTROL, (*(*info).ctrlsdet).dlpmin_text, SENSITIVE = ((*(*info).savswitch).pos_dets EQ 3)
  				WIDGET_CONTROL, (*(*info).ctrlsdet).dlpmax_text, SENSITIVE = ((*(*info).savswitch).pos_dets EQ 3)
  				WIDGET_CONTROL, (*(*info).ctrlsdet).refdlpmin_text, SENSITIVE = ((*(*info).savswitch).pos_dets EQ 3)
  				WIDGET_CONTROL, (*(*info).ctrlsdet).refdlpmax_text, SENSITIVE = ((*(*info).savswitch).pos_dets EQ 3)
  				WIDGET_CONTROL, (*(*info).ctrlsdet).save_imonly, SET_BUTTON = ((*(*info).savswitch).det_imref_only EQ 1)
  				WIDGET_CONTROL, (*(*info).ctrlsdet).save_refonly, SET_BUTTON = ((*(*info).savswitch).det_imref_only EQ 2)
  				WIDGET_CONTROL, (*(*info).ctrlsdet).save_imref, SET_BUTTON = ((*(*info).savswitch).det_imref_only EQ 3)
  				WIDGET_CONTROL, (*(*info).ctrlsdet).get_dets, SENSITIVE = (TOTAL(*(*(*info).detparams).sel_dets) GE 1)
  				IF (*(*info).winswitch).showretrdet THEN CRISPEX_DISPLAYS_RETRIEVE_DET_LOOPSLAB, event, /NO_DRAW
  				CRISPEX_DISPRANGE_LP_RANGE, event
  				CRISPEX_UPDATE_LP, event
  				WIDGET_CONTROL, (*(*info).winids).restsesfeedbtlb, /SHOW
  			ENDIF ELSE (*(*info).loopswitch).retrieve_detfile = 0	; Add error message
  			IF (*(*info).winswitch).showloop THEN BEGIN
  				CRISPEX_DISPLAYS_LOOPSLAB, event, /NO_DRAW
  				IF (*(*info).winswitch).showrefloop THEN CRISPEX_DISPLAYS_REFLOOPSLAB, event, /NO_DRAW
  				CRISPEX_UPDATE_LP, event
  				WIDGET_CONTROL, (*(*info).winids).restsesfeedbtlb, /SHOW
  			ENDIF
  			IF (*(*info).winswitch).showphis THEN BEGIN
  				(*(*info).winswitch).showphis = 0
  				IF ((*(*info).dataparams).nt EQ 1) THEN CRISPEX_UPDATE_T, event
  				CRISPEX_DISPLAYS_PHIS_TOGGLE, event
  				WIDGET_CONTROL, (*(*info).winids).restsesfeedbtlb, /SHOW
  			ENDIF ELSE BEGIN
  				CRISPEX_UPDATE_T, event
  				CRISPEX_DRAW, event
  				WIDGET_CONTROL, (*(*info).winids).restsesfeedbtlb, /SHOW
  			ENDELSE
  			; Menu
  			IF (*(*info).winswitch).dispwids THEN BEGIN
  				(*(*info).winswitch).dispwids = 0
  				CRISPEX_DISPWIDS, event
  			ENDIF
  			CRISPEX_WINDOW_USER_FEEDBACK_CLOSE, event, /SESSION
  			(*(*(*info).sesparams).sessions)[WHERE(*(*(*info).sesparams).sessions EQ 1)] = 0
  		ENDIF ELSE BEGIN
  			CRISPEX_WINDOW_USER_FEEDBACK_CLOSE, event, /SESSION
  			CRISPEX_WINDOW_OK, event,'ERROR!',$
          'Unable to restore earlier session due to incompatibility '+$
          'between currently and earlier loaded data.',$
  				OK_EVENT='CRISPEX_CLOSE_EVENT_WINDOW', BASE=tlb
  			(*(*info).winids).errtlb = tlb
  		ENDELSE
  	ENDIF ELSE BEGIN
  		CRISPEX_WINDOW_USER_FEEDBACK_CLOSE, event, /SESSION
  		IF (N_ELEMENTS(versioninfo) GT 0) THEN message4 = 'Session was saved with CRISPEX v'+versioninfo.version_number+' (rev '+versioninfo.revision_number+').' ELSE message4 = ''
  		CRISPEX_WINDOW_OK, event,'ERROR!',$
        'Unable to restore earlier session due to incompatibility between '+$
        'saved and expected session save file format. Running version of '+$
  			'CRISPEX requires a session saved with CRISPEX v1.6 (rev 542) or later. '+$
        message4, OK_EVENT='CRISPEX_CLOSE_EVENT_WINDOW', BASE=tlb
  		(*(*info).winids).errtlb = tlb
  	ENDELSE
  ENDIF ELSE BEGIN
  	CRISPEX_WINDOW_OK, event,'ERROR!','No session selected for restore.', $
  		OK_EVENT='CRISPEX_CLOSE_EVENT_WINDOW', BASE=tlb
  	(*(*info).winids).errtlb = tlb
  ENDELSE
END

;================================================================================= SAVE LOOPSLICE/SLAB PROCEDURES
PRO CRISPEX_SAVE_DETERMINE_FILENAME, event, infilename=infilename, outfilename=outfilename, tlab=tlab, ext=ext, exch_ext=exch_ext, export_id=export_id, import_id=import_id
; Handles the creation of an output filename
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (N_ELEMENTS(INFILENAME) NE 1) THEN infilename = (*(*info).dataparams).imfilename
	infilename = (STRSPLIT(infilename,PATH_SEP(),/EXTRACT))[N_ELEMENTS(STRSPLIT(infilename,PATH_SEP(),/EXTRACT))-1]
	basefstr = STRMID(infilename,0,STRPOS(infilename,'.',/REVERSE_SEARCH))
	IF KEYWORD_SET(EXCH_EXT) THEN outfilename = basefstr ELSE BEGIN
		IF KEYWORD_SET(TLAB) THEN BEGIN
			CRISPEX_SAVE_DETERMINE_SAVEID, event, saveid
			outfilename = basefstr+'_'+saveid
			IF (N_ELEMENTS(EXPORT_ID) EQ 1) THEN export_id = saveid ELSE export_id=''
		ENDIF ELSE IF (N_ELEMENTS(IMPORT_ID) EQ 1) THEN outfilename = basefstr+'_'+import_id ELSE $
			outfilename = basefstr
	ENDELSE
	IF (N_ELEMENTS(EXT) EQ 1) THEN outfilename = outfilename+'.'+ext
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [infilename,outfilename],labels=['base filename', 'output filename']
END

PRO CRISPEX_SAVE_DETERMINE_SAVEID, event, saveid, PREF=pref
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	monthstrarr = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec']
	curt = SYSTIME()
	tstr = STRSPLIT(curt,/EXTRACT)
	sstr = STRSPLIT(tstr[3],':',/EXTRACT)
	tstr[2] = STRING(tstr[2],FORMAT='(I02)')								; date
	IF KEYWORD_SET(PREF) THEN defsaveid = (*(*info).prefs).tmp_defsaveid ELSE defsaveid = (*(*info).prefs).defsaveid
	IF (defsaveid GE 2) THEN tstr[1] = STRING(WHERE(monthstrarr EQ tstr[1])+1,FORMAT='(I02)')		; month (numeric)
	IF (defsaveid EQ 0) THEN date_order = [4,1,2] ELSE $							; defsaveid = 0 > YYYYMMMDD_hhmmss, ex: 2011Apr12_114545
		IF (defsaveid EQ 1) THEN date_order = [2,1,4] ELSE $						; defsaveid = 1 > DDMMMYYYY_hhmmss, ex: 12Apr2011_114545
		IF (defsaveid EQ 2) THEN date_order = [4,1,2] ELSE $						; defsaveid = 2 > YYYYMMDD_hhmmss, ex: 20110412_114545
		IF (defsaveid EQ 3) THEN date_order = [2,1,4]							; defsaveid = 3 > DDMMYYYY_hhmmss, ex: 12042011_114545
	saveid = STRJOIN(tstr[date_order])+'_'+STRJOIN(sstr)
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [saveid],labels=['save ID']
END

PRO CRISPEX_SAVE_LOOP_PTS, event
; Handles the saving of loop points of a defined path
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	CRISPEX_SAVE_CHECK_PATH_WRITE, event
	IF ((*(*info).paths).opath_write EQ 1) THEN BEGIN
		WIDGET_CONTROl,/HOURGLASS
		PRINT,'Saving current loop points..'
		x_coords        = *(*(*info).loopparams).xp		
    y_coords        = *(*(*info).loopparams).yp
		x_loop_pts      = *(*(*info).loopparams).xr		
    y_loop_pts      = *(*(*info).loopparams).yr
		w_loop_pts      = *(*(*info).loopparams).w_lpts	
    spect_pos       = (*(*info).dataparams).lp
		t_saved         = (*(*info).dispparams).t
    ngaps           = (*(*info).loopparams).ngaps
    databounds      = *(*(*info).loopparams).databounds
    wdatabounds     = *(*(*info).loopparams).wdatabounds
		crispex_version = [(*(*info).versioninfo).version_number, $
      (*(*info).versioninfo).revision_number]
		CRISPEX_SAVE_DETERMINE_FILENAME, event, outfilename=filename, /tlab, ext='clsav'
		SAVE, crispex_version, x_coords, y_coords, x_loop_pts, y_loop_pts, $
      w_loop_pts, spect_pos, t_saved, ngaps, databounds, wdatabounds, $
      FILENAME = (*(*info).paths).opath+filename
		PRINT,'Saving current loop points done. Saved data to: '+STRTRIM(filename,2)
		WIDGET_CONTROL, (*(*info).ctrlscp).sel_saved_loop, SENSITIVE = 1
		WIDGET_CONTROL, (*(*info).ctrlscp).all_saved_loop, SENSITIVE = 1
	ENDIF
END

PRO CRISPEX_SAVE_APPROX_LOOPSLICE, event
; Handles the saving of an approximate (i.e. nearest neighbour interpolated) timeslice along a loop
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	CRISPEX_SAVE_APPROX_LOOPSLAB, event, /SAVE_SLICE
END

PRO CRISPEX_SAVE_APPROX_LOOPSLAB, event, SAVE_SLICE=save_slice
; Handles the saving of an approximate (i.e. nearest neighbour interpolated)
;  timeslab along a loop 
  WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  ; Determine filenames
  CRISPEX_SAVE_DETERMINE_FILENAME, event, outfilename=filename, /tlab, $
    ext='csav', export_id=expid 
  CRISPEX_SAVE_DETERMINE_FILENAME, event, infilename=filename, $
    outfilename=filename2, ext='clsav', /exch_ext
  ; Set save messages
	save_message1 = REPLICATE('Saving current approximate loop ',2)+$
    ['slab...','slice...']
	save_message2 = REPLICATE('Saving current approximate loop ',2)+$
    ['slab','slice']+REPLICATE(' done. Saved data to: '+STRTRIM(filename,2),2)
  ; Set loop_slab to slice or slab, depending on set keyword
	IF KEYWORD_SET(SAVE_SLICE) THEN $
    loop_slab = *(*(*info).loopsdata).loopslice $
  ELSE $
    loop_slab = *(*(*info).loopsdata).loopslab
  ; Check for writeability of output path
	CRISPEX_SAVE_CHECK_PATH_WRITE, event
  ; If output path is writeable, start writing
	IF ((*(*info).paths).opath_write) THEN BEGIN
		WIDGET_CONTROL,/HOURGLASS
		PRINT,save_message1[KEYWORD_SET(SAVE_SLICE)]
    ; Set all variables that are to be saved
		type            = 1
		average_spectrum= ((*(*info).dataparams).spec)[*,(*(*info).dataparams).s] 
		scaling_factor  = (*(*info).dataparams).ms
		vertices        = *(*(*info).loopsdata).crossloc
		x_coords        = *(*(*info).loopparams).xp	
    y_coords        = *(*(*info).loopparams).yp
		x_loop_pts      = *(*(*info).loopparams).xr			
    y_loop_pts      = *(*(*info).loopparams).yr
		w_loop_pts      = *(*(*info).loopparams).w_lpts		
    spect_pos       = (*(*info).dataparams).lp
		t_saved         = (*(*info).dispparams).t			
    loop_size       = (*(*info).loopsdata).loopsize
    ngaps           = (*(*info).loopparams).ngaps
    databounds      = *(*(*info).loopparams).databounds
    wdatabounds     = *(*(*info).loopparams).wdatabounds
		crispex_version = [(*(*info).versioninfo).version_number, $
                       (*(*info).versioninfo).revision_number]
    ; Save loop slab variables to IDL save file and print out message
		SAVE, crispex_version, type, average_spectrum, scaling_factor, vertices, $
      x_coords, y_coords, x_loop_pts, y_loop_pts, w_loop_pts, loop_size, $
      loop_slab, spect_pos, t_saved, ngaps, databounds, wdatabounds, $
      FILENAME=(*(*info).paths).opath+filename
		PRINT,save_message2[KEYWORD_SET(SAVE_SLICE)]
    ; Save loop path variables to separate IDL save file and print out message
		SAVE, crispex_version, x_coords, y_coords, x_loop_pts, y_loop_pts, $
      w_loop_pts, spect_pos, t_saved, FILENAME=(*(*info).paths).opath+filename2
		PRINT,'Saved current loop points for later retrieval to: '+STRTRIM(filename2,2)
    ; Reset buttons
		WIDGET_CONTROL, (*(*info).ctrlscp).sel_saved_loop, SENSITIVE = 1
		WIDGET_CONTROL, (*(*info).ctrlscp).all_saved_loop, SENSITIVE = 1
	ENDIF
END

PRO CRISPEX_SAVE_EXACT_LOOPSLICE, event
; Handles the saving of an exact (i.e. linearly interpolated) timeslice along a loop
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	CRISPEX_SAVE_EXACT_LOOPSLAB, event, /SAVE_SLICE
END

PRO CRISPEX_SAVE_EXACT_LOOPSLAB_CHECK, event, SAVE_SLICE=save_slice
; Opens a time estimate warning window
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	CRISPEX_SAVE_CHECK_PATH_WRITE, event
	IF ((*(*info).paths).opath_write EQ 1) THEN BEGIN
		IF ((*(*info).feedbparams).estimate_run EQ 0) THEN BEGIN
			CRISPEX_ESTIMATE_TIME_WINDOW, event
			CRISPEX_ESTIMATE_TIME_CALCULATION, event
			WIDGET_CONTROL, (*(*info).winids).estimatetlb, /DESTROY
			(*(*info).winids).estimatetlb = 0
			(*(*info).winswitch).estimate_win = 0
		ENDIF
		time = (*(*info).feedbparams).estimate_time * N_ELEMENTS(*(*(*info).loopparams).w_lpts)/FLOAT((*(*info).feedbparams).estimate_lx) * (*(*info).dataparams).nlp * (*(*info).dispparams).t_range
		(*(*info).savswitch).cont = 3
		CRISPEX_ESTIMATE_FULL_TIME, time, denom, units
		CRISPEX_SAVE_WARNING_YESNO, event, 'Saving the exact loop slab may take up to about',STRTRIM(CEIL(time/denom),2)+units+'. Do you wish to continue saving?',$
			OK_EVENT='CRISPEX_SAVE_LOOPSL_CONTINUE', CANCEL_EVENT='CRISPEX_SAVE_LOOPSL_ABORT'
		IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).savswitch).cont],labels=['Saving procedure']
	ENDIF
END

PRO CRISPEX_SAVE_EXACT_LOOPSLAB, event, SAVE_SLICE=save_slice
; Handles the saving of an exact (i.e. linearly interpolated) timeslab along a loop
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL,/HOURGLASS
  ; Set save sub-messages
	save_message1 = ['slab','slice']
	IF KEYWORD_SET(SAVE_SLICE) THEN BEGIN
		PRINT,'Saving current exact loop slice...'
    ; Get exact loop slice based on loop parameters
		CRISPEX_LOOP_GET_EXACT_SLICE, event, *(*(*info).data).imagedata, $
      *(*(*info).loopparams).xr, *(*(*info).loopparams).yr, $
      *(*(*info).loopparams).xp, *(*(*info).loopparams).yp, $
			*(*(*info).loopparams).w_lpts, *(*(*info).loopsdata).exact_loopslice, $
      *(*(*info).loopsdata).exact_crossloc, loopsize, /im
		(*(*info).loopsdata).exact_loopsize = loopsize
		loop_slab = *(*(*info).loopsdata).exact_loopslice
		lp_low = (*(*info).dataparams).lp	&	lp_upp = lp_low
	ENDIF ELSE BEGIN
		t_0 = SYSTIME(/SECONDS)
		feedback_text = 'Saving current exact loop slab...'
		PRINT,feedback_text
		(*(*info).savparams).lp_orig = (*(*info).dataparams).lp
		lp_low = 0	&	lp_upp = (*(*info).dataparams).nlp-1
		FOR k=lp_low,lp_upp DO BEGIN
      ; Call user feedback with appropriate parameters
			CRISPEX_UPDATE_USER_FEEDBACK, event, title='Saving exact loop slab', $
        var=k, maxvar=(*(*info).dataparams).nlp-1, $
        feedback_text=feedback_text+'            ',/destroy_top
			(*(*info).dataparams).lp = k
      ; Get exact loop slice based on loop parameters
			CRISPEX_LOOP_GET_EXACT_SLICE, event, *(*(*info).data).imagedata, $
        *(*(*info).loopparams).xr, *(*(*info).loopparams).yr, $
        *(*(*info).loopparams).xp, *(*(*info).loopparams).yp, $
				*(*(*info).loopparams).w_lpts, *(*(*info).loopsdata).exact_loopslice, $
        *(*(*info).loopsdata).exact_crossloc, loopsize, /im
			IF (k EQ 0) THEN $
				*(*(*info).loopsdata).exact_loopslab = $
          *(*(*info).loopsdata).exact_loopslice $
			ELSE $
        *(*(*info).loopsdata).exact_loopslab = $
          [[[*(*(*info).loopsdata).exact_loopslab]], $
          [[*(*(*info).loopsdata).exact_loopslice]]]
			t_1 = SYSTIME(/SECONDS)
      ; Estimate saving time based on what has been extracted until now
			CRISPEX_ESTIMATE_FULL_TIME_RUNNING, k+1, (*(*info).dataparams).nlp, t_0, $
        t_1, denom, units, accumsectime, totalsectime
      ; Set feedback message
			feedback_text = STRTRIM(k+1,2)+'/'+STRTRIM((*(*info).dataparams).nlp,2)+$
        ' slices extracted in '+STRTRIM(STRING(accumsectime/denom,$
        FORMAT='(3(F9.2,x))'),2)+'/'+STRTRIM(STRING(totalsectime/denom,$
        FORMAT='(3(F9.2,x))'),2)+units
		ENDFOR
		(*(*info).dataparams).lp = (*(*info).savparams).lp_orig
		loop_slab = *(*(*info).loopsdata).exact_loopslab
	ENDELSE
	(*(*info).loopsdata).exact_loopsize = loopsize
  ; Check for writeability of output path
	CRISPEX_SAVE_CHECK_PATH_WRITE, event
  ; If output path is writeable, start writing
	IF ((*(*info).paths).opath_write EQ 1) THEN BEGIN
		WIDGET_CONTROL,/HOURGLASS
    ; Set all variables that are to be saved
  	type            = 0
  	average_spectrum= ((*(*info).dataparams).spec)[*,(*(*info).dataparams).s] 
  	scaling_factor  = (*(*info).dataparams).ms
  	vertices        = *(*(*info).loopsdata).exact_crossloc
  	x_coords        = *(*(*info).loopparams).xp  
    y_coords        = *(*(*info).loopparams).yp
  	x_loop_pts      = *(*(*info).loopparams).xr				
    y_loop_pts      = *(*(*info).loopparams).yr
		w_loop_pts      = *(*(*info).loopparams).w_lpts		
  	spect_pos       = (*(*info).dataparams).lp				
    loop_size       = (*(*info).loopsdata).exact_loopsize
  	spect_pos_low   = lp_low						
    spect_pos_upp   = lp_upp
  	t_low           = (*(*info).dispparams).t_low				
    t_upp           = (*(*info).dispparams).t_upp
  	t_saved         = (*(*info).dispparams).t
    ngaps           = (*(*info).loopparams).ngaps
    databounds      = *(*(*info).loopparams).databounds
    wdatabounds     = *(*(*info).loopparams).wdatabounds
  	crispex_version = [(*(*info).versioninfo).version_number, $
                       (*(*info).versioninfo).revision_number]
  	CRISPEX_SAVE_DETERMINE_FILENAME, event, outfilename=filename, /tlab, $
      ext='csav'
  	IF ~KEYWORD_SET(SAVE_SLICE) THEN CRISPEX_WINDOW_USER_FEEDBACK_CLOSE, event
    ; Save loop slab variables to IDL save file and print out message
  	SAVE, crispex_version, type, average_spectrum, scaling_factor, vertices, $
      x_coords, y_coords, x_loop_pts, y_loop_pts, w_loop_pts, loop_size, loop_slab, $
      spect_pos, lp_low, lp_upp, t_saved, t_low, t_upp, ngaps, databounds, $
      wdatabounds, FILENAME = (*(*info).paths).opath+filename
  	PRINT,'Saving current exact loop '+save_message1[KEYWORD_SET(SAVE_SLICE)]+$
      ' done. Saved data to: '+STRTRIM(filename,2)
  ENDIF
END

PRO CRISPEX_SAVE_LOOPSL_CONTINUE, event
; Handles continue events from the loopslice/slab warning window
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  CASE (*(*info).savswitch).cont OF
  ; Save diagram from saved path at single spectral position
    1: CRISPEX_SAVE_RETRIEVE_LOOPSLAB, event, /SAVE_SLICE		
  ; Save diagram from saved path for all spectral positions
    2: CRISPEX_SAVE_RETRIEVE_LOOPSLAB, event 		
  ; Save diagram for all spectral positions
    3: CRISPEX_SAVE_EXACT_LOOPSLAB, event 				
  ; Save diagram from saved detection at single spectral position
    4: CRISPEX_SAVE_RETRIEVE_DET_LOOPSLAB, event, /SAVE_SLICE		
  ; Save diagram from saved detection at all spectral positions
    5: CRISPEX_SAVE_RETRIEVE_DET_LOOPSLAB, event 			
    ELSE: RETURN
  ENDCASE
END

PRO CRISPEX_SAVE_LOOPSL_ABORT, event
; Handles abort event from the loopslice/slab warning window
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savswitch).cont = 0
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).savswitch).cont],$
      labels=['Saving procedure']
	WIDGET_CONTROL, event.TOP, /DESTROY
END

PRO CRISPEX_SAVE_RETRIEVE_LOOPSLAB, event, SAVE_SLICE=save_slice
; Handles the saving of an exact (i.e. linearly interpolated) timeslab along a
;  retrieved loop 
  WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  ; Store current wavelength values, to be restored once done
	(*(*info).savparams).lp_orig = (*(*info).dataparams).lp
	(*(*info).savparams).lp_ref_orig = (*(*info).dataparams).lp_ref
	nfiles = (*(*info).retrparams).retrieve_filecount * $
    CEIL((*(*info).savswitch).imref_only/2.)
	pass = 0L
	loopdet = ([2,1])[KEYWORD_SET(SAVE_SLICE)]
  ; Set variables depending on whether saving a slice or a slab
	IF KEYWORD_SET(SAVE_SLICE) THEN BEGIN
		nlp_pos = 1				&	refnlp_pos = 1
		save_message = 'slice'
	ENDIF ELSE BEGIN
		nlp_pos = (*(*info).dataparams).nlp	
    refnlp_pos = (*(*info).dataparams).refnlp
		save_message = 'slab'
	ENDELSE
  ; Determine number of passes, depending on saving from main, ref or both
	IF ((*(*info).savswitch).imref_only EQ 1) THEN $
    maxpass = nlp_pos * nfiles $
  ELSE IF ((*(*info).savswitch).imref_only EQ 2) THEN $
    maxpass = refnlp_pos * nfiles $
  ELSE $
		maxpass = (nlp_pos + refnlp_pos) * (*(*info).retrparams).retrieve_filecount
	t_0 = SYSTIME(/SECONDS)
	WIDGET_CONTROL,/HOURGLASS
  ; Check output path for writeability
	CRISPEX_SAVE_CHECK_PATH_WRITE, event
	FOR i=0,nfiles-1 DO BEGIN
		t_1 = SYSTIME(/SECONDS)
    ; Get current filename
		fstr = (*(*(*info).retrparams).retrieve_files)[$
            (i MOD (*(*info).retrparams).retrieve_filecount)]
    ; Determine save filename, based on input file names
		IF ((*(*info).dataparams).refimfilename NE '') THEN $
      CRISPEX_SAVE_RETRIEVE_DETERMINE_FILENAME, event, $
        (*(*info).savswitch).imref_only, (*(*info).dataparams).imfilename, $
			  refimfilename=(*(*info).dataparams).refimfilename, $
        *(*(*info).data).imagedata, refdata=*(*(*info).data).refdata, $
        (*(*info).paths).opath, i, (*(*info).retrparams).retrieve_filecount, $
        filename, data, nonlp, imref, whichdata, fstr=fstr, loopdet=loopdet $
    ELSE $
			CRISPEX_SAVE_RETRIEVE_DETERMINE_FILENAME, event, $
        (*(*info).savswitch).imref_only, (*(*info).dataparams).imfilename, $
        *(*(*info).data).imagedata, (*(*info).paths).opath, i, $
				(*(*info).retrparams).retrieve_filecount, filename, data, nonlp, $
        imref, whichdata, fstr=fstr, loopdet=loopdet
    ; Restore loop path file
		RESTORE,(*(*(*info).retrparams).retrieve_files)[$
      (i MOD (*(*info).retrparams).retrieve_filecount)] 
    ; Check whether saved-from file is different from current data file
    saved_from = FILE_BASENAME(fstr,'.clsav')
    saved_to = FILE_BASENAME(filename,'.csav')
    IF (saved_to NE saved_from) THEN BEGIN
      IF (imref EQ 1) THEN BEGIN
        ; Current data file is main, but path was saved from ref
        ; Convert path coordinates from ref to main
        IF ((*(*info).dataswitch).wcs_set AND $
          (*(*info).dataswitch).ref_wcs_set) THEN BEGIN
          IF ((TOTAL(x_coords LT 0) EQ 0) AND $
            (TOTAL(x_coords GE (*(*info).dataparams).refnx) EQ 0) AND $
            (TOTAL(y_coords LT 0) EQ 0) AND $
            (TOTAL(y_coords GE (*(*info).dataparams).refny)) EQ 0) THEN BEGIN
            xp_main = $
              REFORM(((*(*info).dataparams).pix_ref2main[*,x_coords,0])[0,*])
            yp_main = $
              REFORM(((*(*info).dataparams).pix_ref2main[*,0,y_coords])[1,0,*])
            xyp = {x:xp_main, y:yp_main}
          ENDIF ELSE $
            xyp = CRISPEX_TRANSFORM_GET_WCS(x_coords, y_coords, $
              (*(*info).dataparams).wcs_ref, (*(*info).dataparams).wcs_main, $
              /PIXEL, /COORD)
        ENDIF ELSE BEGIN
          xyp = CRISPEX_TRANSFORM_COORDS(x_coords, y_coords, $
            (*(*info).dataparams).refdx, (*(*info).dataparams).dx, $
            (*(*info).dataparams).refdy, (*(*info).dataparams).dy, $
            (*(*info).dataparams).xval_ref, (*(*info).dataparams).xval, $
            (*(*info).dataparams).yval_ref, (*(*info).dataparams).yval, $
            (*(*info).dataparams).xpix_ref, (*(*info).dataparams).xpix, $
            (*(*info).dataparams).ypix_ref, (*(*info).dataparams).ypix)
        ENDELSE
        xypath = CRISPEX_GET_PATH(xyp.x, xyp.y, N_ELEMENTS(xyp.x), $
          (*(*info).dataparams).nx, (*(*info).dataparams).ny)
        x_coords = xyp.x
        y_coords = xyp.y
        x_loop_pts = xypath.xr
        y_loop_pts = xypath.yr
        nx = (*(*info).dataparams).nx
        ny = (*(*info).dataparams).ny
      ENDIF ELSE BEGIN
        ; Current data file is ref, but path was saved from main
        ; Convert path coordinates from main to ref
        IF ((*(*info).dataswitch).wcs_set AND $
          (*(*info).dataswitch).ref_wcs_set) THEN BEGIN
          IF ((TOTAL(x_coords LT 0) EQ 0) AND $
            (TOTAL(x_coords GE (*(*info).dataparams).nx) EQ 0) AND $
            (TOTAL(y_coords LT 0) EQ 0) AND $
            (TOTAL(y_coords GE (*(*info).dataparams).ny)) EQ 0) THEN BEGIN
            xp_ref = $
              REFORM(((*(*info).dataparams).pix_main2ref[*,x_coords,0])[0,*])
            yp_ref = $
              REFORM(((*(*info).dataparams).pix_main2ref[*,0,y_coords])[1,0,*])
            xyp = {x:xp_ref, y:yp_ref}
          ENDIF ELSE $
            xyp = CRISPEX_TRANSFORM_GET_WCS(x_coords, y_coords, $
              (*(*info).dataparams).wcs_main, (*(*info).dataparams).wcs_ref, $
              /PIXEL, /COORD)
        ENDIF ELSE BEGIN
          xyp = CRISPEX_TRANSFORM_COORDS(x_coords, y_coords, $
            (*(*info).dataparams).dx, (*(*info).dataparams).refdx, $
            (*(*info).dataparams).dy, (*(*info).dataparams).refdy, $
            (*(*info).dataparams).xval, (*(*info).dataparams).xval_ref, $
            (*(*info).dataparams).yval, (*(*info).dataparams).yval_ref, $
            (*(*info).dataparams).xpix, (*(*info).dataparams).xpix_ref, $
            (*(*info).dataparams).ypix, (*(*info).dataparams).ypix_ref)
        ENDELSE
        xypath = CRISPEX_GET_PATH(xyp.x, xyp.y, N_ELEMENTS(xyp.x), $
          (*(*info).dataparams).refnx, (*(*info).dataparams).refny)
        x_coords = xyp.x
        y_coords = xyp.y
        x_loop_pts = xypath.xr
        y_loop_pts = xypath.yr
        nx = (*(*info).dataparams).refnx
        ny = (*(*info).dataparams).refny
      ENDELSE
	    w_loop_pts = $
        WHERE((x_loop_pts GE 0) AND (x_loop_pts LT (nx)) AND $
              (y_loop_pts GE 0) AND (y_loop_pts LT (ny)), nw_lpts)
    ENDIF
		IF (N_ELEMENTS(T_SAVED) NE 1) THEN t_saved = (*(*info).dispparams).t
		IF KEYWORD_SET(SAVE_SLICE) THEN BEGIN
      IF (imref EQ 1) THEN BEGIN
        IF (saved_from EQ saved_to) THEN $
			    lp_low = spect_pos<((*(*info).dataparams).nlp-1)	$
        ELSE $
          lp_low = (*(*info).savparams).lp_orig
      ENDIF ELSE BEGIN
        IF (saved_from EQ saved_to) THEN $
			    lp_low = spect_pos<((*(*info).dataparams).refnlp-1) $
        ELSE $
          lp_low = (*(*info).savparams).lp_ref_orig
      ENDELSE
      lp_upp = lp_low
      spect_pos = lp_low
		ENDIF ELSE BEGIN
			lp_low = 0
			IF (imref EQ 1) THEN BEGIN
				lp_upp = (*(*info).dataparams).nlp-1 
        IF (saved_from NE saved_to) THEN $
          spect_pos = (*(*info).savparams).lp_orig
			ENDIF ELSE BEGIN
				lp_upp = (*(*info).dataparams).refnlp-1	
        IF (saved_from NE saved_to) THEN $
          spect_pos = (*(*info).savparams).lp_ref_orig
			ENDELSE
		ENDELSE
		FOR k=lp_low,lp_upp DO BEGIN
			pass += 1L
			part = STRTRIM(pass,2)+'/'+STRTRIM(maxpass,2)
			IF (pass EQ 1) THEN $
        feedback_text = ': saving retrieved exact loop '+$
          save_message+'...               '
			CRISPEX_UPDATE_USER_FEEDBACK, event, title='Saving retrieved loop '+$
        save_message+'(s)', var=pass-1, maxvar=maxpass, feedback_text=part+$
        feedback_text, /destroy_top
			IF (imref EQ 1) THEN $ 
        (*(*info).dataparams).lp = k $
       ELSE $
        (*(*info).dataparams).lp_ref = k
			CRISPEX_LOOP_GET_EXACT_SLICE, event, data, x_loop_pts, $
        y_loop_pts, x_coords, y_coords, w_loop_pts, loop_slice_out, $
        crossloc_out, loopsize_out, im=whichdata
			IF ~KEYWORD_SET(SAVE_SLICE) THEN BEGIN
				IF (k EQ lp_low) THEN $
          loop_slab = loop_slice_out $
        ELSE $
          loop_slab = [ [[loop_slab]], [[loop_slice_out]] ]
			ENDIF ELSE $
        loop_slab = loop_slice_out
			t_1 = SYSTIME(/SECONDS)
			CRISPEX_ESTIMATE_FULL_TIME_RUNNING, pass, maxpass, t_0, t_1, denom, $
        units, accumsectime, totalsectime
			feedback_text = ' slices extracted in '+$
        STRTRIM(STRING(accumsectime/denom,FORMAT='(3(F9.2,x))'),2)+'/'+$
        STRTRIM(STRING(totalsectime/denom,FORMAT='(3(F9.2,x))'),2)+units
		ENDFOR
    ; Check for gaps if info not availabe from restored file (although it will
    ; likely have no gaps then)
    IF ((N_ELEMENTS(ngaps) NE 0) AND (saved_to EQ saved_from)) THEN $
      result = {ngaps:ngaps, databounds:databounds, wdatabounds:wdatabounds} $
    ELSE $ 
      result = CRISPEX_ARRAY_GET_GAP(w_loop_pts, N_ELEMENTS(x_loop_pts))
		type = 0
		IF (imref EQ 1) THEN BEGIN
			average_spectrum= ((*(*info).dataparams).spec)[*,(*(*info).dataparams).s] 
			scaling_factor  = (*(*info).dataparams).ms
		ENDIF ELSE BEGIN
			average_spectrum= ((*(*info).dataparams).refspec)
			scaling_factor  = (*(*info).dataparams).refms
		ENDELSE
    vertices        = crossloc_out
		spect_pos_low   = lp_low						
    spect_pos_upp   = lp_upp
    loop_size       = loopsize_out
		t_low           = (*(*info).dispparams).t_low				
    t_upp           = (*(*info).dispparams).t_upp
    ngaps           = result.ngaps
    databounds      = result.databounds
    wdatabounds     = result.wdatabounds
		crispex_version = [(*(*info).versioninfo).version_number, $
      (*(*info).versioninfo).revision_number]
    singlefilename = FILE_BASENAME(filename)
		SAVE, crispex_version, type, average_spectrum, scaling_factor, vertices, $
      x_coords, y_coords, x_loop_pts, y_loop_pts, loop_size, loop_slab, $
      spect_pos, spect_pos_low, spect_pos_upp, t_saved, t_low, t_upp, $
      ngaps, databounds, wdatabounds, $
			FILENAME = (*(*info).paths).opath+singlefilename 
		PRINT,'Saving retrieved exact loop '+save_message+' done. Saved data to: '+$
      STRTRIM(singlefilename,2)
		IF (*(*info).savswitch).delete_clsav THEN BEGIN
			IF ((*(*info).savswitch).imref_only LE 2) THEN $
        FILE_DELETE, STRTRIM((*(*(*info).retrparams).retrieve_files)[i],2), /QUIET $
      ELSE BEGIN
				IF (i GE (*(*info).retrparams).retrieve_filecount) THEN $
          FILE_DELETE, STRTRIM((*(*(*info).retrparams).retrieve_files)[$
                        (i MOD (*(*info).retrparams).retrieve_filecount)],2), /QUIET
			ENDELSE
		ENDIF
	ENDFOR
	CRISPEX_WINDOW_USER_FEEDBACK_CLOSE, event
	(*(*info).dataparams).lp = (*(*info).savparams).lp_orig
	(*(*info).dataparams).lp_ref = (*(*info).savparams).lp_ref_orig
END

PRO CRISPEX_SAVE_RETRIEVE_DETERMINE_FILENAME, event, imref_only, imfilename, refimfilename=refimfilename, imdata, refdata=refdata, opath, var, endoflist, outputfilename, outputdata, outputnonlp, outputimref, outputwhichdata, $
	index=index, fstr=fstr, loopdet=loopdet
; Determines the filename of the retrieved loop path or detection timeslice to be saved
	; loopdet = 1 > loop, slice
	; loopdet = 2 > loop, slab
	; loopdet = 3 > det, slice
	; loopdet = 4 > det, slab
	; outputimref = 1 > main
	; outputimref = 2 > reference
	IF (imref_only EQ 1) THEN BEGIN			; Only save from main cube
		IF (loopdet LE 2) THEN CRISPEX_SAVE_DETERMINE_FILENAME, event, infilename=fstr, outfilename=outputfilename, ext='csav', /exch_ext ELSE $
			CRISPEX_SAVE_DETERMINE_FILENAME, event, infilename=fstr, outfilename=outputfilename, ext='csav', import_id = 'D'+STRTRIM(index,2)
		outputnonlp = (loopdet EQ 1)
		outputimref = 1
		outputdata = imdata
		outputwhichdata = 1
	ENDIF ELSE IF (imref_only EQ 2) THEN BEGIN	; Only save from reference cube
		IF (loopdet LE 2) THEN BEGIN
			clstr = STRSPLIT(fstr,'_',/EXTRACT)
			datestamp = clstr[N_ELEMENTS(clstr)-2]
			timestamp = (STRSPLIT(clstr[N_ELEMENTS(clstr)-1],'.',/EXTRACT))[0]
			CRISPEX_SAVE_DETERMINE_FILENAME, event, infilename=refimfilename, outfilename=outputfilename, ext='csav', import_id = datestamp+'_'+timestamp
		ENDIF ELSE CRISPEX_SAVE_DETERMINE_FILENAME, event, infilename=refimfilename, outfilename=outputfilename, ext='csav', import_id = 'D'+STRTRIM(index,2)
		outputnonlp = (loopdet EQ 3)
		outputimref = 2
		outputdata = refdata
		outputwhichdata = 0
	ENDIF ELSE BEGIN				; Save from both main and reference cube
		IF (var LT endoflist) THEN BEGIN
			IF (loopdet LE 2) THEN CRISPEX_SAVE_DETERMINE_FILENAME, event, infilename=fstr, outfilename=outputfilename, ext='csav', /exch_ext ELSE $
				CRISPEX_SAVE_DETERMINE_FILENAME, event, infilename=fstr, outfilename=outputfilename, ext='csav', import_id = 'D'+STRTRIM(index,2)
			outputnonlp = (loopdet EQ 1)
			outputimref = 1
			outputdata = imdata
			outputwhichdata = 1
		ENDIF ELSE BEGIN
			IF (loopdet LE 2) THEN BEGIN
				clstr = STRSPLIT(fstr,'_',/EXTRACT)
				datestamp = clstr[N_ELEMENTS(clstr)-2]
				timestamp = (STRSPLIT(clstr[N_ELEMENTS(clstr)-1],'.',/EXTRACT))[0]
				CRISPEX_SAVE_DETERMINE_FILENAME, event, infilename=refimfilename, outfilename=outputfilename, ext='csav', import_id = datestamp+'_'+timestamp
			ENDIF ELSE CRISPEX_SAVE_DETERMINE_FILENAME, event, infilename=refimfilename, outfilename=outputfilename, ext='csav', import_id = 'D'+STRTRIM(index,2)
			outputnonlp = (loopdet EQ 3)
			outputimref = 2
			outputdata = refdata
			outputwhichdata = 0
		ENDELSE
	ENDELSE
END

PRO CRISPEX_SAVE_RETRIEVE_DET_LOOPSLAB, event, SAVE_SLICE=save_slice
; Handles the saving of an exact (i.e. linearly interpolated) timeslab along a
; retrieved detection 
  WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	nfiles = (*(*info).detparams).nr_sel_loops * $
    CEIL((*(*info).savswitch).det_imref_only/2.)
	pass = 0
	loopdet = ([4,3])[KEYWORD_SET(SAVE_SLICE)]
  ; Store original temporal boundaries and wavelength position
	lower_t = (*(*info).dispparams).t_low
	upper_t = (*(*info).dispparams).t_upp
	(*(*info).savparams).lp_orig = (*(*info).dataparams).lp
  ; Determine wavelength boundaries, based on save settings
	IF KEYWORD_SET(SAVE_SLICE) THEN BEGIN
    ; Saving slice, from main 
		lp_dn = (*(*info).dataparams).lp	
    lp_up = lp_dn
		IF ((*(*info).savswitch).det_imref_only GE 2) THEN BEGIN
      ; Saving slice, either from ref only or from main and ref
			lp_ref_dn = (*(*info).dataparams).lp_ref	
      lp_ref_up = lp_ref_dn
		ENDIF
	ENDIF ELSE BEGIN
    ; Saving slab
		IF ((*(*info).savswitch).pos_dets EQ 1) THEN BEGIN
      ; All wavelengths, for main
			lp_dn = (*(*info).dispparams).lp_first	
      lp_up = (*(*info).dispparams).lp_last
			IF ((*(*info).savswitch).det_imref_only GE 2) THEN BEGIN
        ; All wavelengths, either from ref only or from main and ref
				lp_ref_dn = (*(*info).dispparams).lp_ref_first	
        lp_ref_up = (*(*info).dispparams).lp_ref_last
			ENDIF
		ENDIF 
	ENDELSE
  IF ((*(*info).savswitch).pos_dets NE 3) THEN BEGIN
    ; Selected wavelengths, from main
  	(*(*info).detparams).lp_dn = lp_dn	
    (*(*info).detparams).lp_up = lp_up
    IF ((*(*info).savswitch).det_imref_only GE 2) THEN BEGIN
      ; Selected wavelengths, from reference
			(*(*info).detparams).lp_ref_dn = lp_ref_dn	
      (*(*info).detparams).lp_ref_up = lp_ref_up
    ENDIF
  ENDIF
  lp_range = (*(*info).detparams).lp_up-(*(*info).detparams).lp_dn+1
  lp_ref_range = (*(*info).detparams).lp_ref_up-(*(*info).detparams).lp_ref_dn+1
  ; Determine number of maximum passes, based on what to save
	IF ((*(*info).savswitch).det_imref_only EQ 1) THEN $
    maxpass = lp_range * (*(*info).detparams).width * nfiles $
  ELSE IF ((*(*info).savswitch).det_imref_only EQ 2) THEN $
    maxpass = lp_ref_range * (*(*info).detparams).width * nfiles $
  ELSE $
		maxpass = (lp_range  + lp_ref_range) * (*(*info).detparams).width * $
                (*(*info).detparams).nr_sel_loops
  ; Determine saved wavelength
	IF ((*(*info).savparams).lp_orig LT (*(*info).detparams).lp_dn) THEN $
    lp_im_saved = (*(*info).detparams).lp_dn $
  ELSE IF ((*(*info).savparams).lp_orig GT (*(*info).detparams).lp_up) THEN $
    lp_im_saved = (*(*info).detparams).lp_up $
  ELSE $
    lp_im_saved = (*(*info).savparams).lp_orig
	IF ((*(*info).savswitch).det_imref_only GE 2) THEN BEGIN
    ; Store original wavelength and determine saved wavlength for ref
		(*(*info).savparams).lp_ref_orig = (*(*info).dataparams).lp_ref
		IF ((*(*info).savparams).lp_ref_orig LT $
      (*(*info).detparams).lp_ref_dn) THEN $
      lp_ref_saved = (*(*info).detparams).lp_ref_dn $
    ELSE IF ((*(*info).savparams).lp_ref_orig GT $
      (*(*info).detparams).lp_ref_up) THEN $
      lp_ref_saved = (*(*info).detparams).lp_ref_up $
    ELSE $
      lp_ref_saved = (*(*info).savparams).lp_ref_orig
	ENDIF
	t_0 = SYSTIME(/SECONDS)
  ; Loop over all detections to be retrieved
	FOR i=0,nfiles-1 DO BEGIN
		WIDGET_CONTROL,/HOURGLASS
		part = STRTRIM(i+1,2)+'/'+STRTRIM(nfiles,2)
    ; Get the current detection index
		idx = (*(*(*info).detparams).sel_loops)[$
      (i MOD (*(*info).detparams).nr_sel_loops)]
    ; Determine the output filename
		IF ((*(*info).dataparams).refimfilename NE '') THEN BEGIN
      CRISPEX_SAVE_RETRIEVE_DETERMINE_FILENAME, event, $
        (*(*info).savswitch).det_imref_only, (*(*info).dataparams).imfilename, $
			  refimfilename=(*(*info).dataparams).refimfilename, $
        *(*(*info).data).imagedata, refdata=*(*(*info).data).refdata, $
        (*(*info).paths).opath, i, (*(*info).detparams).nr_sel_loops, $
        filename, data, nonlp, detimref, detwhichdata, fstr=fstr, $
        loopdet=loopdet, index=idx 
    ENDIF ELSE BEGIN
			CRISPEX_SAVE_RETRIEVE_DETERMINE_FILENAME, event, $
        (*(*info).savswitch).det_imref_only, (*(*info).dataparams).imfilename, $
        *(*(*info).data).imagedata, (*(*info).paths).opath, i, $
				(*(*info).detparams).nr_sel_loops, filename, data, nonlp, detimref, $
        detwhichdata, fstr=fstr, loopdet=loopdet, index=idx
    ENDELSE
		delta = FLOOR((*(*info).detparams).width/2.)
    ; Get path variables
    xlp_det = *(*(*(*info).detparams).xlp)[idx]
    ylp_det = *(*(*(*info).detparams).ylp)[idx]
    xlr_det = *(*(*(*info).detparams).xlr)[idx]
    ylr_det = *(*(*(*info).detparams).ylr)[idx]
    ; Loop over detection width to get the smallest subset of w_lpts in order to
    ; determine path selection, gaps, etc. (and if necessary, conversions to
    ; reference) 
		IF (detimref EQ 1) THEN BEGIN
      ; If saving from main, set parameters accordingly
      data = (*(*info).data).imagedata
      lp_saved = lp_im_saved 
      nx = (*(*info).dataparams).nx
      ny = (*(*info).dataparams).ny
			lp_dn = (*(*info).detparams).lp_dn 	
      lp_up = (*(*info).detparams).lp_up < ((*(*info).dataparams).nlp-1)
    ENDIF ELSE BEGIN
      ; If saving from reference, set parameters accordingly
      data = (*(*info).data).refdata
			lp_saved = lp_ref_saved
			lp_dn = (*(*info).detparams).lp_ref_dn 	
      lp_up = (*(*info).detparams).lp_ref_up < $
        ((*(*info).dataparams).refnlp-1)
      nx = (*(*info).dataparams).refnx
      ny = (*(*info).dataparams).refny
      ; Transform coordinates if necessary
      IF ((*(*info).dispswitch).main2ref_no_map EQ 0) THEN BEGIN
        IF ((*(*info).dataswitch).wcs_set AND $
          (*(*info).dataswitch).ref_wcs_set) THEN BEGIN
          IF ((TOTAL(xlp_det LT 0) EQ 0) AND $
            (TOTAL(xlp_det GE (*(*info).dataparams).nx) EQ 0) AND $
            (TOTAL(ylp_det LT 0) EQ 0) AND $
            (TOTAL(ylp_det GE (*(*info).dataparams).ny)) EQ 0) THEN BEGIN
            xlp_ref = $
              REFORM(((*(*info).dataparams).pix_main2ref[*,xlp_det,0])[0,*])
            ylp_ref = $
              REFORM(((*(*info).dataparams).pix_main2ref[*,0,ylp_det])[1,0,*])
            xylp_ref = {x:xlp_ref, y:ylp_ref}
          ENDIF ELSE $
            xylp_ref = CRISPEX_TRANSFORM_GET_WCS(xlp_det, ylp_det, $
              (*(*info).dataparams).wcs_main, (*(*info).dataparams).wcs_ref, $
              /PIXEL, /COORD)
        ENDIF ELSE BEGIN
          xylp_ref = CRISPEX_TRANSFORM_COORDS(xlp_det, ylp_det, $
            (*(*info).dataparams).dx, (*(*info).dataparams).refdx, $
            (*(*info).dataparams).dy, (*(*info).dataparams).refdy, $
            (*(*info).dataparams).xval, (*(*info).dataparams).xval_ref, $
            (*(*info).dataparams).yval, (*(*info).dataparams).yval_ref, $
            (*(*info).dataparams).xpix, (*(*info).dataparams).xpix_ref, $
            (*(*info).dataparams).ypix, (*(*info).dataparams).ypix_ref)
        ENDELSE
        xlp_det = xylp_ref.x
        ylp_det = xylp_ref.y
  		  FOR k=((*(*info).detparams).mid-delta),$
              ((*(*info).detparams).mid+delta) DO BEGIN
          xlr_tmp = (xlr_det)[*,k]
          ylr_tmp = (ylr_det)[*,k]
          IF ((*(*info).dataswitch).wcs_set AND $
            (*(*info).dataswitch).ref_wcs_set) THEN $
            xylr_ref = CRISPEX_TRANSFORM_GET_WCS(xlr_tmp, ylr_tmp, $
              (*(*info).dataparams).wcs_main, (*(*info).dataparams).wcs_ref, $
              /PIXEL, /COORD, /NO_ROUND) $
          ELSE BEGIN
            xylr_ref = CRISPEX_TRANSFORM_COORDS(xlr_tmp, ylr_tmp, $
              (*(*info).dataparams).dx, (*(*info).dataparams).refdx, $
              (*(*info).dataparams).dy, (*(*info).dataparams).refdy, $
              (*(*info).dataparams).xval, (*(*info).dataparams).xval_ref, $
              (*(*info).dataparams).yval, (*(*info).dataparams).yval_ref, $
              (*(*info).dataparams).xpix, (*(*info).dataparams).xpix_ref, $
              (*(*info).dataparams).ypix, (*(*info).dataparams).ypix_ref)
          ENDELSE
          xlr_det[*,k] = xylr_ref.x
          ylr_det[*,k] = xylr_ref.y
        ENDFOR
      ENDIF
    ENDELSE
    ; Get detection slab
    inparams = {xlp:xlp_det, ylp:ylp_det, xlr:xlr_det, ylr:ylr_det, $
      nx:nx, ny:ny, lp_dn:lp_dn, lp_up:lp_up, no_nlp:nonlp, idx:idx, $
      detimref:detimref, data:data, t_0:t_0, maxpass:maxpass}
    CRISPEX_RETRIEVE_DET_GET_SLAB, event, inparams, w_lpts_out, gapresult_out, $
      loopslab_out, crossloc_out, loopsize_out, t_det_out, t_low_out, $
      t_upp_out, /SAVE_DET
    ; Save variables
	  loop_slab = loopslab_out 
		type = 0
		IF (detimref EQ 1) THEN BEGIN
			average_spectrum = ((*(*info).dataparams).spec)[*,(*(*info).dataparams).s] 
			scaling_factor = (*(*info).dataparams).ms
		ENDIF ELSE BEGIN
			average_spectrum = ((*(*info).dataparams).refspec)
			scaling_factor = (*(*info).dataparams).refms
		ENDELSE
		vertices        = crossloc_out
		spect_pos       = lp_saved	
    spect_pos_low   = lp_dn	
    spect_pos_upp   = lp_up
    loop_size       = loopsize_out
		x_coords        = xlp_det				
    y_coords        = ylp_det
    x_loop_pts      = REFORM(xlr_det[*,(*(*info).detparams).mid])
    y_loop_pts      = REFORM(ylr_det[*,(*(*info).detparams).mid])
		t_saved         = t_det_out					
    t_low           = t_low_out
    t_upp           = t_upp_out
    ngaps           = gapresult_out.ngaps
    databounds      = gapresult_out.databounds
    wdatabounds     = gapresult_out.wdatabounds
		crispex_version = [(*(*info).versioninfo).version_number, $
                       (*(*info).versioninfo).revision_number]
    singlefilename = FILE_BASENAME(filename)
    ; Save variables to file
		SAVE, crispex_version, type, average_spectrum, scaling_factor, vertices, $
      x_coords, y_coords, x_loop_pts, y_loop_pts, loop_size, loop_slab, $
      spect_pos, spect_pos_low, spect_pos_upp, t_saved, t_low, t_upp, $
      ngaps, databounds, wdatabounds, $
			FILENAME = (*(*info).paths).opath+singlefilename 
		PRINT,'Saving retrieved exact space-time diagram done. Saved data to: '+$
      STRTRIM(singlefilename,2)
	ENDFOR
  ; Reset display variable to original values
	(*(*info).dispparams).t_low = lower_t
	(*(*info).dispparams).t_upp = upper_t
	(*(*info).dataparams).lp = (*(*info).savparams).lp_orig
	IF ((*(*info).savswitch).det_imref_only GE 2) THEN $
    (*(*info).dataparams).lp_ref = (*(*info).savparams).lp_ref_orig
	CRISPEX_WINDOW_USER_FEEDBACK_CLOSE, event
END

;================================================================================= OUTPUT SAVE SETTINGS AND FILENAME CHECK
PRO CRISPEX_SAVE_CHECK_PATH_WRITE, event
; Checks whether the user has write permissions in the current opath
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).paths).opath_write = FILE_TEST((*(*info).paths).opath, /WRITE)
	IF ((*(*info).paths).opath_write EQ 0) THEN BEGIN
		CRISPEX_WINDOW_OK, event, 'ERROR!',$
      'You appear not to have write permissions to the current '+$
      'output directory ('+(*(*info).paths).opath+'). '+$
			'Please change the path before continuing saving.', $
      OK_EVENT='CRISPEX_CLOSE_EVENT_WINDOW', BASE=tlb, /BLOCK
		(*(*info).winids).errtlb = tlb
	END
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).paths).opath_write],labels=['Output path writeable']
END

PRO CRISPEX_SAVE_SET_IPATH, event 
; Sets the output path for all saving procedures
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	thispath = DIALOG_PICKFILE(TITLE = 'CRISPEX'+(*(*info).sesparams).instance_label+': Set input path', /DIRECTORY, PATH = (*(*info).paths).ipath)
	IF (thispath EQ '') THEN RETURN ELSE (*(*info).paths).ipath = thispath
	IF ((*(*info).winids).savewintlb GT 0) THEN WIDGET_CONTROL, (*(*info).ctrlssav).path_textlab, SET_VALUE = STRTRIM((*(*info).paths).ipath,2)
	IF (event.TOP EQ (*(*info).winids).preftlb) THEN (*(*info).prefs).tmp_prefipath = (*(*info).paths).ipath
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).paths).ipath],labels=['Input path']
END

PRO CRISPEX_SAVE_SET_OPATH, event 
; Sets the output path for all saving procedures
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	thispath = DIALOG_PICKFILE(TITLE = 'CRISPEX'+(*(*info).sesparams).instance_label+': Set output path', /DIRECTORY, PATH = (*(*info).paths).opath)
	IF (thispath EQ '') THEN RETURN ELSE (*(*info).paths).opath = thispath
	IF ((*(*info).winids).savewintlb GT 0) THEN WIDGET_CONTROL, (*(*info).ctrlssav).path_textlab, SET_VALUE = STRTRIM((*(*info).paths).opath,2)
	IF ((*(*info).winids).saveoptwintlb GT 0) THEN WIDGET_CONTROL, (*(*info).ctrlssav).savopt_path_textlab, SET_VALUE = STRTRIM((*(*info).paths).opath,2)
	IF (event.TOP EQ (*(*info).winids).preftlb) THEN (*(*info).prefs).tmp_prefopath = (*(*info).paths).opath
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).paths).opath],labels=['Output path']
END

PRO CRISPEX_SAVE_GET_FILENAME, event, title, standard_filename, ok_event, session_save=session_save, SNAPSHOT=snapshot
; Gets the filename for save routines
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF ((*(*info).winids).savewintlb NE 0) THEN BEGIN
		CRISPEX_WINDOW_OK, event, 'WARNING!',$
      'You are currently already saving output. Please finish '+$
      'saving or discard the current saving procedure first, '+$
			'before starting a new saving procedure.', OK_EVENT='CRISPEX_CLOSE_EVENT_WINDOW', BASE=tlb
		(*(*info).winids).warntlb = tlb
		RETURN
	END
	fulltitle = 'CRISPEX'+(*(*info).sesparams).instance_label+': '+STRTRIM(title,2)
	base = WIDGET_BASE(TITLE = title, GROUP_LEADER = (*(*info).winids).root, TLB_FRAME_ATTR = 1, /TLB_KILL_REQUEST_EVENTS)
	disp = WIDGET_BASE(base, /COLUMN)
	message_base = WIDGET_BASE(disp, /COLUMN)
	path_base = WIDGET_BASE(message_base, /ROW)
	path_label = WIDGET_LABEL(path_base, VALUE = 'Current path:')
	(*(*info).ctrlssav).path_textlab = WIDGET_LABEL(path_base, VALUE = STRTRIM((*(*info).paths).opath,2), /DYNAMIC_RESIZE)
	filename_base = WIDGET_BASE(message_base, /ROW)
	text_label1 = WIDGET_LABEL(filename_base, VALUE = 'Filename (w/o extension):')
	(*(*info).savparams).filename_text = WIDGET_TEXT(filename_base, VALUE = standard_filename,  /EDITABLE, XSIZE = 40)
	WIDGET_CONTROL, (*(*info).savparams).filename_text, SET_TEXT_SELECT = [0,STRLEN(standard_filename)]
	button_base = WIDGET_BASE(disp,COLUMN=3,/GRID_LAYOUT,/ALIGN_CENTER)
	IF KEYWORD_SET(SESSION_SAVE) THEN change_path_but = WIDGET_BUTTON(button_base, VALUE = 'Change path', EVENT_PRO = 'CRISPEX_SAVE_SET_OPATH') ELSE $
		options_but = WIDGET_BUTTON(button_base, VALUE = 'Options...', EVENT_PRO = 'CRISPEX_SAVE_OPTIONS')
	no_but = WIDGET_BUTTON(button_base, VALUE = 'Cancel', EVENT_PRO = 'CRISPEX_CLOSE_EVENT_WINDOW')
	yes_but = WIDGET_BUTTON(button_base, VALUE = 'OK' , EVENT_PRO = ok_event)
	WIDGET_CONTROL, base, /REALIZE, TLB_SET_XOFFSET = 500, TLB_SET_YOFFSET = 500
	WIDGET_CONTROL, base, SET_UVALUE = info
	XMANAGER, 'CRISPEX', base, /NO_BLOCK
	(*(*info).winids).savewintlb = base
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).winids).savewintlb],labels=['savewintlb']
END

PRO CRISPEX_SAVE_CHECK_FILENAME, event, extension, ok_event, midtension=midtension
; Checks the save filename for validity and overwrite problems
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	csesfiles = FILE_SEARCH((*(*info).paths).opath+"*"+extension, COUNT = csesfilecount)
	WIDGET_CONTROL, (*(*info).savparams).filename_text, GET_VALUE = session_filename
	IF (N_ELEMENTS(midtension) GT 0) THEN midtension = midtension ELSE midtension = ''
	full_session_filename = session_filename+midtension+'.'+extension
	compressedfilename = STRCOMPRESS(full_session_filename, /REMOVE_ALL)
	existing = WHERE(STRPOS(csesfiles,(*(*info).paths).opath+full_session_filename) EQ 0, count)
	IF (count LE 0) AND (session_filename NE '') AND (compressedfilename EQ full_session_filename)  AND ((*(*info).paths).opath_write EQ 1) THEN CRISPEX_SAVE_CONTINUE, event, session_filename $
	ELSE IF (count LE 0) AND (session_filename EQ '') OR (compressedfilename NE full_session_filename) THEN BEGIN
		CRISPEX_WINDOW_OK, event,'ERROR!',$
      'Invalid filename. Please enter a filename of '+$
      'at least one character and without any white spaces.',$
			OK_EVENT='CRISPEX_CLOSE_EVENT_WINDOW', BASE=tlb
		(*(*info).winids).errtlb = tlb
	ENDIF ELSE IF ((*(*info).paths).opath_write EQ 0) THEN CRISPEX_SAVE_CHECK_PATH_WRITE, event $
	ELSE CRISPEX_SAVE_WARNING_YESNO, event,'The file already exists. Do you wish to','continue and overwrite this file?', OK_EVENT=ok_event, CANCEL_EVENT='CRISPEX_CLOSE_EVENT_WINDOW'
END

PRO CRISPEX_SAVE_CONTINUE, event, session_filename
; Selects the continuation of saving session, JPEG or MPEG
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF ((*(*info).savparams).savpro EQ 'SESSION') THEN CRISPEX_SESSION_SAVE, event, session_filename
	IF ((STRPOS((*(*info).savparams).savpro,'FRAMES') NE -1) OR STRCMP((*(*info).savparams).savpro,'MPEG')) THEN CRISPEX_SAVE_FRAMES_SAVE, event, session_filename ELSE $
		IF (STRPOS((*(*info).savparams).savpro,'LINESCAN') NE -1) THEN CRISPEX_SAVE_LINESCAN_SAVE, event, session_filename
END

PRO CRISPEX_SAVE_WARNING_YESNO, event, warningmessage1, warningmessage2, warningmessage3, ok_event=ok_event, cancel_event=cancel_event
; Creates the loopslice/slab warning window
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	base = WIDGET_BASE(TITLE = 'CRISPEX'+(*(*info).sesparams).instance_label+': WARNING!', GROUP_LEADER = (*(*info).winids).root, TLB_FRAME_ATTR = 1, /TLB_KILL_REQUEST_EVENTS)
	disp = WIDGET_BASE(base, /COLUMN)
	message_base = WIDGET_BASE(disp, /COLUMN)
	IF (N_ELEMENTS(warningmessage1) GT 0) THEN text_label1 = WIDGET_LABEL(message_base, VALUE = warningmessage1)
	IF (N_ELEMENTS(warningmessage2) GT 0) THEN text_label2 = WIDGET_LABEL(message_base, VALUE = warningmessage2)
	IF (N_ELEMENTS(warningmessage3) GT 0) THEN text_label3 = WIDGET_LABEL(message_base, VALUE = warningmessage3)
	button_base = WIDGET_BASE(disp,/ROW,/ALIGN_CENTER)
	no_but = WIDGET_BUTTON(button_base, VALUE = 'No, cancel', EVENT_PRO = cancel_event)
	yes_but = WIDGET_BUTTON(button_base, VALUE = 'Yes, continue' , EVENT_PRO = ok_event)
	WIDGET_CONTROL, base, /REALIZE, TLB_SET_XOFFSET = 500, TLB_SET_YOFFSET = 500
	WIDGET_CONTROL, base, SET_UVALUE = info
	XMANAGER, 'CRISPEX', base, /NO_BLOCK
END

;================================================================================= OUTPUT SAVE PROCEDURES
PRO CRISPEX_SAVE_JPEG_SNAPSHOT, event
; Handles the saving of a single main image (as in display) as JPEG
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savparams).savpro = 'JPEG_FRAMES'
	(*(*info).savparams).snapshot = 1
	CRISPEX_SAVE_FRAMES, event
END	

PRO CRISPEX_SAVE_JPEG_ALL_FRAMES, event
; Handles the saving of a series of main images (as in display) as JPEG
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savparams).savpro = 'JPEG_FRAMES'
	(*(*info).savparams).snapshot = 0
	CRISPEX_SAVE_FRAMES, event
END

PRO CRISPEX_SAVE_JPEG_LINESCAN, event
; Handles the saving of a single main image (as in display) as JPEG
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savparams).savpro = 'JPEG_LINESCAN'
	CRISPEX_SAVE_LINESCAN, event
END	

PRO CRISPEX_SAVE_PNG_SNAPSHOT, event
; Handles the saving of a single main image (as in display) as JPEG
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savparams).savpro = 'PNG_FRAMES'
	(*(*info).savparams).snapshot = 1
	CRISPEX_SAVE_FRAMES, event
END	

PRO CRISPEX_SAVE_PNG_ALL_FRAMES, event
; Handles the saving of a series of main images (as in display) as JPEG
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savparams).savpro = 'PNG_FRAMES'
	(*(*info).savparams).snapshot = 0
	CRISPEX_SAVE_FRAMES, event
END

PRO CRISPEX_SAVE_PNG_LINESCAN, event
; Handles the saving of a single main image (as in display) as JPEG
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savparams).savpro = 'PNG_LINESCAN'
	CRISPEX_SAVE_LINESCAN, event
END	

PRO CRISPEX_SAVE_CHECK, event
; Checks the jpeg series save filename for validity and overwrite problems
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF ((*(*info).savparams).savpro EQ 'MPEG') THEN BEGIN
		extension = 'mpg'	&	midtension = ''
	ENDIF ELSE IF (STRPOS((*(*info).savparams).savpro,'FRAMES') NE -1) THEN BEGIN		; Check whether saving procedure contains 'FRAMES' (test = 1) or 'LINESCAN' (test = 0)
		IF (*(*info).savparams).snapshot THEN midtension = '' ELSE BEGIN
			nlpos = CEIL(ALOG10((*(*info).dataparams).nlp))
			lp_id = 'lp'+STRING((*(*info).dataparams).lp,FORMAT='(I0'+STRTRIM(nlpos,2)+')')
			midtension = '_'+lp_id
		ENDELSE
		IF ((*(*info).savparams).savpro EQ 'JPEG_FRAMES') THEN extension = 'jpg'
		IF ((*(*info).savparams).savpro EQ 'PNG_FRAMES') THEN extension = 'png'
	ENDIF ELSE BEGIN
		ntpos = CEIL(ALOG10((*(*info).dataparams).nt))
		nlpos = CEIL(ALOG10((*(*info).dataparams).nlp))
		t_id = 't'+STRING((*(*info).dispparams).t,FORMAT='(I0'+STRTRIM(ntpos,2)+')')
		lp_id = 'lp'+STRING((*(*info).dataparams).lp,FORMAT='(I0'+STRTRIM(nlpos,2)+')')
		midtension = '_'+t_id+'_'+lp_id
		IF ((*(*info).savparams).savpro EQ 'JPEG_LINESCAN') THEN extension = 'jpg'
		IF ((*(*info).savparams).savpro EQ 'PNG_LINESCAN') THEN extension = 'png'
	ENDELSE
	CRISPEX_SAVE_CHECK_FILENAME, event, extension, 'CRISPEX_SAVE_OVER', midtension = midtension
END

PRO CRISPEX_SAVE_OVER, event
; Handles the overwriting and activates the subsequent saving of the jpeg frames
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, (*(*info).savparams).filename_text, GET_VALUE = filename
	IF ((*(*info).savparams).savpro EQ 'MPEG') THEN CRISPEX_SAVE_MPEG_SAVE, event, filename ELSE $
		IF (STRPOS((*(*info).savparams).savpro,'FRAMES') NE -1) THEN CRISPEX_SAVE_FRAMES_SAVE, event, filename ELSE CRISPEX_SAVE_LINESCAN_SAVE, event, filename
	IF ((*(*info).winids).saveoptwintlb GT 0) THEN BEGIN
		WIDGET_CONTROL, (*(*info).winids).saveoptwintlb,/DESTROY
		(*(*info).winids).saveoptwintlb = 0
	ENDIF
	WIDGET_CONTROL, event.TOP, /DESTROY
END

PRO CRISPEX_SAVE_FRAMES, event
; Handles the saving of a series of main images (as in display) as JPEG
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	CRISPEX_SAVE_CHECK_PATH_WRITE, event
	label = ['series','snapshot']
	IF (*(*info).savparams).snapshot THEN BEGIN
		ntpos = CEIL(ALOG10((*(*info).dataparams).nt))
		nlpos = CEIL(ALOG10((*(*info).dataparams).nlp))
		t_id = 't'+STRING((*(*info).dispparams).t,FORMAT='(I0'+STRTRIM(ntpos,2)+')')
		lp_id = 'lp'+STRING((*(*info).dataparams).lp,FORMAT='(I0'+STRTRIM(nlpos,2)+')')
		CRISPEX_SAVE_CHECK_PATH_WRITE, event
		CRISPEX_SAVE_DETERMINE_FILENAME, event, outfilename=standardfilename, import_id=lp_id+'_'+t_id
	ENDIF ELSE CRISPEX_SAVE_DETERMINE_FILENAME, event, outfilename=standardfilename
	IF ((*(*info).savparams).savpro EQ 'JPEG_FRAMES') THEN CRISPEX_SAVE_GET_FILENAME, event, 'Save JPEG '+label[KEYWORD_SET(SNAPSHOT)], standardfilename, 'CRISPEX_SAVE_CHECK'
	IF ((*(*info).savparams).savpro EQ 'PNG_FRAMES') THEN CRISPEX_SAVE_GET_FILENAME, event, 'Save PNG '+label[KEYWORD_SET(SNAPSHOT)], standardfilename, 'CRISPEX_SAVE_CHECK'
END

PRO CRISPEX_SAVE_FRAMES_SAVE, event, supplied_filename
; Handles the saving of a series (between temporal boundaries) of main images (as in display) as JPEG
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	ntpos = CEIL(ALOG10((*(*info).dataparams).nt))
	nlpos = CEIL(ALOG10((*(*info).dataparams).nlp))
	t_before = (*(*info).dispparams).t
	IF (*(*info).savparams).snapshot THEN BEGIN
		t_low = (*(*info).dispparams).t		&	t_upp = t_low
	ENDIF ELSE BEGIN
		t_low = (*(*info).dispparams).t_low	&	t_upp = (*(*info).dispparams).t_upp 
		lp_id = 'lp'+STRING((*(*info).dataparams).lp,FORMAT='(I0'+STRTRIM(nlpos,2)+')')
	ENDELSE
	WIDGET_CONTROL, /HOURGLASS
	IF STRCMP((*(*info).savparams).savpro,'MPEG') THEN mpegid = MPEG_OPEN([(*(*info).winsizes).xywinx, (*(*info).winsizes).xywiny], QUALITY = 100, BITRATE = 1E8)
	FOR i = t_low, t_upp DO BEGIN
		(*(*info).dispparams).t = i
		CRISPEX_UPDATE_T, event
		IF (*(*info).savparams).overlays_incl THEN BEGIN
			CRISPEX_DRAW_XY, event, NO_CURSOR=ABS((*(*info).savparams).overlays_curs-1), NO_NUMBER=ABS((*(*info).savparams).overlays_num-1), THICK=(*(*info).savparams).overlays_thick, $
				NO_ENDPOINTS=ABS((*(*info).savparams).overlays_pts-1), SYMSIZE=(*(*info).savparams).overlays_symsize, ASECBAR=(*(*info).savparams).overlays_asecbar
			image=TVRD()
		ENDIF ELSE CRISPEX_DRAW_SCALING, event, image, /MAIN
		TVLCT,r,g,b,/GET
		IF (*(*info).savparams).snapshot THEN midtension = '' ELSE BEGIN
			t_id = 't'+STRING((*(*info).dispparams).t,FORMAT='(I0'+STRTRIM(ntpos,2)+')')
			midtension = '_'+lp_id+'_'+t_id
		ENDELSE
		IF (STRCMP((*(*info).savparams).savpro,'JPEG_FRAMES') OR STRCMP((*(*info).savparams).savpro,'MPEG')) THEN BEGIN
			s = SIZE(image)
			finalimage = BYTARR(3,s[1],s[2])
			finalimage(0,*,*) = r(image)
			finalimage(1,*,*) = g(image)
			finalimage(2,*,*) = b(image)
			IF STRCMP((*(*info).savparams).savpro,'MPEG') THEN BEGIN
				imdisp = REVERSE(finalimage,3)
				MPEG_PUT,mpegid, IMAGE = imdisp, FRAME = i-(*(*info).dispparams).t_low, /COLOR
			ENDIF ELSE BEGIN
				filename = (*(*info).paths).opath+supplied_filename+midtension+'.jpg'
				WRITE_JPEG, filename,finalimage,TRUE=1,QUALITY = 75				
				PRINT, 'Written: '+filename
			ENDELSE
		ENDIF
		IF STRCMP((*(*info).savparams).savpro,'PNG_FRAMES') THEN BEGIN
			filename = (*(*info).paths).opath+supplied_filename+midtension+'.png'
			WRITE_PNG,filename,image,r,g,b
			PRINT, 'Written: '+filename
		ENDIF
	ENDFOR
	IF STRCMP((*(*info).savparams).savpro,'MPEG') THEN BEGIN
		MPEG_SAVE, mpegid, FILENAME = (*(*info).paths).opath+supplied_filename+'.mpg'
		MPEG_CLOSE, mpegid
		PRINT, 'Written: '+(*(*info).paths).opath+supplied_filename+'.mpg'
	ENDIF
	(*(*info).dispparams).t = t_before
	CRISPEX_UPDATE_T, event
	IF (*(*info).savparams).overlays_incl THEN CRISPEX_DRAW_XY, event
	WIDGET_CONTROL, (*(*info).winids).savewintlb, /DESTROY
	(*(*info).winids).savewintlb = 0
END

PRO CRISPEX_SAVE_LINESCAN, event
; Handles the saving of a series of main images (as in display) as JPEG
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	CRISPEX_SAVE_CHECK_PATH_WRITE, event
	CRISPEX_SAVE_DETERMINE_FILENAME, event, outfilename=standardfilename
	IF ((*(*info).savparams).savpro EQ 'JPEG_LINESCAN') THEN CRISPEX_SAVE_GET_FILENAME, event, 'Save JPEG line scan', standardfilename, 'CRISPEX_SAVE_CHECK'
	IF ((*(*info).savparams).savpro EQ 'PNG_LINESCAN') THEN CRISPEX_SAVE_GET_FILENAME, event, 'Save PNG line scan', standardfilename, 'CRISPEX_SAVE_CHECK'
END

PRO CRISPEX_SAVE_LINESCAN_SAVE, event, supplied_filename
; Handles the saving of a series (between temporal boundaries) of main images (as in display) as JPEG
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	nlpos = CEIL(ALOG10((*(*info).dataparams).nlp))
	ntpos = CEIL(ALOG10((*(*info).dataparams).nt))
	lp_before = (*(*info).dataparams).lp
	WIDGET_CONTROL, /HOURGLASS
	t_id = 't'+STRING((*(*info).dispparams).t,FORMAT='(I0'+STRTRIM(ntpos,2)+')')
	FOR i = (*(*info).dispparams).lp_low, (*(*info).dispparams).lp_upp DO BEGIN
		(*(*info).dataparams).lp = i
		CRISPEX_UPDATE_T, event
		IF (*(*info).savparams).overlays_incl THEN BEGIN
			CRISPEX_DRAW_XY, event, NO_CURSOR=ABS((*(*info).savparams).overlays_curs-1), NO_NUMBER=ABS((*(*info).savparams).overlays_num-1), THICK=(*(*info).savparams).overlays_thick, $
				NO_ENDPOINTS=ABS((*(*info).savparams).overlays_pts-1), SYMSIZE=(*(*info).savparams).overlays_symsize, ASECBAR=(*(*info).savparams).overlays_asecbar
			image=TVRD()
		ENDIF ELSE CRISPEX_DRAW_SCALING, event, image, /MAIN
		TVLCT,r,g,b,/GET
		IF (*(*info).savparams).linescan_ls THEN BEGIN
			CRISPEX_UPDATE_LP, event
      CRISPEX_DRAW_SPECTRAL_MAIN, event, /LS_ONLY
			lsimage = TVRD()
		ENDIF
		lp_id = 'lp'+STRING((*(*info).dataparams).lp,FORMAT='(I0'+STRTRIM(nlpos,2)+')')
		IF ((*(*info).savparams).savpro EQ 'JPEG_LINESCAN') THEN BEGIN
			s = SIZE(image)
			finalimage = BYTARR(3,s[1],s[2])
			finalimage(0,*,*) = r(image)
			finalimage(1,*,*) = g(image)
			finalimage(2,*,*) = b(image)
			filename = (*(*info).paths).opath+supplied_filename+'_'+t_id+'_'+lp_id+'.jpg'
			WRITE_JPEG, filename,finalimage,TRUE=1,QUALITY = 75
			PRINT, 'Written: '+filename
			IF (*(*info).savparams).linescan_ls THEN BEGIN
				lsfilename = (*(*info).paths).opath+supplied_filename+'_detspect_'+t_id+'_'+lp_id+'.jpg'
				WRITE_JPEG, lsfilename,lsimage,QUALITY = 75
				PRINT, 'Written: '+lsfilename
			ENDIF
		ENDIF
		IF ((*(*info).savparams).savpro EQ 'PNG_LINESCAN') THEN BEGIN
			filename = (*(*info).paths).opath+supplied_filename+'_'+t_id+'_'+lp_id+'.png'
			WRITE_PNG,filename,image,r,g,b
			PRINT, 'Written: '+filename
			IF (*(*info).savparams).linescan_ls THEN BEGIN
				lsfilename = (*(*info).paths).opath+supplied_filename+'_detspect_'+t_id+'_'+lp_id+'.png'
				WRITE_PNG,lsfilename,lsimage
				PRINT, 'Written: '+lsfilename
			ENDIF
		ENDIF
	ENDFOR
	(*(*info).dataparams).lp = lp_before
	CRISPEX_UPDATE_T, event
	IF (*(*info).savparams).overlays_incl THEN CRISPEX_DRAW_XY, event
	IF (*(*info).savparams).linescan_ls THEN BEGIN
		CRISPEX_UPDATE_LP, event
    CRISPEX_DRAW_SPECTRAL_MAIN, event, /LS_ONLY
	ENDIF
	WIDGET_CONTROL, (*(*info).winids).savewintlb, /DESTROY
	(*(*info).winids).savewintlb = 0
END

PRO CRISPEX_SAVE_MPEG, event
; Handles the saving of a series of main images (as in display) as JPEG
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savparams).savpro = 'MPEG'
	CRISPEX_SAVE_CHECK_PATH_WRITE, event
	CRISPEX_SAVE_DETERMINE_FILENAME, event, outfilename=standardfilename, import_id='lp'+STRTRIM(LONG((*(*info).dataparams).lp),2)
	CRISPEX_SAVE_GET_FILENAME, event, 'Save MPEG movie', standardfilename, 'CRISPEX_SAVE_CHECK'
END

PRO CRISPEX_SAVE_OPTIONS, event
; Handles the extra saving options for save as PNG/JPEG/MPEG
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	base = WIDGET_BASE(TITLE = 'CRISPEX'+(*(*info).sesparams).instance_label+': Saving options', GROUP_LEADER = (*(*info).winids).root, TLB_FRAME_ATTR = 1, /TLB_KILL_REQUEST_EVENTS)
	disp = WIDGET_BASE(base, /COLUMN)
	path_base = WIDGET_BASE(disp, /COLUMN, /FRAME)
	path_label = WIDGET_LABEL(path_base, VALUE = 'Path options', /ALIGN_LEFT)
	curpath_base = WIDGET_BASE(path_base, /ROW)
	curpath_label = WIDGET_LABEL(curpath_base, VALUE = 'Current path:')
	(*(*info).ctrlssav).savopt_path_textlab = WIDGET_LABEL(curpath_base, VALUE = STRTRIM((*(*info).paths).opath,2), /DYNAMIC_RESIZE)
	pathbut_base = WIDGET_BASE(path_base, COLUMN=1,/GRID_LAYOUT,/ALIGN_LEFT)
	change_path_but = WIDGET_BUTTON(pathbut_base, VALUE = 'Change path', EVENT_PRO = 'CRISPEX_SAVE_SET_OPATH')
	overlays_base = WIDGET_BASE(disp, /COLUMN, /FRAME)
	overlays_label = WIDGET_LABEL(overlays_base, VALUE = 'Overlays options', /ALIGN_LEFT)
	overlays_but_base = WIDGET_BASE(overlays_base, /ROW)
	overlays_buts_base = WIDGET_BASE(overlays_but_base, /COLUMN, /NONEXCLUSIVE)
	overlays_incl_but = WIDGET_BUTTON(overlays_buts_base, VALUE = 'Include overlays', EVENT_PRO = 'CRISPEX_SAVE_OPTIONS_OVERLAYS_INCLUDE')
	overlays_subbuts_base = WIDGET_BASE(overlays_but_base, /COLUMN, /NONEXCLUSIVE)
	WIDGET_CONTROL, overlays_incl_but, SET_BUTTON = (*(*info).savparams).overlays_incl
	(*(*info).ctrlssav).overlays_num_but = WIDGET_BUTTON(overlays_subbuts_base, VALUE = 'Number overlays', EVENT_PRO = 'CRISPEX_SAVE_OPTIONS_OVERLAYS_NUMBER', SENSITIVE = (*(*info).savparams).overlays_incl)
	WIDGET_CONTROL, (*(*info).ctrlssav).overlays_num_but, SET_BUTTON = (*(*info).savparams).overlays_num
	(*(*info).ctrlssav).overlays_curs_but = WIDGET_BUTTON(overlays_subbuts_base, VALUE = 'Include cursor', EVENT_PRO = 'CRISPEX_SAVE_OPTIONS_OVERLAYS_CURSOR', SENSITIVE = (*(*info).savparams).overlays_incl)
	WIDGET_CONTROL, (*(*info).ctrlssav).overlays_curs_but, SET_BUTTON = (*(*info).savparams).overlays_curs
	(*(*info).ctrlssav).overlays_pts_but = WIDGET_BUTTON(overlays_subbuts_base, VALUE = 'Include endpoints', EVENT_PRO = 'CRISPEX_SAVE_OPTIONS_OVERLAYS_ENDPOINTS', SENSITIVE = (*(*info).savparams).overlays_incl)
	WIDGET_CONTROL, (*(*info).ctrlssav).overlays_pts_but, SET_BUTTON = (*(*info).savparams).overlays_pts
	(*(*info).ctrlssav).overlays_asecbar_but = WIDGET_BUTTON(overlays_subbuts_base, VALUE = 'Add arcseconds bar', EVENT_PRO = 'CRISPEX_SAVE_OPTIONS_OVERLAYS_ASECBAR', SENSITIVE = (*(*info).savparams).overlays_incl)
	WIDGET_CONTROL, (*(*info).ctrlssav).overlays_asecbar_but, SET_BUTTON = (*(*info).savparams).overlays_asecbar
	overlays_combo_base = WIDGET_BASE(overlays_base, /COLUMN)
	overlays_thick_base = WIDGET_BASE(overlays_combo_base, /ROW)
	(*(*info).ctrlssav).overlays_thick_slider = WIDGET_SLIDER(overlays_thick_base, TITLE = 'Overlay thickness', MIN = 1, MAX = 8, VALUE = (*(*info).savparams).overlays_thick, $
		EVENT_PRO = 'CRISPEX_SAVE_OPTIONS_OVERLAYS_THICK', SENSITIVE = (*(*info).savparams).overlays_incl, /DRAG)
	(*(*info).ctrlssav).overlays_symsize_slider = WIDGET_SLIDER(overlays_thick_base, TITLE = 'Overlay symbol size', MIN = 1, MAX = 8, VALUE = (*(*info).savparams).overlays_symsize, $
		EVENT_PRO = 'CRISPEX_SAVE_OPTIONS_OVERLAYS_SYMSIZE', SENSITIVE = (*(*info).savparams).overlays_incl, /DRAG)
	(*(*info).ctrlssav).overlays_asecbar_slider = WIDGET_SLIDER(overlays_base, TITLE = 'Arcseconds bar length', MIN = 1, MAX = 8, VALUE = (*(*info).savparams).overlays_asecbar_length, $
		EVENT_PRO = 'CRISPEX_SAVE_OPTIONS_OVERLAYS_ASECBAR_LENGTH', SENSITIVE = ((*(*info).savparams).overlays_incl AND (*(*info).savparams).overlays_asecbar), /DRAG)
	linescan_base = WIDGET_BASE(disp,/COLUMN, /FRAME)
	linescan_label = WIDGET_LABEL(linescan_base, VALUE = 'Linescan options', /ALIGN_LEFT)
	linescan_but_base = WIDGET_BASE(linescan_base, /NONEXCLUSIVE)
	linescan_incl_ls_but = WIDGET_BUTTON(linescan_but_base, VALUE = 'Save detailed spectrum', EVENT_PRO = 'CRISPEX_SAVE_OPTIONS_INCLUDE_DETSPECT', $
		SENSITIVE = (((*(*info).dataparams).nlp GT 1) AND (((*(*info).savparams).savpro EQ 'JPEG_LINESCAN') OR ((*(*info).savparams).savpro EQ 'PNG_LINESCAN'))))
	WIDGET_CONTROL, linescan_incl_ls_but, SET_BUTTON = (*(*info).savparams).linescan_ls
	button_base = WIDGET_BASE(disp,COLUMN=1,/GRID_LAYOUT,/ALIGN_CENTER)
	ok_but = WIDGET_BUTTON(button_base, VALUE = 'OK', EVENT_PRO = 'CRISPEX_CLOSE_EVENT_WINDOW')
	WIDGET_CONTROL, base, /REALIZE, TLB_SET_XOFFSET = (*(*info).winsizes).spxoffset, TLB_SET_YOFFSET = 0, /TLB_KILL_REQUEST_EVENTS
	WIDGET_CONTROL, base, SET_UVALUE = info
	XMANAGER, 'CRISPEX', base, /NO_BLOCK
	(*(*info).winids).saveoptwintlb = base
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).winids).saveoptwintlb],labels=['saveoptwintlb']
END

PRO CRISPEX_SAVE_OPTIONS_OVERLAYS_INCLUDE, event
; Handles the extra saving options for save as PNG/JPEG/MPEG
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savparams).overlays_incl = event.SELECT
	WIDGET_CONTROL, (*(*info).ctrlssav).overlays_num_but, SENSITIVE = (*(*info).savparams).overlays_incl
	WIDGET_CONTROL, (*(*info).ctrlssav).overlays_curs_but, SENSITIVE = (*(*info).savparams).overlays_incl
	WIDGET_CONTROL, (*(*info).ctrlssav).overlays_pts_but, SENSITIVE = (*(*info).savparams).overlays_incl
	WIDGET_CONTROL, (*(*info).ctrlssav).overlays_asecbar_but, SENSITIVE = (*(*info).savparams).overlays_incl
	WIDGET_CONTROL, (*(*info).ctrlssav).overlays_thick_slider, SENSITIVE = (*(*info).savparams).overlays_incl
	WIDGET_CONTROL, (*(*info).ctrlssav).overlays_symsize_slider, SENSITIVE = (*(*info).savparams).overlays_incl
	CRISPEX_SAVE_OPTIONS_OVERLAYS_INCLUDE_UPDATE_DISPLAY, event
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).savparams).overlays_incl],labels=['Include overlays']
END

PRO CRISPEX_SAVE_OPTIONS_OVERLAYS_INCLUDE_UPDATE_DISPLAY, event
; Handles the extra saving options for save as PNG/JPEG/MPEG
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (*(*info).savparams).overlays_incl THEN BEGIN
		CRISPEX_DRAW_XY, event, NO_CURSOR=ABS((*(*info).savparams).overlays_curs-1), NO_NUMBER=ABS((*(*info).savparams).overlays_num-1), THICK=(*(*info).savparams).overlays_thick, $
			NO_ENDPOINTS=ABS((*(*info).savparams).overlays_pts-1), SYMSIZE=(*(*info).savparams).overlays_symsize, ASECBAR=(*(*info).savparams).overlays_asecbar
	ENDIF ELSE CRISPEX_DRAW_XY, event
END

PRO CRISPEX_SAVE_OPTIONS_OVERLAYS_NUMBER, event
; Handles the extra saving options for save as PNG/JPEG/MPEG
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savparams).overlays_num = event.SELECT
	CRISPEX_SAVE_OPTIONS_OVERLAYS_INCLUDE_UPDATE_DISPLAY, event
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).savparams).overlays_num],labels=['Number overlays']
END

PRO CRISPEX_SAVE_OPTIONS_OVERLAYS_CURSOR, event
; Handles the extra saving options for save as PNG/JPEG/MPEG
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savparams).overlays_curs = event.SELECT
	CRISPEX_SAVE_OPTIONS_OVERLAYS_INCLUDE_UPDATE_DISPLAY, event
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).savparams).overlays_curs],labels=['Include cursor']
END

PRO CRISPEX_SAVE_OPTIONS_OVERLAYS_THICK, event
; Handles the extra saving options for save as PNG/JPEG/MPEG
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savparams).overlays_thick = event.VALUE
	CRISPEX_SAVE_OPTIONS_OVERLAYS_INCLUDE_UPDATE_DISPLAY, event
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).savparams).overlays_thick],labels=['Overlay thickness']
END

PRO CRISPEX_SAVE_OPTIONS_OVERLAYS_SYMSIZE, event
; Handles the extra saving options for save as PNG/JPEG/MPEG
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savparams).overlays_symsize = event.VALUE
	CRISPEX_SAVE_OPTIONS_OVERLAYS_INCLUDE_UPDATE_DISPLAY, event
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).savparams).overlays_symsize],labels=['Overlay symbol size']
END

PRO CRISPEX_SAVE_OPTIONS_OVERLAYS_ENDPOINTS, event
; Handles the extra saving options for save as PNG/JPEG/MPEG
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savparams).overlays_pts = event.SELECT
	CRISPEX_SAVE_OPTIONS_OVERLAYS_INCLUDE_UPDATE_DISPLAY, event
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).savparams).overlays_pts],labels=['Include endpoints']
END

PRO CRISPEX_SAVE_OPTIONS_OVERLAYS_ASECBAR, event
; Handles the extra saving options for save as PNG/JPEG/MPEG
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savparams).overlays_asecbar = event.SELECT
	WIDGET_CONTROL, (*(*info).ctrlssav).overlays_asecbar_slider, SENSITIVE = (*(*info).savparams).overlays_asecbar
	CRISPEX_SAVE_OPTIONS_OVERLAYS_INCLUDE_UPDATE_DISPLAY, event
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).savparams).overlays_asecbar],labels=['Add arcseconds bar']
END

PRO CRISPEX_SAVE_OPTIONS_OVERLAYS_ASECBAR_LENGTH, event
; Handles the extra saving options for save as PNG/JPEG/MPEG
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savparams).overlays_asecbar_length = event.VALUE
	(*(*info).savparams).overlays_asecbar_pix = $
    (*(*info).savparams).overlays_asecbar_length / $
    FLOAT((*(*info).dataparams).dx) * (*(*info).zooming).factor
	CRISPEX_SAVE_OPTIONS_OVERLAYS_INCLUDE_UPDATE_DISPLAY, event
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).savparams).overlays_asecbar_length, (*(*info).savparams).overlays_asecbar_pix],$
		labels=['Arcseconds bar length','Arcseconds bar length in pixels']
END

PRO CRISPEX_SAVE_OPTIONS_INCLUDE_DETSPECT, event
; Handles the extra saving options for save as PNG/JPEG/MPEG
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).savparams).linescan_ls = event.SELECT
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).savparams).linescan_ls],labels=['Save detailed spectrum']
END

;================================================================================= SLIDER CONTROL PROCEDURES
PRO CRISPEX_SLIDER_NPHI, event
; Handles the change in spectral slit length slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).phiparams).nphi_set = event.VALUE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).phiparams).nphi_set],labels=['Phi-slit length']
  CRISPEX_UPDATE_PHISLIT_COORDS, event
	CRISPEX_UPDATE_PHISLICE, event
END

PRO CRISPEX_SLIDER_PHI_ANGLE, event
; Handles the change in spectral slit angle slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).phiparams).angle = event.VALUE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).phiparams).angle],labels=['Phi-slit angle']
  CRISPEX_UPDATE_PHISLIT_COORDS, event
	CRISPEX_PHISLIT_DIRECTION, event
	CRISPEX_UPDATE_PHISLICE, event
END

PRO CRISPEX_SLIDER_LP, event
; Handles the change in spectral position slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).dataparams).lp = event.VALUE
  WIDGET_CONTROL, (*(*info).ctrlscp).lp_blink_but, $
    SENSITIVE=((*(*info).pbparams).lp_blink NE (*(*info).dataparams).lp)
	CRISPEX_SLIDER_LP_UPDATE, event
END

PRO CRISPEX_SLIDER_LP_DECR, event
; Handles increase of spectral position
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).dataparams).lp -= 1L 
	IF ((*(*info).dataparams).lp LT (*(*info).dispparams).lp_low) THEN $
    (*(*info).dataparams).lp = (*(*info).dispparams).lp_upp
	CRISPEX_SLIDER_LP_UPDATE, event, /OVERRIDE_DIAGNOSTIC
END

PRO CRISPEX_SLIDER_LP_INCR, event
; Handles increase of spectral position
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).dataparams).lp += 1L
	IF ((*(*info).dataparams).lp GT (*(*info).dispparams).lp_upp) THEN $
    (*(*info).dataparams).lp = (*(*info).dispparams).lp_low
	CRISPEX_SLIDER_LP_UPDATE, event, /OVERRIDE_DIAGNOSTIC
END

PRO CRISPEX_SLIDER_LP_REF, event
; Handles change in reference spectral position slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).dataparams).lp_ref = event.VALUE
	CRISPEX_SLIDER_LP_UPDATE, event
END

PRO CRISPEX_SLIDER_LP_REF_DECR, event
; Handles increase of spectral position
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).dataparams).lp_ref -= 1L 
	IF ((*(*info).dataparams).lp_ref LT (*(*info).dispparams).lp_ref_low) THEN $
    (*(*info).dataparams).lp_ref = (*(*info).dispparams).lp_ref_upp
	CRISPEX_SLIDER_LP_UPDATE, event, /OVERRIDE_DIAGNOSTIC
END

PRO CRISPEX_SLIDER_LP_REF_INCR, event
; Handles increase of spectral position
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).dataparams).lp_ref += 1L
	IF ((*(*info).dataparams).lp_ref GT (*(*info).dispparams).lp_ref_upp) THEN $
    (*(*info).dataparams).lp_ref = (*(*info).dispparams).lp_ref_low
	CRISPEX_SLIDER_LP_UPDATE, event, /OVERRIDE_DIAGNOSTIC
END

PRO CRISPEX_SLIDER_LP_REF_LOCK, event, UNLOCK=unlock, NO_DRAW=no_draw
; Handles (un)locking the reference reference to (from) the main spectral position slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  IF KEYWORD_SET(UNLOCK) THEN BEGIN
	  (*(*info).ctrlsswitch).lp_ref_lock = 0
    WIDGET_CONTROL, (*(*info).ctrlscp).lp_ref_but, SET_BUTTON=0
  ENDIF ELSE $
	  (*(*info).ctrlsswitch).lp_ref_lock = event.SELECT
  IF (*(*info).ctrlsswitch).lp_ref_lock THEN $
	  (*(*info).dataparams).lp_ref = (*(*info).dataparams).lp
	WIDGET_CONTROL, (*(*info).ctrlscp).lp_ref_slider, $
    SENSITIVE = ABS((*(*info).ctrlsswitch).lp_ref_lock-1), SET_VALUE = (*(*info).dataparams).lp_ref
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).dataparams).lp, (*(*info).dataparams).lp_ref], labels=['lp','lp_ref']
  IF ~KEYWORD_SET(NO_DRAW) THEN BEGIN
  	CRISPEX_UPDATE_T, event
  	CRISPEX_UPDATE_LP, event
  	CRISPEX_DRAW, event
  ENDIF
END

PRO CRISPEX_SLIDER_LP_UPDATE, event, OVERRIDE_DIAGNOSTIC=override_diagnostic, $
  NO_DRAW=no_draw
; Handles the the update after change in the spectral position slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  ; Determine whether lp falls in not displayed diagnostic window, act accordingly
  lp_diag_all = TOTAL((*(*info).dataparams).lp GE (*(*info).intparams).diag_start)-1
  IF ((*(*info).intparams).disp_diagnostics[lp_diag_all] EQ 0) THEN BEGIN
    ; Determine distance to upper and lower boundaries of closest displayed diagnostics window
    ; 0=dist_low, 1=dist_upp, 2=disp_low_next, 3=disp_upp_next
    dist_low_upp = CRISPEX_SLIDER_LP_DIAG(event, lp_diag_all) 
    IF (((dist_low_upp[0] LT dist_low_upp[1]) AND KEYWORD_SET(OVERRIDE_DIAGNOSTIC)) OR $
        ((dist_low_upp[0] GE dist_low_upp[1]) AND ~KEYWORD_SET(OVERRIDE_DIAGNOSTIC))) THEN BEGIN
      (*(*info).dataparams).lp = (*(*info).intparams).diag_start[dist_low_upp[3]]
      lp_diag_all = dist_low_upp[3]
    ENDIF ELSE BEGIN
      (*(*info).dataparams).lp = (*(*info).intparams).diag_start[dist_low_upp[2]]+$
        (*(*info).intparams).diag_width[dist_low_upp[2]]-1 
      lp_diag_all = dist_low_upp[2]
    ENDELSE
  ENDIF
  (*(*info).intparams).lp_diag_all = lp_diag_all
	IF (*(*info).ctrlsswitch).lp_ref_lock THEN $
    (*(*info).dataparams).lp_ref = (*(*info).dataparams).lp
  ; Determine whether lp_ref falls in not displayed diagnostic window, act accordingly
  lp_ref_diag_all = TOTAL((*(*info).dataparams).lp_ref GE (*(*info).intparams).refdiag_start)-1
  IF ((*(*info).intparams).disp_refdiagnostics[lp_ref_diag_all] EQ 0) THEN BEGIN
    ; Determine distance to upper and lower boundaries of closest displayed diagnostics window
    ; 0=dist_low, 1=dist_upp, 2=disp_low_next, 3=disp_upp_next
    dist_low_upp = CRISPEX_SLIDER_LP_DIAG(event, lp_diag_all, /REFERENCE)
    IF (dist_low_upp[0] GE dist_low_upp[1]) THEN BEGIN
      (*(*info).dataparams).lp_ref = (*(*info).intparams).refdiag_start[dist_low_upp[3]]
      lp_ref_diag_all = dist_low_upp[3]
    ENDIF ELSE BEGIN
      (*(*info).dataparams).lp_ref = (*(*info).intparams).refdiag_start[dist_low_upp[2]]+$
        (*(*info).intparams).refdiag_width[dist_low_upp[2]]-1 
      lp_ref_diag_all = dist_low_upp[2]
    ENDELSE
  ENDIF
  (*(*info).intparams).lp_ref_diag_all = lp_ref_diag_all
  (*(*info).scaling).idx = $
    (((*(*info).scaling).imrefscaling EQ 0) OR ((*(*info).scaling).imrefscaling EQ 2)) * $
    (*(*info).intparams).lp_diag_all + $
    (((*(*info).scaling).imrefscaling GT 0) + ((*(*info).scaling).imrefscaling GT 2)) * $
    (*(*info).intparams).ndiagnostics + $
    ((*(*info).scaling).imrefscaling EQ 1) * (*(*info).intparams).lp_ref_diag_all + $
    ((*(*info).scaling).imrefscaling GT 1) * (*(*info).intparams).nrefdiagnostics 
	WIDGET_CONTROL, (*(*info).ctrlscp).lp_slider, SET_VALUE = (*(*info).dataparams).lp
  WIDGET_CONTROL, (*(*info).ctrlscp).lp_ref_slider, SET_VALUE = (*(*info).dataparams).lp_ref
  IF (((*(*info).intparams).ndiagnostics GT 1) OR $
    ((*(*info).intparams).nrefdiagnostics GT 1)) THEN BEGIN
    CRISPEX_SCALING_SET_BOXBUTTONS, event
    CRISPEX_SCALING_SET_SLIDERS, event
  ENDIF
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).dataparams).lp, (*(*info).dataparams).lp_ref], $
      labels=['lp','lp_ref']
  IF ~KEYWORD_SET(NO_DRAW) THEN BEGIN
  	CRISPEX_UPDATE_T, event
  	CRISPEX_UPDATE_LP, event
  	CRISPEX_DRAW, event
  ENDIF
END

PRO CRISPEX_SLIDER_SPECTBLINK, event
; Handles the change in spectral step (for spectral blink) slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).pbparams).lp_blink = event.VALUE
  lp_blink_diag_all = TOTAL((*(*info).pbparams).lp_blink GE (*(*info).intparams).diag_start)-1
  IF ((*(*info).intparams).disp_diagnostics[lp_blink_diag_all] EQ 0) THEN BEGIN
    ; Determine distance to upper and lower boundaries of closest displayed diagnostics window
    ; 0=dist_low, 1=dist_upp, 2=disp_low_next, 3=disp_upp_next
    dist_low_upp = CRISPEX_SLIDER_LP_DIAG(event, lp_blink_diag_all, /BLINK) 
    IF (dist_low_upp[0] GE dist_low_upp[1]) THEN $
      (*(*info).pbparams).lp_blink = (*(*info).intparams).diag_start[dist_low_upp[3]] $
    ELSE  $
      (*(*info).pbparams).lp_blink = (*(*info).intparams).diag_start[dist_low_upp[2]]+$
        (*(*info).intparams).diag_width[dist_low_upp[2]]-1 
  ENDIF
  WIDGET_CONTROL, (*(*info).ctrlscp).lp_blink_but, $
    SENSITIVE=((*(*info).pbparams).lp_blink NE (*(*info).dataparams).lp)
  WIDGET_CONTROL, (*(*info).ctrlscp).lp_blink_slider, SET_VALUE=(*(*info).pbparams).lp_blink
  (*(*info).dataparams).lp = (*(*info).pbparams).lp_blink
  CRISPEX_SLIDER_LP_UPDATE, event
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).pbparams).lp_blink], labels=['lp_blink']
END

PRO CRISPEX_SLIDER_SPEED, event
; Handles the change in playback speed slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event, /IGNORE_LAST
	(*(*info).pbparams).t_speed = event.VALUE
  WIDGET_CONTROL, (*(*info).ctrlscp).t_speed_slider, SET_VALUE = (*(*info).pbparams).t_speed 
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).pbparams).t_speed], labels=['Playback (blink) speed']
END

PRO CRISPEX_SLIDER_STEP, event
; Handles the change in temporal step slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).pbparams).t_step = event.VALUE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [(*(*info).pbparams).t_step], labels=['t_step']
END

PRO CRISPEX_SLIDER_T, event
; Handles the change in temporal slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).dispparams).t = event.VALUE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).dispparams).t], labels=['t']
	CRISPEX_UPDATE_T, event
	IF ((*(*info).dispparams).phislice_update OR (event.DRAG EQ 0)) THEN $
    CRISPEX_UPDATE_SLICES, event, /NO_DRAW, $
      NO_PHIS=((*(*info).winswitch).showphis EQ 0) $
  ELSE BEGIN		
		IF (*(*info).dataswitch).onecube THEN $
      WIDGET_CONTROL, (*(*info).ctrlscp).slice_button, SENSITIVE = 1, $
        SET_VALUE = 'Update spectral windows' 
	ENDELSE
  IF ((*(*info).dataswitch).spfile EQ 0) THEN CRISPEX_UPDATE_SSP, event
  IF ((*(*info).winswitch).showrefls AND ((*(*info).dataswitch).refspfile EQ 0)) THEN CRISPEX_UPDATE_REFSSP, event
  CRISPEX_DRAW, event, NO_PHIS=event.DRAG
END

PRO CRISPEX_SLIDER_TIME_OFFSET, event
; Handles the change in temporal slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  CASE (*(*info).dispparams).master_time OF
    0:  BEGIN
          (*(*info).dispparams).toffset_main = event.VALUE
          t_old = (*(*(*info).dispparams).tarr_main)[(*(*info).dispparams).t_main]
        END
    1:  BEGIN
          (*(*info).dispparams).toffset_ref = event.VALUE
          t_old = (*(*(*info).dispparams).tarr_ref)[(*(*info).dispparams).t_ref]
        END
  ENDCASE
  CRISPEX_COORDS_TRANSFORM_T, event, NT_OLD=(*(*info).dataparams).nt, $
    T_OLD=t_old
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [event.VALUE], labels=['Raster timing offset']
	CRISPEX_UPDATE_T, event
  IF (*(*info).winswitch).showsp THEN CRISPEX_DISPLAYS_SP_REPLOT_AXES, event
  IF (*(*info).winswitch).showrefsp THEN CRISPEX_DISPLAYS_REFSP_REPLOT_AXES, event
	CRISPEX_DRAW, event
END

PRO CRISPEX_SLIDER_X, event
; Handles the change in main x-position slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).dataparams).x = event.VALUE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).dataparams).x], labels=['x']
  CRISPEX_SLIDER_X_XREF_UPDATE, event, /MAIN
END

PRO CRISPEX_SLIDER_XREF, event
; Handles the change in reference x-position slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).dataparams).xref = event.VALUE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).dataparams).xref], labels=['xref']
  CRISPEX_SLIDER_X_XREF_UPDATE, event, /REFERENCE
END

PRO CRISPEX_SLIDER_X_XREF_UPDATE, event, MAIN=main, REFERENCE=reference
; Handles the updates after a change in main/reference x-position slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  ; If necessary, transform coordinates prior to updating sy
  CRISPEX_COORDS_TRANSFORM_XY, event, $
    MAIN2SJI=(*(*info).dataswitch).sjifile,$ 
    MAIN2REF=(KEYWORD_SET(MAIN) AND (*(*info).dataswitch).reffile),$
    REF2MAIN=KEYWORD_SET(REFERENCE), $
    REF2SJI=(KEYWORD_SET(REFERENCE) AND (*(*info).dataswitch).sjifile)
  ; Adjust path if drawing one
  IF ((*(*info).overlayswitch).loopslit AND $
      ((*(*info).loopparams).np GE 1) OR $
      ((*(*info).loopparams).np_ref GE 1)) THEN BEGIN
    IF ((*(*info).loopparams).np GE 1) THEN $
	  	*(*(*info).loopparams).xp = $
        [(*(*(*info).loopparams).xp)[0:(*(*info).loopparams).np-2],$
                                    (*(*info).dataparams).x]
    IF ((*(*info).winswitch).showref AND $
      (*(*info).loopparams).np_ref GE 1) THEN $
	  	*(*(*info).loopparams).xp_ref = $
        [(*(*(*info).loopparams).xp_ref)[0:(*(*info).loopparams).np_ref-2],$
                                    (*(*info).dataparams).xref]
    IF ((*(*info).winswitch).showsji AND $
      (*(*info).loopparams).np_sji GE 1) THEN $
	  	*(*(*info).loopparams).xp_sji = $
        [(*(*(*info).loopparams).xp_sji)[0:(*(*info).loopparams).np_sji-2],$
                                    (*(*info).dataparams).xsji]
    CRISPEX_LOOP_GET_PATH, event, /ADD_REMOVE
  ENDIF
  ; Set main/reference slider accordingly
  CRISPEX_COORDSLIDERS_SET, 1, 1, event
  ; Update cursor coordinates
	CRISPEX_UPDATE_SX, event
  ; Update slices and redraw 
  IF (*(*info).winswitch).showls THEN CRISPEX_UPDATE_SSP, event
  IF (*(*info).winswitch).showsp THEN CRISPEX_UPDATE_SPSLICE, event
  IF (*(*info).winswitch).showrefls THEN CRISPEX_UPDATE_REFSSP, event
  IF (*(*info).winswitch).showrefsp THEN CRISPEX_UPDATE_REFSPSLICE, event
	IF (*(*info).winswitch).showphis THEN BEGIN
		CRISPEX_PHISLIT_DIRECTION, event
    CRISPEX_UPDATE_PHISLIT_COORDS, event
		CRISPEX_UPDATE_PHISLICE, event
	ENDIF ELSE CRISPEX_DRAW, event
END

PRO CRISPEX_SLIDER_XPOS, event, REFERENCE=reference, SJI=sji
; Handles change in xpos-slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  IF KEYWORD_SET(REFERENCE) THEN BEGIN
    (*(*info).zooming).xrefpos = event.VALUE 
    IF (*(*info).dispswitch).main2ref_no_map THEN BEGIN
      (*(*info).zooming).xpos = (*(*info).zooming).xrefpos
      WIDGET_CONTROL, (*(*info).ctrlscp).xpos_slider, $
        SET_VALUE=(*(*info).zooming).xpos
    ENDIF
  ENDIF ELSE IF KEYWORD_SET(SJI) THEN $
    (*(*info).zooming).xsjipos = event.VALUE $
  ELSE BEGIN
    (*(*info).zooming).xpos = event.VALUE
    IF ((*(*info).winswitch).showref AND $
      (*(*info).dispswitch).main2ref_no_map) THEN BEGIN
      (*(*info).zooming).xrefpos = (*(*info).zooming).xpos
      WIDGET_CONTROL, (*(*info).ctrlsref).xrefpos_slider, $
        SET_VALUE=(*(*info).zooming).xrefpos
    ENDIF
  ENDELSE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).zooming).xpos], labels=['xpos']
	CRISPEX_UPDATE_SX, event
	CRISPEX_UPDATE_T, event
	CRISPEX_DRAW, event
END

PRO CRISPEX_SLIDER_XPOS_REF, event
; Handles change in reference xpos-slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  CRISPEX_SLIDER_XPOS, event, /REFERENCE
END

PRO CRISPEX_SLIDER_XPOS_SJI, event
; Handles change in slit-jaw image xpos-slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  CRISPEX_SLIDER_XPOS, event, /SJI
END

PRO CRISPEX_SLIDER_Y, event
; Handles the change in main y-position slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).dataparams).y = event.VALUE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).dataparams).y], labels=['y']
  CRISPEX_SLIDER_Y_YREF_UPDATE, event, /MAIN
END

PRO CRISPEX_SLIDER_YREF, event
; Handles the change in reference y-position slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	(*(*info).dataparams).yref = event.VALUE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).dataparams).yref], labels=['yref']
  CRISPEX_SLIDER_Y_YREF_UPDATE, event, /REFERENCE
END

PRO CRISPEX_SLIDER_Y_YREF_UPDATE, event, MAIN=main, REFERENCE=reference
; Handles the updates after a change in main/reference y-position slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  ; If necessary, transform coordinates prior to updating sy
  CRISPEX_COORDS_TRANSFORM_XY, event, $
    MAIN2SJI=(*(*info).dataswitch).sjifile,$ 
    MAIN2REF=(KEYWORD_SET(MAIN) AND (*(*info).dataswitch).reffile),$
    REF2MAIN=KEYWORD_SET(REFERENCE), $
    REF2SJI=(KEYWORD_SET(REFERENCE) AND (*(*info).dataswitch).sjifile)
  ; Adjust path if drawing one
  IF ((*(*info).overlayswitch).loopslit AND $
      ((*(*info).loopparams).np GE 1) OR $
      ((*(*info).loopparams).np_ref GE 1)) THEN BEGIN
    IF ((*(*info).loopparams).np GE 1) THEN $
  		*(*(*info).loopparams).yp = $
        [(*(*(*info).loopparams).yp)[0:(*(*info).loopparams).np-2],$
                                    (*(*info).dataparams).y]
    IF ((*(*info).winswitch).showref AND $
      (*(*info).loopparams).np_ref GE 1) THEN $
  		*(*(*info).loopparams).yp_ref = $
        [(*(*(*info).loopparams).yp_ref)[0:(*(*info).loopparams).np_ref-2],$
                                    (*(*info).dataparams).yref]
    IF ((*(*info).winswitch).showsji AND $
      (*(*info).loopparams).np_sji GE 1) THEN $
  		*(*(*info).loopparams).yp_sji = $
        [(*(*(*info).loopparams).yp_sji)[0:(*(*info).loopparams).np_sji-2],$
                                    (*(*info).dataparams).ysji]
    CRISPEX_LOOP_GET_PATH, event, /ADD_REMOVE
  ENDIF
  ; Set main/reference slider accordingly
  CRISPEX_COORDSLIDERS_SET, 1, 1, event
  ; Update cursor coordinates
	CRISPEX_UPDATE_SY, event
  ; Update slices and redraw 
  IF (*(*info).winswitch).showls THEN CRISPEX_UPDATE_SSP, event
  IF (*(*info).winswitch).showsp THEN CRISPEX_UPDATE_SPSLICE, event
  IF (*(*info).winswitch).showrefls THEN CRISPEX_UPDATE_REFSSP, event
  IF (*(*info).winswitch).showrefsp THEN CRISPEX_UPDATE_REFSPSLICE, event
	IF (*(*info).winswitch).showphis THEN BEGIN
		CRISPEX_PHISLIT_DIRECTION, event
    CRISPEX_UPDATE_PHISLIT_COORDS, event
		CRISPEX_UPDATE_PHISLICE, event
	ENDIF ELSE CRISPEX_DRAW, event
END

PRO CRISPEX_SLIDER_YPOS, event, REFERENCE=reference, SJI=sji
; Handles change in y-slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  IF KEYWORD_SET(REFERENCE) THEN BEGIN
    (*(*info).zooming).yrefpos = event.VALUE 
    IF (*(*info).dispswitch).main2ref_no_map THEN BEGIN
      (*(*info).zooming).ypos = (*(*info).zooming).yrefpos
      WIDGET_CONTROL, (*(*info).ctrlscp).ypos_slider, $
        SET_VALUE=(*(*info).zooming).ypos
    ENDIF
  ENDIF ELSE IF KEYWORD_SET(SJI) THEN $
    (*(*info).zooming).ysjipos = event.VALUE $
  ELSE BEGIN
    (*(*info).zooming).ypos = event.VALUE
    IF ((*(*info).winswitch).showref AND $
      (*(*info).dispswitch).main2ref_no_map) THEN BEGIN
      (*(*info).zooming).yrefpos = (*(*info).zooming).ypos
      WIDGET_CONTROL, (*(*info).ctrlsref).yrefpos_slider, $
        SET_VALUE=(*(*info).zooming).yrefpos
    ENDIF
  ENDELSE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).zooming).ypos], labels=['ypos']
	CRISPEX_UPDATE_SY, event
	CRISPEX_UPDATE_T, event
	CRISPEX_DRAW, event
END

PRO CRISPEX_SLIDER_YPOS_REF, event
; Handles change in slit-jaw image ypos-slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  CRISPEX_SLIDER_YPOS, event, /REFERENCE
END

PRO CRISPEX_SLIDER_YPOS_SJI, event
; Handles change in slit-jaw image ypos-slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  CRISPEX_SLIDER_YPOS, event, /SJI
END

;========================= UPDATE SLICES AND PARAMETERS PROCEDURES
PRO CRISPEX_UPDATE_SLICES, event, NO_DRAW=no_draw, NO_PHIS=no_phis, $
  SSP_UPDATE=ssp_update, REFSSP_UPDATE=refssp_update, $
  REFLS_DRAW=refls_draw, NO_FEEDBACK=no_feedback
; Gets the new spectral phi slit scan for update of the spectral phi slit
; slice after change in framenumber
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  IF (~KEYWORD_SET(NO_PHIS) OR KEYWORD_SET(SSP_UPDATE) OR $
    KEYWORD_SET(REFSSP_UPDATE)) THEN BEGIN
    WIDGET_CONTROL,/HOURGLASS
    IF ~KEYWORD_SET(NO_FEEDBACK) THEN BEGIN
      totslices = $
        ((*(*info).winswitch).showrefls AND ((*(*info).dataswitch).refspfile EQ 0))+$
  	    ((*(*info).winswitch).showphis OR $
        ((*(*info).dataswitch).onecube AND (*(*info).winswitch).showls))+$
        (~KEYWORD_SET(NO_PHIS) AND (*(*info).winswitch).showphis) 
      base_txt = 'Updating '+STRLOWCASE((*(*info).paramparams).sp_h[$
        (*(*info).plotswitch).heightset])+' slices... '
      CRISPEX_WINDOW_USER_FEEDBACK, event, 'Updating slices', base_txt+'(may take some time)'
    ENDIF
    IF ((*(*info).winswitch).showrefls AND ((*(*info).dataswitch).refspfile EQ 0)) THEN BEGIN
    	IF ((*(*info).dataparams).refnt GT 1) THEN $
        *(*(*info).data).refsspscan = (*(*(*info).data).refscan)[(*(*info).dispparams).t_ref] 
      IF KEYWORD_SET(REFSSP_UPDATE) THEN BEGIN
        CRISPEX_UPDATE_REFSSP, event
        IF KEYWORD_SET(REFLS_DRAW) THEN CRISPEX_DRAW_SPECTRAL_REF, event, /LS_ONLY
      ENDIF
      IF ~KEYWORD_SET(NO_FEEDBACK) THEN $
        WIDGET_CONTROL, (*(*info).ctrlsfeedb).feedback_text, $
          SET_VALUE=base_txt+'1/'+STRTRIM(totslices,2)+' done            '
    ENDIF
  	IF ((*(*info).winswitch).showphis OR $
        ((*(*info).dataswitch).onecube AND (*(*info).winswitch).showls)) THEN BEGIN
  		IF ((*(*info).dataparams).mainnt GT 1) THEN $
        *(*(*info).data).sspscan = (*(*(*info).data).scan)[(*(*info).dispparams).t_main] $
      ELSE $
        *(*(*info).data).sspscan = (*(*(*info).data).scan)
      IF KEYWORD_SET(SSP_UPDATE) THEN CRISPEX_UPDATE_SSP, event
      IF ~KEYWORD_SET(NO_FEEDBACK) THEN $
        WIDGET_CONTROL, (*(*info).ctrlsfeedb).feedback_text, SET_VALUE=base_txt+$
          STRTRIM(KEYWORD_SET(REFSSP_UPDATE)+1,2)+'/'+STRTRIM(totslices,2)+$
          ' done            '
      IF (~KEYWORD_SET(NO_PHIS) AND (*(*info).winswitch).showphis) THEN BEGIN
    		*(*(*info).data).phiscan = (*(*(*info).data).sspscan)[*,*,$
           ((*(*info).dataparams).s * (*(*info).dataparams).nlp):$
          (((*(*info).dataparams).s+1)*(*(*info).dataparams).nlp-1)] 
        CRISPEX_UPDATE_PHISLICE, event, NO_DRAW=no_draw
        IF ~KEYWORD_SET(NO_FEEDBACK) THEN $
          WIDGET_CONTROL, (*(*info).ctrlsfeedb).feedback_text, SET_VALUE=base_txt+$
            STRTRIM(KEYWORD_SET(REFSSP_UPDATE)+KEYWORD_SET(SSP_UPDATE)+1,2)+$
            '/'+STRTRIM(totslices,2)+' done            '
      ENDIF
  	ENDIF
    WIDGET_CONTROL, (*(*info).ctrlscp).slice_button, SENSITIVE=0
    IF ~KEYWORD_SET(NO_FEEDBACK) THEN $
      CRISPEX_WINDOW_USER_FEEDBACK_CLOSE, event
  ENDIF
END

PRO CRISPEX_UPDATE_SPSLICE, event
; Handles updating spectrum-time diagram
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  IF ((*(*info).dispswitch).xy_out_of_range EQ 0) THEN BEGIN
    t_low = (*(*(*info).dispparams).tsel_main)[(*(*info).dispparams).t_low]
    t_upp = (*(*(*info).dispparams).tsel_main)[(*(*info).dispparams).t_upp]
  	spslice = ((*(*(*info).data).spdata)[ $
      FIX((*(*info).dataparams).y) * (*(*info).dataparams).nx * $
      (*(*info).dataparams).ns + FIX((*(*info).dataparams).x) * $
      (*(*info).dataparams).ns + (*(*info).dataparams).s ])
    ; Warp slice if non-equidistant lp
  	IF (*(*info).dispswitch).warpspslice THEN $                   
      dispslice = WARP_TRI( (*(*info).dispparams).xo,(*(*info).dispparams).yo,$
                            (*(*info).dispparams).xi,(*(*info).dispparams).yi,$
                            spslice) $
    ELSE $
      dispslice = spslice
    dispslice = dispslice[$
      (*(*info).dispparams).lp_low:(*(*info).dispparams).lp_upp,t_low:t_upp]
    FOR d=0,(*(*info).intparams).ndisp_diagnostics-1 DO BEGIN
      IF ((*(*info).intparams).ndiagnostics GT 1) THEN $
        tmp_disp = dispslice[((*(*(*info).intparams).diag_starts)[d]-$
                              (*(*(*info).intparams).diag_starts)[0]):$
                              ((*(*(*info).intparams).diag_starts)[d]-$
                              (*(*(*info).intparams).diag_starts)[0]+$
                              (*(*(*info).intparams).diag_widths)[d]-1),*] $
      ELSE $
        tmp_disp = dispslice
    	IF ((*(*info).dispparams).slices_imscale EQ 0) THEN BEGIN
        minmax = CRISPEX_SCALING_SLICES(tmp_disp, $
          (*(*info).scaling).gamma[(*(*(*info).intparams).wheredispdiag)[d]], $
          (*(*info).scaling).histo_opt_val[$
            (*(*(*info).intparams).wheredispdiag)[d]],$
          (*(*info).scaling).minimum[(*(*(*info).intparams).wheredispdiag)[d]],$
          (*(*info).scaling).maximum[(*(*(*info).intparams).wheredispdiag)[d]])
          (*(*info).scaling).spslice_min[$
            (*(*(*info).intparams).wheredispdiag)[d]] = minmax[0]
          (*(*info).scaling).spslice_max[$
            (*(*(*info).intparams).wheredispdiag)[d]] = minmax[1]
      ENDIF ELSE BEGIN
        IF ((*(*(*info).scaling).imagescale)[0] EQ 0) THEN $
          minmax = [(*(*info).scaling).imagemin, (*(*info).scaling).imagemax] $
        ELSE $
          minmax = [(*(*info).scaling).imagemin_curr, $
                    (*(*info).scaling).imagemax_curr]
      ENDELSE
      tmp_disp = BYTSCL(tmp_disp, MIN=minmax[0], MAX=minmax[1], /NAN)
      IF (d EQ 0) THEN $
        final_disp = tmp_disp $
      ELSE $
        final_disp = [final_disp,tmp_disp]
    ENDFOR
    *(*(*info).data).spslice = final_disp
    *(*(*info).data).spslice_congrid = $
      CONGRID( *(*(*info).data).spslice, (*(*info).dispparams).nlpreb, $
      (*(*info).dispparams).ntreb, INTERP=(*(*info).dispparams).interpspslice,$
      /CENTER)
  ENDIF ELSE $
    *(*(*info).data).spslice_congrid =  $
      CONGRID( *(*(*info).data).emptydopslice, (*(*info).dispparams).nlpreb, $
      (*(*info).dispparams).ntreb, INTERP=(*(*info).dispparams).interpspslice,$
      /CENTER)
END

PRO CRISPEX_UPDATE_REFSPSLICE, event
; Handles updating reference spectrum-time diagram
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  IF ((*(*info).dispswitch).xyref_out_of_range EQ 0) THEN BEGIN
    t_low = (*(*(*info).dispparams).tsel_ref)[(*(*info).dispparams).t_low]
    t_upp = (*(*(*info).dispparams).tsel_ref)[(*(*info).dispparams).t_upp]
  	refspslice = ((*(*(*info).data).refspdata)[ FIX((*(*info).dataparams).yref) * $
                  (*(*info).dataparams).refnx + FIX((*(*info).dataparams).xref) ])
    ; Warp slice if non-equidistant lp
  	IF (*(*info).dispswitch).warprefspslice THEN $                
      dispslice = WARP_TRI( $
        (*(*info).dispparams).xo_ref, (*(*info).dispparams).yo_ref,$
        (*(*info).dispparams).xi_ref,(*(*info).dispparams).yi_ref,$
  		  refspslice) $
  	ELSE $
      dispslice = refspslice
    dispslice = dispslice[$
      (*(*info).dispparams).lp_ref_low:(*(*info).dispparams).lp_ref_upp,$
      t_low:t_upp]
    FOR d=0,(*(*info).intparams).ndisp_refdiagnostics-1 DO BEGIN
      sel_idx = (*(*info).intparams).ndiagnostics+$
                (*(*(*info).intparams).wheredisprefdiag)[d]
      IF ((*(*info).intparams).nrefdiagnostics GT 1) THEN $
        tmp_disp = dispslice[((*(*(*info).intparams).refdiag_starts)[d]-$
                              (*(*(*info).intparams).refdiag_starts)[0]):$
                              ((*(*(*info).intparams).refdiag_starts)[d]-$
                              (*(*(*info).intparams).refdiag_starts)[0]+$
                              (*(*(*info).intparams).refdiag_widths)[d]-1),*] $
      ELSE $
        tmp_disp = dispslice
      IF ((*(*info).dispparams).slices_imscale EQ 0) THEN BEGIN
        refminmax = CRISPEX_SCALING_SLICES(tmp_disp, $
          (*(*info).scaling).gamma[sel_idx], $
          (*(*info).scaling).histo_opt_val[sel_idx], $
          (*(*info).scaling).minimum[sel_idx],$
          (*(*info).scaling).maximum[sel_idx])
          (*(*info).scaling).spslice_min[sel_idx] = refminmax[0]
          (*(*info).scaling).spslice_max[sel_idx] = refminmax[1]
      ENDIF ELSE BEGIN
        IF ((*(*(*info).scaling).imagescale)[1] EQ 0) THEN $
          refminmax = [(*(*info).scaling).refmin, (*(*info).scaling).refmax] $
        ELSE $
          refminmax = $
            [(*(*info).scaling).refmin_curr, (*(*info).scaling).refmax_curr]
      ENDELSE
      tmp_disp = BYTSCL(tmp_disp, MIN=refminmax[0], MAX=refminmax[1], /NAN)
      IF (d EQ 0) THEN $
        final_disp = tmp_disp $
      ELSE $
        final_disp = [final_disp,tmp_disp]
    ENDFOR
    *(*(*info).data).refspslice = final_disp
    *(*(*info).data).refspslice_congrid = $
      CONGRID( *(*(*info).data).refspslice, $
      (*(*info).dispparams).refnlpreb, (*(*info).dispparams).refntreb, $
      INTERP=(*(*info).dispparams).interpspslice, /CENTER)
  ENDIF ELSE $
    *(*(*info).data).refspslice_congrid =  $
      CONGRID( *(*(*info).data).emptydopslice, (*(*info).dispparams).refnlpreb, $
      (*(*info).dispparams).refntreb, INTERP=(*(*info).dispparams).interpspslice,$
      /CENTER)
END

PRO CRISPEX_UPDATE_SSP, event
; Handles updating the detailed spectrum
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  wheres = WHERE((*(*info).stokesparams).select_sp EQ 1, count) 
  IF ((count GT 0) AND ((*(*info).dispswitch).xy_out_of_range EQ 0)) THEN BEGIN
  	FOR i=0,TOTAL((*(*info).stokesparams).select_sp)-1 DO BEGIN
    		IF ((*(*info).dataswitch).spfile EQ 1) THEN BEGIN
          spidx = LONG((*(*info).dataparams).y) * (*(*info).dataparams).nx * $
                      (*(*info).dataparams).ns + $
    				      LONG((*(*info).dataparams).x) * (*(*info).dataparams).ns + $
                      wheres[i]  
    			ssp = ( ( *(*(*info).data).spdata)[spidx] )
        ; If no spectral cube supplied, determine from image cube
    		ENDIF ELSE BEGIN    
    			IF (*(*info).dataswitch).onecube THEN $
  				  ssp = (*(*(*info).data).sspscan)[$
              LONG((*(*info).dataparams).x),LONG((*(*info).dataparams).y),$
              (wheres[i] * (*(*info).dataparams).nlp):$
              ((wheres[i]+1) * (*(*info).dataparams).nlp - 1)]  $
          ELSE $
  				  ssp = (*(*(*info).data).scan)[$
              LONG((*(*info).dataparams).x),LONG((*(*info).dataparams).y),$
              (wheres[i] * (*(*info).dataparams).nlp):$
              ((wheres[i]+1) * (*(*info).dataparams).nlp -1)]
    		ENDELSE
      (*(*info).data).ssp_cur[i] = PTR_NEW(ssp)
    ENDFOR
  ENDIF
END

PRO CRISPEX_UPDATE_REFSSP, event
; Handles updating the reference detailed spectrum
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  IF ((*(*info).dispswitch).xyref_out_of_range EQ 0) THEN BEGIN
    IF ((*(*info).dataswitch).refspfile EQ 1) THEN BEGIN
      sspidx = LONG((*(*info).dataparams).yref) * (*(*info).dataparams).refnx + $
               LONG((*(*info).dataparams).xref)
      refssp = ( ( *(*(*info).data).refspdata)[sspidx] ) 
    ENDIF ELSE $
      refssp = REFORM((*(*(*info).data).refsspscan)[$
                LONG((*(*info).dataparams).xref),LONG((*(*info).dataparams).yref),*])
    *(*(*info).data).refssp_cur = refssp
  ENDIF
END

PRO CRISPEX_UPDATE_PHISLIT_COORDS, event
; Handles the update of the slit coordinates 
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  nw_prev = (*(*info).phiparams).nw_cur
  ; Failsafe necessary because of numerical accuracy
  cosval = COS(!DTOR * (*(*info).phiparams).angle)
  sinval = SIN(!DTOR * (*(*info).phiparams).angle)
  IF (((*(*info).phiparams).angle EQ 0) OR ((*(*info).phiparams).angle EQ 90)) THEN BEGIN
    cosval = ROUND(cosval)
    sinval = ROUND(sinval)
  ENDIF
  x_pts = cosval * (FINDGEN( 2*(*(*info).phiparams).nphi_set/2) - $
              (*(*info).phiparams).nphi_set/2) + LONG((*(*info).dataparams).x)
  y_pts = sinval * (FINDGEN( 2*(*(*info).phiparams).nphi_set/2) - $
              (*(*info).phiparams).nphi_set/2) + LONG((*(*info).dataparams).y)
	w = WHERE((x_pts GE 0) AND (x_pts LE (*(*info).dispparams).x_last) AND $
            (y_pts GE 0) AND (y_pts LE (*(*info).dispparams).y_last), nw)
	(*(*info).phiparams).nw_cur = nw
	*(*(*info).phiparams).x_pts = REBIN(x_pts[w], nw, (*(*info).dataparams).nlp)
	*(*(*info).phiparams).y_pts = REBIN(y_pts[w], nw, (*(*info).dataparams).nlp)
  midphi = WHERE(((*(*(*info).phiparams).x_pts)[*,0] EQ LONG((*(*info).dataparams).x)) AND $
                  ((*(*(*info).phiparams).y_pts)[*,0] EQ LONG((*(*info).dataparams).y)))
	(*(*info).phiparams).sphi = midphi +  ((*(*info).phiparams).nphi - nw)/2
  ; Replot axes only under conditions specified below
  IF (((*(*info).phiparams).nw_cur NE nw_prev) AND $                        ; change in nw_cur 
    (((*(*info).phiparams).nw_cur NE (*(*info).phiparams).nphi_set) OR $  ; while nw_cur lt nphi_set
    (nw_prev NE (*(*info).phiparams).nphi_set))) THEN $                   ; nw_cur becomes nphi_set
      CRISPEX_DISPLAYS_PHIS_REPLOT_AXES, event
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [nw,midphi], labels=['nw','midphi']
END

PRO CRISPEX_UPDATE_PHISLICE, event, NO_DRAW=no_draw
; Handles the actual update of the spectral phi slit slice after change in framenumber
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	lp_pts = REBIN(FINDGEN(1,(*(*info).dataparams).nlp), (*(*info).phiparams).nw_cur, $
    (*(*info).dataparams).nlp)
	tmp = INTERPOLATE( *(*(*info).data).phiscan, *(*(*info).phiparams).x_pts, $
    *(*(*info).phiparams).y_pts, lp_pts) ;$
	phislice = (TRANSPOSE(tmp, [1,0]))[(*(*info).dispparams).lp_low:(*(*info).dispparams).lp_upp,*]
  ; If 2D, then display
  IF ((SIZE(phislice))[0] EQ 2) THEN BEGIN
    ; Warp slice if non-equidistant lp
  	IF (*(*info).dispswitch).warpspslice THEN BEGIN
      dispslice = INTERPOLATE(phislice,$
        (*(*(*info).dispparams).phisxtri)[0:((SIZE(phislice))[1]-1),0:((SIZE(phislice))[2]-1)],$
        (*(*(*info).dispparams).phisytri)[0:((SIZE(phislice))[1]-1),0:((SIZE(phislice))[2]-1)])
    ENDIF ELSE $
      dispslice = phislice
    FOR d=0,(*(*info).intparams).ndisp_diagnostics-1 DO BEGIN
      IF ((*(*info).intparams).ndiagnostics GT 1) THEN $
        tmp_disp = dispslice[((*(*(*info).intparams).diag_starts)[d]-$
                              (*(*(*info).intparams).diag_starts)[0]):$
                              ((*(*(*info).intparams).diag_starts)[d]-$
                              (*(*(*info).intparams).diag_starts)[0]+$
                              (*(*(*info).intparams).diag_widths)[d]-1),*] $
      ELSE $
        tmp_disp = dispslice
    	IF ((*(*info).dispparams).slices_imscale EQ 0) THEN BEGIN
        minmax = CRISPEX_SCALING_SLICES(tmp_disp, $
          (*(*info).scaling).gamma[(*(*(*info).intparams).wheredispdiag)[d]], $
          (*(*info).scaling).histo_opt_val[(*(*(*info).intparams).wheredispdiag)[d]],$
          (*(*info).scaling).minimum[(*(*(*info).intparams).wheredispdiag)[d]],$
          (*(*info).scaling).maximum[(*(*(*info).intparams).wheredispdiag)[d]])
        (*(*info).scaling).phislice_min[(*(*(*info).intparams).wheredispdiag)[d]] = minmax[0]
        (*(*info).scaling).phislice_max[(*(*(*info).intparams).wheredispdiag)[d]] = minmax[1]
      ENDIF
      IF (d EQ 0) THEN $
        final_disp = tmp_disp $
      ELSE $
        final_disp = [final_disp,tmp_disp]
    ENDFOR
    *(*(*info).data).phislice = final_disp
  ENDIF ELSE *(*(*info).data).phislice = phislice
	IF ~KEYWORD_SET(NO_DRAW) THEN CRISPEX_DRAW, event
END

PRO CRISPEX_UPDATE_LP, event, NO_LOOP_GET=no_loop_get
; Handles the update of displayed data after change in spectral position
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (*(*info).overlayswitch).loopslit AND ((*(*info).loopparams).np GT 0) THEN BEGIN
    IF ~KEYWORD_SET(NO_LOOP_GET) THEN CRISPEX_LOOP_GET, event
    IF (*(*info).winswitch).showloop THEN BEGIN
  		IF (*(*info).dispswitch).exts THEN $
        *(*(*info).loopsdata).loopslice = (*(*(*info).loopsdata).loopslab)[*,*,$
          (*(*info).dataparams).lp-(*(*info).dispparams).lp_low] $
      ELSE $
  			*(*(*info).loopsdata).loopslice = (*(*(*info).loopsdata).loopslab)[*,*,$
          (*(*info).dataparams).lp]
      IF ((*(*info).loopparams).nw_lpts NE 1) THEN $
        *(*(*info).loopsdata).loopslice = REFORM(*(*(*info).loopsdata).loopslice)
    ENDIF
		IF (*(*info).winswitch).showrefloop THEN BEGIN
			IF (*(*info).dispswitch).refexts THEN $
        *(*(*info).loopsdata).refloopslice = REFORM((*(*(*info).loopsdata).refloopslab)[*,*,$
          (*(*info).dataparams).lp_ref-(*(*info).dispparams).lp_ref_low]) $
      ELSE $
				*(*(*info).loopsdata).refloopslice = REFORM((*(*(*info).loopsdata).refloopslab)[*,*,$
          (*(*info).dataparams).lp_ref])
      IF ((*(*info).loopparams).nw_lpts_ref NE 1) THEN $
        *(*(*info).loopsdata).refloopslice = REFORM(*(*(*info).loopsdata).refloopslice)
		ENDIF
	ENDIF
	IF (*(*info).winswitch).showrestloop THEN $
    FOR k=0,N_ELEMENTS(*(*(*info).restoreparams).disp_loopnr)-1 DO BEGIN
		IF (SIZE(*(*(*(*info).loopsdata).rest_loopslab[k]),/N_DIMENSIONS) EQ 3) THEN BEGIN
			IF (*(*(*info).restoreparams).disp_imref)[k] THEN $
        *(*(*(*info).loopsdata).rest_loopslice[k]) = $
          (*(*(*(*info).loopsdata).rest_loopslab[k]))[*,*,(*(*info).dataparams).lp_ref-$
				    (*(*info).dispparams).lp_ref_low] $
      ELSE $
        *(*(*(*info).loopsdata).rest_loopslice[k]) = $
          (*(*(*(*info).loopsdata).rest_loopslab[k]))[*,*,(*(*info).dataparams).lp-$
            (*(*info).dispparams).lp_low]
      IF ((SIZE(*(*(*(*info).loopsdata).rest_loopslice[k])))[1] NE 1) THEN $
        *(*(*(*info).loopsdata).rest_loopslice[k]) = $
          REFORM(*(*(*(*info).loopsdata).rest_loopslice[k]))
		ENDIF ELSE BEGIN
			IF (*(*(*info).restoreparams).disp_imref)[k] THEN $
        *(*(*(*info).loopsdata).rest_loopslice[k]) = *(*(*(*info).loopsdata).rest_loopslab[k]) $
      ELSE $
				*(*(*(*info).loopsdata).rest_loopslice[k]) = *(*(*(*info).loopsdata).rest_loopslab[k])
		ENDELSE
	ENDFOR
	IF (*(*info).winswitch).showretrdet THEN BEGIN
    *(*(*info).loopsdata).det_loopslice = REFORM((*(*(*info).loopsdata).det_loopslab)[*,*,$
      (*(*info).dataparams).lp-(*(*info).dispparams).lp_low])
  ENDIF
  CRISPEX_SCALING_APPLY_SELECTED, event
END

PRO CRISPEX_UPDATE_T, event
; Handles the updated of displayed data after change in framenumber
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  ; Update time indices
  IF ((*(*info).dataparams).mainnt GT 1) THEN $
    (*(*info).dispparams).t_main = (*(*(*info).dispparams).tsel_main)[(*(*info).dispparams).t]
  IF ((*(*info).dataparams).refnt GT 1) THEN $
    (*(*info).dispparams).t_ref = (*(*(*info).dispparams).tsel_ref)[(*(*info).dispparams).t]
  IF ((*(*info).dataparams).sjint GT 1) THEN $
    (*(*info).dispparams).t_sji = (*(*(*info).dispparams).tsel_sji)[(*(*info).dispparams).t]
	IF (*(*info).winswitch).showdop THEN BEGIN
		(*(*info).dataparams).lp_dop = 2*(*(*info).dataparams).lc - (*(*info).dataparams).lp
		(*(*info).dispswitch).drawdop = (((*(*info).dataparams).lp_dop GE (*(*info).dispparams).lp_low)$
                                 AND ((*(*info).dataparams).lp_dop LE (*(*info).dispparams).lp_upp)$
                                 AND ((*(*info).dataparams).lp_dop NE (*(*info).dataparams).lc)) 
	ENDIF
  ; Determine main image, in case the cube has a spectral dimension
	IF ((*(*info).dataswitch).spfile EQ 1) OR (*(*info).dataswitch).onecube THEN BEGIN
    basecubeidx = (*(*info).dispparams).t_main * (*(*info).dataparams).nlp * (*(*info).dataparams).ns+ $
			            (*(*info).dataparams).s * (*(*info).dataparams).nlp
		*(*(*info).data).xyslice = (*(*(*info).data).imagedata)[$
      basecubeidx + (*(*info).dataparams).lp]
		IF ((*(*info).winswitch).showdop AND (*(*info).dispswitch).drawdop) THEN $
			temp_xyslice =  (*(*(*info).data).imagedata)[$
        basecubeidx + (*(*info).dataparams).lp_dop]
  ; Determine main image, in case the cube has no spectral dimension
	ENDIF ELSE BEGIN
    basecubeidx = (*(*info).dataparams).s * (*(*info).dataparams).nlp 
		*(*(*info).data).xyslice = (*(*(*info).data).imagedata)[basecubeidx + $
      (*(*info).dataparams).lp]
		IF ((*(*info).winswitch).showdop AND (*(*info).dispswitch).drawdop) THEN $
      temp_xyslice = (*(*(*info).data).imagedata)[basecubeidx + $
      (*(*info).dataparams).lp_dop]
	ENDELSE
  ; Determine Doppler image
	IF ((*(*info).winswitch).showdop AND (*(*info).dispswitch).drawdop) THEN BEGIN
		IF ((*(*info).dataparams).lp_dop GT (*(*info).dataparams).lc) THEN $
      *(*(*info).data).dopslice = temp_xyslice - *(*(*info).data).xyslice $
    ELSE $
      *(*(*info).data).dopslice = *(*(*info).data).xyslice - temp_xyslice 
	ENDIF
  ; Determine reference image
	IF ((*(*info).winswitch).showref OR (*(*info).winswitch).showimref) THEN BEGIN
		IF (((*(*info).dataparams).refnlp GT 1) AND ((*(*info).dataparams).refnt GT 1)) THEN BEGIN
      refidx = (*(*info).dispparams).t_ref * (*(*info).dataparams).refnlp + (*(*info).dataparams).lp_ref
      *(*(*info).data).refslice = (*(*(*info).data).refdata)[refidx]
		ENDIF ELSE BEGIN
			IF ((*(*info).dataparams).refnt EQ 0) THEN $
        *(*(*info).data).refslice = (*(*(*info).data).refdata) $
			ELSE IF ((*(*info).dataparams).refnt EQ 1) THEN BEGIN
				IF ((*(*info).dataparams).refnlp NE 1) THEN $
          *(*(*info).data).refslice = (*(*(*info).data).refdata)[$
            (*(*info).dataparams).lp_ref] $
				ELSE $
          *(*(*info).data).refslice = (*(*(*info).data).refdata)[0]
			ENDIF ELSE IF ((*(*info).dataparams).refnt EQ (*(*info).dataparams).nt) THEN BEGIN
        *(*(*info).data).refslice = (*(*(*info).data).refdata)[$
          (*(*info).dispparams).t_ref]
			ENDIF ELSE $
        *(*(*info).data).refslice = (*(*(*info).data).refdata)[$
          (*(*info).dispparams).t_ref * (*(*info).dataparams).refnlp + (*(*info).dataparams).lp_ref]
		ENDELSE
	ENDIF
  ; Determine mask image
	IF (*(*info).dataswitch).maskfile THEN BEGIN
		IF ((*(*info).dataparams).masknt GT 1) THEN BEGIN
      *(*(*info).data).maskslice = (*(*(*info).data).maskdata)[$
        (*(*info).dispparams).t_main]
		ENDIF ELSE BEGIN
      *(*(*info).data).maskslice = (*(*(*info).data).maskdata)[0]
		ENDELSE
	ENDIF
  ; Determine sji image
	IF (*(*info).dataswitch).sjifile THEN BEGIN
		IF ((*(*info).dataparams).sjint GT 1) THEN $
        sjislice_tmp = ((*(*(*info).data).sjidata)[(*(*info).dispparams).t_sji]) $
    ELSE $
        sjislice_tmp = ((*(*(*info).data).sjidata)[0])
    ; If SJI data is scaled integer, descale and convert to float
    IF (*(*info).dispswitch).sjiscaled THEN $
      sjislice_tmp = CRISPEX_SCALING_DESCALE(sjislice_tmp, (*(*info).dispparams).sjibscale, $
        (*(*info).dispparams).sjibzero)
    *(*(*info).data).sjislice = sjislice_tmp
	ENDIF
END

PRO CRISPEX_UPDATE_SX, event
; Handles the change in xy- and reference image x-position slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  sx = CRISPEX_TRANSFORM_DATA2DEVICE(info, X_IN=(*(*info).dataparams).x, /MAIN)
  sxp = CRISPEX_TRANSFORM_DATA2DEVICE(info, X_IN=*(*(*info).loopparams).xp, $
    /MAIN)
  sxr = CRISPEX_TRANSFORM_DATA2DEVICE(info, X_IN=*(*(*info).loopparams).xr, $
    /MAIN)
	(*(*info).curs).sxlock = sx.x
	(*(*info).curs).sx = sx.x
	*(*(*info).overlayparams).sxp = sxp.x
	*(*(*info).overlayparams).sxr = sxr.x
  IF (*(*info).winswitch).showsji THEN BEGIN
    sxsji = CRISPEX_TRANSFORM_DATA2DEVICE(info, $
      X_IN=(*(*info).dataparams).xsji, /SJI)
  	(*(*info).curs).sxsji = sxsji.x
  	(*(*info).curs).sxsjilock = sxsji.x
  ENDIF
  IF (*(*info).winswitch).showref THEN BEGIN
    sxref = CRISPEX_TRANSFORM_DATA2DEVICE(info, $
      X_IN=(*(*info).dataparams).xref, /REFERENCE)
    sxpref = CRISPEX_TRANSFORM_DATA2DEVICE(info, $
      X_IN=*(*(*info).loopparams).xp_ref, /REFERENCE)
    sxrref = CRISPEX_TRANSFORM_DATA2DEVICE(info, $
      X_IN=*(*(*info).loopparams).xr_ref, /REFERENCE)
  	(*(*info).curs).sxref = sxref.x
    (*(*info).curs).sxreflock = sxref.x
  	*(*(*info).overlayparams).sxp_ref = sxpref.x
  	*(*(*info).overlayparams).sxr_ref = sxrref.x
  ENDIF
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET,event,$
      [(*(*info).dataparams).x,(*(*info).curs).sxlock,(*(*info).curs).sx],$
      labels=['x','sxlock','sx']
END

PRO CRISPEX_UPDATE_SY, event
; Handles the change in xy- and reference image y-position slider
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  sy = CRISPEX_TRANSFORM_DATA2DEVICE(info, Y_IN=(*(*info).dataparams).y, /MAIN)
  syp = CRISPEX_TRANSFORM_DATA2DEVICE(info, Y_IN=*(*(*info).loopparams).yp, $
    /MAIN)
  syr = CRISPEX_TRANSFORM_DATA2DEVICE(info, Y_IN=*(*(*info).loopparams).yr, $
    /MAIN)
	(*(*info).curs).sylock = sy.y
	(*(*info).curs).sy = sy.y
	*(*(*info).overlayparams).syp = syp.y
	*(*(*info).overlayparams).syr = syr.y
  IF (*(*info).winswitch).showsji THEN BEGIN
    sysji = CRISPEX_TRANSFORM_DATA2DEVICE(info, $
      Y_IN=(*(*info).dataparams).ysji, /SJI)
  	(*(*info).curs).sysji = sysji.y
  	(*(*info).curs).sysjilock = sysji.y
  ENDIF
  IF (*(*info).winswitch).showref THEN BEGIN
    syref = CRISPEX_TRANSFORM_DATA2DEVICE(info, $
      Y_IN=(*(*info).dataparams).yref, /REFERENCE)
    sypref = CRISPEX_TRANSFORM_DATA2DEVICE(info, $
      Y_IN=*(*(*info).loopparams).yp_ref, /REFERENCE)
    syrref = CRISPEX_TRANSFORM_DATA2DEVICE(info, $
      Y_IN=*(*(*info).loopparams).yr_ref, /REFERENCE)
  	(*(*info).curs).syref = syref.y
  	(*(*info).curs).syreflock = syref.y
  	*(*(*info).overlayparams).syp_ref = sypref.y
  	*(*(*info).overlayparams).syr_ref = syrref.y
  ENDIF
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET,event,$
      [(*(*info).dataparams).y,(*(*info).curs).sylock,(*(*info).curs).sy],$
      labels=['y','sylock','sy']
END

PRO CRISPEX_UPDATE_USER_FEEDBACK, event, title=title, var=var, minvar=minvar, $
  maxvar=maxvar, feedback_text=feedback_text, destroy_top=destroy_top, $
  close_button=close_button, session=session
; Handles the update of user feedback while saving timeslices
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	IF (N_ELEMENTS(MINVAR) LT 1) THEN minvar = 0
	IF (var EQ minvar) THEN BEGIN
		CRISPEX_WINDOW_USER_FEEDBACK, event, title, feedback_text+'     ', $
      close_button=close_button, session=session
		IF KEYWORD_SET(DESTROY_TOP) THEN BEGIN
			WIDGET_CONTROL, (*(*info).winids).feedbacktlb, SET_UVALUE = info
			WIDGET_CONTROL, event.TOP, /DESTROY
			event.TOP = (*(*info).winids).feedbacktlb
		ENDIF
	ENDIF ELSE BEGIN
		WIDGET_CONTROL,(*(*info).ctrlsfeedb).feedback_text, SET_VALUE = feedback_text
		IF KEYWORD_SET(CLOSE_BUTTON) THEN $
      WIDGET_CONTROL, (*(*info).ctrlsfeedb).close_button, SENSITIVE = 0
	ENDELSE
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [feedback_text], labels=['Feedback text']
END

PRO CRISPEX_UPDATE_STARTUP_FEEDBACK, bgim, xout, yout, feedback_text
	LOADCT,3,/SILENT
	TVSCL,bgim
	LOADCT,0,/SILENT
	FOR i=0,N_ELEMENTS(feedback_text)-1 DO XYOUTS, xout[i], yout[i], feedback_text[i], COLOR=255, $
                                                 /DEVICE, CHARSIZE=1.125
END

PRO CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, msg, OVERWRITEABLE=overwriteable, DONE=done, OPT=opt, $
                                           WIDGET=widget, NEWLINE=newline, FAILED=failed, $
                                           REPEAT_STAGE=repeat_stage, NO_ROUTINE=no_routine, $
                                           WARNING=warning, ERROR=error
  routine = 'CRISPEX SETUP: '
  stages = [KEYWORD_SET(OPT),KEYWORD_SET(WIDGET),KEYWORD_SET(WARNING),KEYWORD_SET(ERROR)]
  stage_set = (WHERE(stages EQ 1))[0]+1
  stage_lab = ['','Setting start-up options ','Setting up widget ','WARNING: ','ERROR: ']
  IF KEYWORD_SET(NO_ROUTINE) THEN routine = STRJOIN(REPLICATE(' ',STRLEN(routine)))
  IF KEYWORD_SET(FAILED) THEN donetext = 'failed.' ELSE donetext = 'done!'
  IF KEYWORD_SET(REPEAT_STAGE) THEN outputtext = routine+stage_lab[stage_set]+msg+'... ' $
    ELSE outputtext = ''
  IF KEYWORD_SET(OVERWRITEABLE) THEN BEGIN
    IF KEYWORD_SET(DONE) THEN BEGIN
	    WRITEU,-1,outputtext+donetext
      PRINT,''
    ENDIF ELSE WRITEU,-1,routine+stage_lab[stage_set]+msg+'... '
  ENDIF ELSE BEGIN
    IF KEYWORD_SET(NEWLINE) THEN PRINT,''
    FOR i=0,N_ELEMENTS(msg)-1 DO BEGIN
      IF (i NE 0) THEN temp_routine = STRJOIN(REPLICATE(' ',STRLEN(routine))) $
        ELSE temp_routine = routine
      PRINT, temp_routine+stage_lab[stage_set]+msg[i]
    ENDFOR
  ENDELSE
END

;================================================================================= VERBOSE PROCEDURES
PRO CRISPEX_VERBOSE_GET, event, variables, labels=labels
; Displays feedback of variables structuredly 
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	nvars = N_ELEMENTS(variables)
	IF ((*(*info).feedbparams).last_routine_count NE 0) THEN PRINT,''
	IF (N_ELEMENTS(labels) EQ nvars) THEN BEGIN
		maxchar = MAX(STRLEN(labels))
		FOR i=0,nvars-1 DO BEGIN
			IF (STRLEN(labels[i]) NE maxchar) THEN whitespace = STRJOIN(REPLICATE(' ',(maxchar-STRLEN(labels[i])))) ELSE whitespace = ''
			PRINT,STRJOIN(REPLICATE('  ',SCOPE_LEVEL()-2))+'> '+labels[i]+whitespace+': '+STRTRIM(variables[i],2)
		ENDFOR
	ENDIF ELSE BEGIN
		FOR i=0,nvars-1 DO HELP, variables[i]
	ENDELSE
END

PRO CRISPEX_VERBOSE_GET_ROUTINE, event, rname, IGNORE_LAST=ignore_last
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	prespace = STRJOIN(REPLICATE('  ',SCOPE_LEVEL()-2))
  rname = (SCOPE_TRACEBACK(/STRUCTURE))[N_ELEMENTS(SCOPE_TRACEBACK(/STRUCTURE))-2].ROUTINE
	IF KEYWORD_SET(IGNORE_LAST) THEN (*(*info).feedbparams).last_routine = ''
	IF ((rname NE (*(*info).feedbparams).last_routine) AND $
    ((*(*info).feedbparams).last_routine_count GT 0)) THEN PRINT,''
	IF (rname EQ (*(*info).feedbparams).last_routine) THEN $
    (*(*info).feedbparams).last_routine_count += 1 $
  ELSE $
    (*(*info).feedbparams).last_routine_count = 0
	IF ((*(*info).feedbparams).last_routine_count GT 0) THEN $
    rcount = ' x '+STRTRIM((*(*info).feedbparams).last_routine_count,2)+'.' $
  ELSE $
    rcount = '.'
	IF (rname NE (*(*info).feedbparams).last_routine) THEN $
    PRINT,prespace+'CRISPEX RUN: Called '+rname+'.' $
  ELSE $
		WRITEU,-1,STRING(FORMAT='(%"\r'+prespace+'CRISPEX RUN: Called ",a'+$
      STRTRIM(STRLEN(rname),2)+',a'+STRTRIM(STRLEN(rcount),2)+')',rname,rcount) 
	(*(*info).feedbparams).last_routine = rname
END

PRO CRISPEX_VERBOSE_SET, event
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL, event.ID, GET_UVALUE = add_verbosity
	tmp_verbosity = (*(*info).feedbparams).verbosity
	IF (add_verbosity EQ -1) THEN (*(*info).feedbparams).verbosity = INTARR(N_ELEMENTS((*(*info).feedbparams).verbosity)) ELSE BEGIN
		tmp_verbosity[add_verbosity] = ABS((tmp_verbosity[add_verbosity] EQ 1) - 1)
		(*(*info).feedbparams).verbosity = tmp_verbosity
	ENDELSE
	CRISPEX_VERBOSE_SET_BUTTONS, event
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [add_verbosity], labels=['Verbosity level']
END

PRO CRISPEX_VERBOSE_SET_BUTTONS, event
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	WIDGET_CONTROL,(*(*(*info).ctrlscp).verbose_set)[0], SET_BUTTON = (TOTAL((*(*info).feedbparams).verbosity) EQ 0)
	WIDGET_CONTROL,(*(*(*info).ctrlscp).verbose_set)[1], SET_BUTTON = ((*(*info).feedbparams).verbosity)[2]
	WIDGET_CONTROL,(*(*(*info).ctrlscp).verbose_set)[2], SET_BUTTON = ((*(*info).feedbparams).verbosity)[3]
	WIDGET_CONTROL,(*(*(*info).ctrlscp).verbose_set)[3], SET_BUTTON = ((*(*info).feedbparams).verbosity)[4]
END

;==================== GENERAL WINDOW PROCEDURES
PRO CRISPEX_WINDOW, xsize, ysize, leader, title, base, wid, xoffset, yoffset, $
                    DRAWID=drawid, DRAWBASE=disp, XSCROLL=xscroll, $
                    YSCROLL=yscroll, SCROLL=scroll, RESIZING=resizing, $
                    RES_HANDLER=res_handler, $
                    NO_TLB_KILL_REQUEST=no_tlb_kill_request, $
                    REFERENCE=reference, SJI=sji
; Sets up the display windows
	IF (N_ELEMENTS(RESIZING) EQ 0) THEN resizing = 0
	IF (N_ELEMENTS(LEADER) EQ 0) THEN $
    base = WIDGET_BASE(TITLE = title, TLB_FRAME_ATTR = 1, $
      TLB_KILL_REQUEST_EVENTS=~KEYWORD_SET(NO_TLB_KILL_REQUEST), $
      TLB_SIZE_EVENTS = resizing) $
  ELSE $
		base = WIDGET_BASE(TITLE = STRTRIM(title), GROUP_LEADER = leader, TLB_FRAME_ATTR = 1, $
      TLB_KILL_REQUEST_EVENTS=~KEYWORD_SET(NO_TLB_KILL_REQUEST), TLB_SIZE_EVENTS = resizing)
	disp = WIDGET_BASE(base, /COLUMN)
  IF KEYWORD_SET(SCROLL) THEN BEGIN
    draw_verslid_base = WIDGET_BASE(disp,/ROW)
    draw_horslid_base = WIDGET_BASE(disp,/ROW)
  ENDIF ELSE draw_verslid_base = disp
	drawid = WIDGET_DRAW(draw_verslid_base, XSIZE = xsize, YSIZE = ysize, RETAIN = 2)
  IF KEYWORD_SET(SCROLL) THEN BEGIN
    IF KEYWORD_SET(REFERENCE) THEN BEGIN
      xscroll_pro = 'CRISPEX_SLIDER_XPOS_REF'
      yscroll_pro = 'CRISPEX_SLIDER_YPOS_REF'
    ENDIF ELSE IF KEYWORD_SET(SJI) THEN BEGIN
      xscroll_pro = 'CRISPEX_SLIDER_XPOS_SJI'
      yscroll_pro = 'CRISPEX_SLIDER_YPOS_SJI'
    ENDIF ELSE BEGIN
      xscroll_pro = 'CRISPEX_SLIDER_XPOS'
      yscroll_pro = 'CRISPEX_SLIDER_YPOS'
    ENDELSE
    yscroll = WIDGET_SLIDER(draw_verslid_base,VALUE=0,MIN=0,MAX=1,/SUPPRESS,/DRAG,$
                            EVENT_PRO=yscroll_pro,/VERTICAL, YSIZE=ysize)
    xscroll = WIDGET_SLIDER(draw_horslid_base,VALUE=0,MIN=0,MAX=1,/SUPPRESS,/DRAG,$
                            EVENT_PRO=xscroll_pro, XSIZE=xsize)
  ENDIF
	WIDGET_CONTROL, base, /REALIZE, TLB_SET_XOFFSET=xoffset, TLB_SET_YOFFSET=yoffset
	IF (N_ELEMENTS(RES_HANDLER) GT 0) THEN $
    XMANAGER, 'CRISPEX', base, EVENT_HANDLER = res_handler, /NO_BLOCK $
  ELSE $
    XMANAGER, 'CRISPEX', base, /NO_BLOCK
	WIDGET_CONTROL, drawid, GET_VALUE = wid
END

PRO CRISPEX_WINDOW_OK, event, title, message1, OK_EVENT=ok_event, CANCEL_EVENT=cancel_event, $
  CANCEL_LABEL=cancel_label, BASE=base, BLOCK=block, NO_SHOW_EVENT=no_show_event, $
  NO_SHOW_CHOICES=no_show_choices, SET_CHOICE_IDX=set_choice_idx
; Sets up the message windows with only an OK-button
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	fulltitle = 'CRISPEX'+(*(*info).sesparams).instance_label+': '+STRTRIM(title,2)
	base = WIDGET_BASE(TITLE = fulltitle, GROUP_LEADER = (*(*info).winids).root, TLB_FRAME_ATTR = 1, $
    /TLB_KILL_REQUEST_EVENTS)
	disp = WIDGET_BASE(base, /COLUMN)
	message_base = WIDGET_BASE(disp, /COLUMN)
  final_msg = CRISPEX_SPLIT_MSG(message1, 50) ; Set maximum width in characters to 50
  FOR j=0,N_ELEMENTS(final_msg)-1 DO $
	  text_label = WIDGET_LABEL(message_base, VALUE = final_msg[j])
  IF (N_ELEMENTS(NO_SHOW_EVENT) EQ 1) THEN BEGIN
    divider = CRISPEX_WIDGET_DIVIDER(disp)
    choice_base = WIDGET_BASE(disp, /ALIGN_CENTER)
    choices = WIDGET_COMBOBOX(choice_base, VALUE=NO_SHOW_CHOICES, EVENT_PRO=NO_SHOW_EVENT)
    IF (N_ELEMENTS(SET_CHOICE_IDX) EQ 1) THEN $
      WIDGET_CONTROL, choices, SET_COMBOBOX_SELECT=set_choice_idx
  ENDIF
	IF (N_ELEMENTS(CANCEL_EVENT) GT 0) THEN BEGIN
		IF (N_ELEMENTS(CANCEL_LABEL) NE 1) THEN cancel_label = 'Cancel'
		button_base = WIDGET_BASE(disp,COLUMN=2,/GRID_LAYOUT,/ALIGN_CENTER) 
		cancel_but = WIDGET_BUTTON(button_base, VALUE = cancel_label, EVENT_PRO = cancel_event)
	ENDIF ELSE button_base = WIDGET_BASE(disp,/ROW,/ALIGN_CENTER)
	ok_but = WIDGET_BUTTON(button_base, VALUE = '   OK   ' , EVENT_PRO = ok_event)
	WIDGET_CONTROL, base, /REALIZE, TLB_SET_XOFFSET = 500, TLB_SET_YOFFSET = 500
	WIDGET_CONTROL, base, SET_UVALUE = info
	IF (N_ELEMENTS(BLOCK) NE 1) THEN block = 0
	XMANAGER, 'CRISPEX', base, NO_BLOCK=ABS(block-1)
END

PRO CRISPEX_WINDOW_USER_FEEDBACK, event, title, initial_feedback, close_button=close_button, session=session
; Sets up the message windows for user feedback 
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	fulltitle = 'CRISPEX'+(*(*info).sesparams).instance_label+': '+STRTRIM(title,2)
	base = WIDGET_BASE(TITLE = fulltitle, GROUP_LEADER = (*(*info).winids).root, TLB_FRAME_ATTR = 1, /TLB_KILL_REQUEST_EVENTS)
	disp = WIDGET_BASE(base, /COLUMN)
	message_base = WIDGET_BASE(disp, /COLUMN)
	(*(*info).ctrlsfeedb).feedback_text = WIDGET_LABEL(message_base, VALUE = initial_feedback, /ALIGN_LEFT, /DYNAMIC_RESIZE)
	IF KEYWORD_SET(close_button) THEN BEGIN
		button_base = WIDGET_BASE(disp,/ROW,/ALIGN_CENTER)
		(*(*info).ctrlsfeedb).close_button = WIDGET_BUTTON(button_base, VALUE = 'Close', EVENT_PRO = 'CRISPEX_WINDOW_USER_FEEDBACK_CLOSE', SENSITIVE = 0)
	ENDIF ELSE empty_text = WIDGET_LABEL(message_base, VALUE = ' ')
	WIDGET_CONTROL, base, /REALIZE, TLB_SET_XOFFSET = 500, TLB_SET_YOFFSET = 500
	WIDGET_CONTROL, base, SET_UVALUE = info
	XMANAGER, 'CRISPEX', base, /NO_BLOCK
	IF KEYWORD_SET(SESSION) THEN (*(*info).winids).restsesfeedbtlb = base ELSE (*(*info).winids).feedbacktlb = base
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [base], labels=['feedbacktlb']
END

PRO CRISPEX_WINDOW_USER_FEEDBACK_CLOSE, event, session=session
; Handles the closure of the user feedback window
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
	IF KEYWORD_SET(SESSION) THEN BEGIN
		tlb = (*(*info).winids).restsesfeedbtlb 
		WIDGET_CONTROL, (*(*info).winids).restsesfeedbtlb, /DESTROY
		(*(*info).winids).restsesfeedbtlb = 0
	ENDIF ELSE BEGIN
		tlb = (*(*info).winids).feedbacktlb
		WIDGET_CONTROL, (*(*info).winids).feedbacktlb, /DESTROY
		(*(*info).winids).feedbacktlb = 0
	ENDELSE
	(*(*info).ctrlsfeedb).feedback_text = 0
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN CRISPEX_VERBOSE_GET, event, [tlb], labels=['feedbacktlb was']
END

PRO CRISPEX_WINDOWS_GET_OFFSETS, event
; Handles the determination current window offsets
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	IF ((*(*info).winids).sptlb NE 0) THEN BEGIN
    geometry = WIDGET_INFO((*(*info).winids).sptlb, /GEOMETRY)
    (*(*info).winsizes).spxoffset = geometry.xoffset
    (*(*info).winsizes).spyoffset = geometry.yoffset
  ENDIF
	IF ((*(*info).winids).lstlb NE 0) THEN BEGIN
    geometry = WIDGET_INFO((*(*info).winids).lstlb, /GEOMETRY)
    (*(*info).winsizes).lsxoffset = geometry.xoffset
    (*(*info).winsizes).lsyoffset = geometry.yoffset
  ENDIF
	IF ((*(*info).winids).doptlb NE 0) THEN BEGIN
    geometry = WIDGET_INFO((*(*info).winids).doptlb, /GEOMETRY)
    (*(*info).winsizes).dopxoffset = geometry.xoffset
    (*(*info).winsizes).dopyoffset = geometry.yoffset
  ENDIF
	IF ((*(*info).winids).imreftlb NE 0) THEN BEGIN
    geometry = WIDGET_INFO((*(*info).winids).imreftlb, /GEOMETRY)
    (*(*info).winsizes).imrefxoffset = geometry.xoffset
    (*(*info).winsizes).imrefyoffset = geometry.yoffset
  ENDIF
	IF ((*(*info).winids).reftlb NE 0) THEN BEGIN
    geometry = WIDGET_INFO((*(*info).winids).reftlb, /GEOMETRY)
    (*(*info).winsizes).refxoffset = geometry.xoffset
    (*(*info).winsizes).refyoffset = geometry.yoffset
  ENDIF
	IF ((*(*info).winids).refsptlb NE 0) THEN BEGIN
    geometry = WIDGET_INFO((*(*info).winids).refsptlb, /GEOMETRY)
    (*(*info).winsizes).refspxoffset = geometry.xoffset
    (*(*info).winsizes).refspyoffset = geometry.yoffset
  ENDIF
	IF ((*(*info).winids).reflstlb NE 0) THEN BEGIN
    geometry = WIDGET_INFO((*(*info).winids).reflstlb, /GEOMETRY)
    (*(*info).winsizes).reflsxoffset = geometry.xoffset
    (*(*info).winsizes).reflsyoffset = geometry.yoffset
  ENDIF
	IF ((*(*info).winids).sjitlb NE 0) THEN BEGIN
    geometry = WIDGET_INFO((*(*info).winids).sjitlb, /GEOMETRY)
    (*(*info).winsizes).sjixoffset = geometry.xoffset
    (*(*info).winsizes).sjiyoffset = geometry.yoffset
  ENDIF
	IF ((*(*info).winids).phistlb NE 0) THEN BEGIN
    geometry = WIDGET_INFO((*(*info).winids).phistlb, /GEOMETRY)
    (*(*info).winsizes).phisxoffset = geometry.xoffset
    (*(*info).winsizes).phisyoffset = geometry.yoffset
  ENDIF
	IF ((*(*info).winids).inttlb NE 0) THEN BEGIN
    geometry = WIDGET_INFO((*(*info).winids).inttlb, /GEOMETRY)
    (*(*info).winsizes).intxoffset = geometry.xoffset
    (*(*info).winsizes).intyoffset = geometry.yoffset
  ENDIF
	IF ((*(*info).winids).looptlb NE 0) THEN BEGIN
    geometry = WIDGET_INFO((*(*info).winids).looptlb, /GEOMETRY)
    (*(*info).winsizes).loopxoffset = geometry.xoffset
    (*(*info).winsizes).loopyoffset = geometry.yoffset
  ENDIF
END

;==================== ZOOM PROCEDURES
PRO CRISPEX_ZOOM, event, NO_DRAW=no_draw
; Handles the zoom event
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
	CRISPEX_UPDATE_SX, event
	CRISPEX_UPDATE_SY, event
;	IF (*(*info).overlayswitch).loopslit THEN CRISPEX_ZOOM_LOOP, event
;	IF ((*(*info).meas).np GE 1) THEN CRISPEX_ZOOM_MEAS, event
	xposconstr 	= ((*(*info).dataparams).nx-1) - (*(*info).dataparams).d_nx
	yposconstr	= ((*(*info).dataparams).ny-1) - (*(*info).dataparams).d_ny
	WIDGET_CONTROL, (*(*info).ctrlscp).xpos_slider, SET_SLIDER_MIN = 0, $
    SET_SLIDER_MAX = xposconstr,SET_VALUE = (*(*info).zooming).xpos 
	WIDGET_CONTROL, (*(*info).ctrlscp).ypos_slider, SET_SLIDER_MIN = 0, $
    SET_SLIDER_MAX = yposconstr,SET_VALUE = (*(*info).zooming).ypos 
  IF ((*(*info).winids).reftlb NE 0) THEN BEGIN
  	xrefposconstr = ((*(*info).dataparams).refnx-1) - (*(*info).dataparams).d_refnx
  	yrefposconstr	= ((*(*info).dataparams).refny-1) - (*(*info).dataparams).d_refny
  	WIDGET_CONTROL, (*(*info).ctrlsref).xrefpos_slider, SET_SLIDER_MIN=0, $
      SET_SLIDER_MAX=xrefposconstr,SET_VALUE=(*(*info).zooming).xrefpos 
  	WIDGET_CONTROL, (*(*info).ctrlsref).yrefpos_slider, SET_SLIDER_MIN=0, $
      SET_SLIDER_MAX=yrefposconstr,SET_VALUE=(*(*info).zooming).yrefpos 
  ENDIF
  IF ((*(*info).winids).sjitlb NE 0) THEN BEGIN
  	xsjiposconstr = ((*(*info).dataparams).sjinx-1) - (*(*info).dataparams).d_sjinx
  	ysjiposconstr	= ((*(*info).dataparams).sjiny-1) - (*(*info).dataparams).d_sjiny
  	WIDGET_CONTROL, (*(*info).ctrlssji).xsjipos_slider, SET_SLIDER_MIN=0, $
      SET_SLIDER_MAX=xsjiposconstr,SET_VALUE=(*(*info).zooming).xsjipos 
  	WIDGET_CONTROL, (*(*info).ctrlssji).ysjipos_slider, SET_SLIDER_MIN=0, $
      SET_SLIDER_MAX=ysjiposconstr,SET_VALUE=(*(*info).zooming).ysjipos 
  ENDIF
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, [(*(*info).zooming).factor,xposconstr,yposconstr], $
                         labels=['Zoomfactor','Maximum xpos','Maximum ypos']
	CRISPEX_UPDATE_T, event
	IF ~KEYWORD_SET(NO_DRAW) THEN CRISPEX_DRAW, event
END

PRO CRISPEX_ZOOM_UPDATE_SLIDERS, event, cursor_x=cursor_x, cursor_y=cursor_y, $
  SENSITIVE=sensitive
; Handles the update of xpos and ypos sliders when changing zoomfactor
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  IF (N_ELEMENTS(SENSITIVE) EQ 1) THEN $
    sensitive = REPLICATE(sensitive,2)  $
  ELSE IF (N_ELEMENTS(SENSITIVE) LT 1) THEN $
    sensitive = [1,1]
	(*(*info).dataparams).d_nx = $
    ((*(*info).dataparams).nx / (*(*info).zooming).factor) < $
    ((*(*info).dataparams).nx-1)
	(*(*info).dataparams).d_ny = $
    ((*(*info).dataparams).ny / (*(*info).zooming).factor) < $
    ((*(*info).dataparams).ny-1)
	(*(*info).phiparams).d_nphi_set = $
    (*(*info).phiparams).nphi_set / (*(*info).zooming).factor
	(*(*info).zooming).xpos = (cursor_x - (*(*info).dataparams).d_nx / 2.) > 0
	(*(*info).zooming).ypos = (cursor_y - (*(*info).dataparams).d_ny / 2.) > 0
	IF (((*(*info).zooming).xpos+(*(*info).dataparams).d_nx) GE $
       (*(*info).dataparams).nx) THEN $
    (*(*info).zooming).xpos = $
      (((*(*info).dataparams).nx-1) - (*(*info).dataparams).d_nx) > 0
	IF (((*(*info).zooming).ypos+(*(*info).dataparams).d_ny) GE $
       (*(*info).dataparams).ny) THEN $
    (*(*info).zooming).ypos = $
      (((*(*info).dataparams).ny-1) - (*(*info).dataparams).d_ny) > 0
	(*(*info).zooming).xpos = LONG((*(*info).zooming).xpos)
	(*(*info).zooming).ypos = LONG((*(*info).zooming).ypos)
  ; Set main/reference x/ypos sliders
	WIDGET_CONTROL, (*(*info).ctrlscp).xpos_slider, SENSITIVE=sensitive[0], $
    SET_VALUE=(*(*info).zooming).xpos
	WIDGET_CONTROL, (*(*info).ctrlscp).ypos_slider, SENSITIVE=sensitive[1], $
    SET_VALUE=(*(*info).zooming).ypos
  ; Set reference variables and x/ypos sliders
  IF ((*(*info).winids).reftlb NE 0) THEN BEGIN
  	(*(*info).dataparams).d_refnx = $
      ((*(*info).dataparams).refnx / (*(*info).zooming).factor) < $
        ((*(*info).dataparams).refnx-1)
  	(*(*info).dataparams).d_refny = $
      ((*(*info).dataparams).refny / (*(*info).zooming).factor) < $
        ((*(*info).dataparams).refny-1)
  	(*(*info).zooming).xrefpos = ((*(*info).dataparams).xref - $
      (*(*info).dataparams).d_refnx / 2.) > 0
  	(*(*info).zooming).yrefpos = ((*(*info).dataparams).yref - $
      (*(*info).dataparams).d_refny / 2.) > 0
  	IF (((*(*info).zooming).xrefpos+(*(*info).dataparams).d_refnx) GE $
      (*(*info).dataparams).refnx) THEN $
      (*(*info).zooming).xrefpos = $
        (((*(*info).dataparams).refnx-1) - (*(*info).dataparams).d_refnx) > 0
  	IF (((*(*info).zooming).yrefpos+(*(*info).dataparams).d_refny) GE $
      (*(*info).dataparams).refny) THEN $
      (*(*info).zooming).yrefpos = (((*(*info).dataparams).refny-1) - $
        (*(*info).dataparams).d_refny) > 0
  	(*(*info).zooming).xrefpos = LONG((*(*info).zooming).xrefpos)
  	(*(*info).zooming).yrefpos = LONG((*(*info).zooming).yrefpos)
  	WIDGET_CONTROL, (*(*info).ctrlsref).xrefpos_slider, SENSITIVE=sensitive[0],$
      SET_VALUE=(*(*info).zooming).xrefpos
  	WIDGET_CONTROL, (*(*info).ctrlsref).yrefpos_slider, SENSITIVE=sensitive[1],$
      SET_VALUE=(*(*info).zooming).yrefpos
    ; Get imrefblink boundaries
    result = CRISPEX_GET_IMREF_BLINK_BOUNDS((*(*info).dataparams).pix_main2ref,$
      (*(*info).dataparams).pix_ref2main, (*(*info).zooming).xpos, $
      (*(*info).zooming).xpos+(*(*info).dataparams).d_nx, $
      (*(*info).zooming).ypos, $
      (*(*info).zooming).ypos+(*(*info).dataparams).d_ny, $
      (*(*info).zooming).xrefpos, $
      (*(*info).zooming).xrefpos+(*(*info).dataparams).d_refnx, $
      (*(*info).zooming).yrefpos, $
      (*(*info).zooming).yrefpos+(*(*info).dataparams).d_refny)
    (*(*info).dispparams).x_main = result.x_main-(*(*info).zooming).xpos
    (*(*info).dispparams).y_main = result.y_main-(*(*info).zooming).ypos
    (*(*info).dispparams).x_ref = result.x_ref-(*(*info).zooming).xrefpos
    (*(*info).dispparams).y_ref = result.y_ref-(*(*info).zooming).yrefpos
  ENDIF
  ; Set SJI variables and x/ypos sliders
  IF ((*(*info).winids).sjitlb NE 0) THEN BEGIN
  	(*(*info).dataparams).d_sjinx = $
      ((*(*info).dataparams).sjinx / (*(*info).zooming).factor) < $
        ((*(*info).dataparams).sjinx-1)
  	(*(*info).dataparams).d_sjiny = $
      ((*(*info).dataparams).sjiny / (*(*info).zooming).factor) < $
        ((*(*info).dataparams).sjiny-1)
  	(*(*info).zooming).xsjipos = ((*(*info).dataparams).xsji - $
      (*(*info).dataparams).d_sjinx / 2.) > 0
  	(*(*info).zooming).ysjipos = ((*(*info).dataparams).ysji - $
      (*(*info).dataparams).d_sjiny / 2.) > 0
  	IF (((*(*info).zooming).xsjipos+(*(*info).dataparams).d_sjinx) GE $
      (*(*info).dataparams).sjinx) THEN $
      (*(*info).zooming).xsjipos = $
        (((*(*info).dataparams).sjinx-1) - (*(*info).dataparams).d_sjinx) > 0
  	IF (((*(*info).zooming).ysjipos+(*(*info).dataparams).d_sjiny) GE $
      (*(*info).dataparams).sjiny) THEN $
      (*(*info).zooming).ysjipos = (((*(*info).dataparams).sjiny-1) - $
        (*(*info).dataparams).d_sjiny) > 0
  	(*(*info).zooming).xsjipos = LONG((*(*info).zooming).xsjipos)
  	(*(*info).zooming).ysjipos = LONG((*(*info).zooming).ysjipos)
  	WIDGET_CONTROL, (*(*info).ctrlssji).xsjipos_slider, SENSITIVE=sensitive[0],$
      SET_VALUE=(*(*info).zooming).xsjipos
  	WIDGET_CONTROL, (*(*info).ctrlssji).ysjipos_slider, SENSITIVE=sensitive[1],$
      SET_VALUE=(*(*info).zooming).ysjipos
  ENDIF
	IF (((*(*info).feedbparams).verbosity)[3] EQ 1) THEN $
    CRISPEX_VERBOSE_GET, event, $
      [(*(*info).zooming).xpos, (*(*info).zooming).ypos, $
      (*(*info).dataparams).d_nx, (*(*info).dataparams).d_ny], $
      labels=['xpos','ypos','d_nx','d_ny']
END

PRO CRISPEX_ZOOMFAC_DECR, event
; Decreases the zoomfactor and calls CRISPEX_BGROUP_ZOOMFAC_SET
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  old_factor_idx = WHERE((*(*info).zooming).factorswitch EQ 1)
  set_factor_idx = ( old_factor_idx - 1 ) > 0
  IF (set_factor_idx NE old_factor_idx) THEN $
    set_zoomfac = CRISPEX_BGROUP_ZOOMFAC_SET(event, SET_FACTOR_IDX=set_factor_idx, $
                                      UNSET_FACTOR_IDX=old_factor_idx)
END

PRO CRISPEX_ZOOMFAC_INCR, event
; Increases the zoomfactor and calls CRISPEX_BGROUP_ZOOMFAC_SET
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN CRISPEX_VERBOSE_GET_ROUTINE, event
  old_factor_idx = WHERE((*(*info).zooming).factorswitch EQ 1)
  set_factor_idx = ( old_factor_idx + 1 ) < (N_ELEMENTS((*(*info).zooming).factorswitch)-1)
  IF (set_factor_idx NE old_factor_idx) THEN $
    set_zoomfac = CRISPEX_BGROUP_ZOOMFAC_SET(event, SET_FACTOR_IDX=set_factor_idx, $
                                      UNSET_FACTOR_IDX=old_factor_idx)
END

PRO CRISPEX_ZOOM_MEAS, event, REFERENCE=reference, SJI=sji
; Handles the change in measurement position after a zoom event
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  result = CRISPEX_TRANSFORM_DATA2DEVICE(info, $
    X=*(*(*info).meas).xp, Y=*(*(*info).meas).yp, /MAIN)
  *(*(*info).meas).sxp = result.x
  *(*(*info).meas).syp = result.y
  IF KEYWORD_SET(REFERENCE) THEN BEGIN
    result = CRISPEX_TRANSFORM_DATA2DEVICE(info, $
      X=*(*(*info).meas).xp_ref, Y=*(*(*info).meas).yp_ref, /REF)
    *(*(*info).meas).sxp_ref = result.x
    *(*(*info).meas).syp_ref = result.y
  ENDIF 
  IF KEYWORD_SET(SJI) THEN BEGIN
    result = CRISPEX_TRANSFORM_DATA2DEVICE(info, $
      X=*(*(*info).meas).xp_sji, Y=*(*(*info).meas).yp_sji, /SJI)
    *(*(*info).meas).sxp_sji = result.x
    *(*(*info).meas).syp_sji = result.y
  ENDIF
END	

PRO CRISPEX_ZOOM_LOOP, event, REFERENCE=reference, SJI=sji
; Handles the change in loop positions after a zoom event
	WIDGET_CONTROL, event.TOP, GET_UVALUE = info
	IF (TOTAL(((*(*info).feedbparams).verbosity)[2:3]) GE 1) THEN $
    CRISPEX_VERBOSE_GET_ROUTINE, event
  result = CRISPEX_TRANSFORM_DATA2DEVICE(info, $
    X=*(*(*info).loopparams).xrdisp, Y=*(*(*info).loopparams).yrdisp, /MAIN)
  *(*(*info).overlayparams).sxr = result.x
  *(*(*info).overlayparams).syr = result.y
  IF KEYWORD_SET(REFERENCE) THEN BEGIN
    result = CRISPEX_TRANSFORM_DATA2DEVICE(info, $
      X=*(*(*info).loopparams).xrdisp_ref, Y=*(*(*info).loopparams).yrdisp_ref, /REF)
    *(*(*info).overlayparams).sxr_ref = result.x
    *(*(*info).overlayparams).syr_ref = result.y
  ENDIF
  IF KEYWORD_SET(SJI) THEN BEGIN
    result = CRISPEX_TRANSFORM_DATA2DEVICE(info, $
      X=*(*(*info).loopparams).xrdisp_sji, Y=*(*(*info).loopparams).yrdisp_sji, /SJI)
    *(*(*info).overlayparams).sxr_sji = result.x
    *(*(*info).overlayparams).syr_sji = result.y
  ENDIF
END

;===============================================================================
;================================== MAIN PROGRAM CODE ==========================
;===============================================================================
PRO CRISPEX, imcube, spcube, $                ; filename of main im & sp cube
              REFCUBE=refcube, $              ; filename(s) of reference image (& spectral) cube(s)
              SJICUBE=sjicube, $              ; filename of slit-jaw image cube
              MASKCUBE=maskcube, $            ; filename of mask cube
              SPECTFILE=spectfile, $          ; filename(s) of spectral save file(s)
              LINE_CENTER=line_center, $		  ; line centre and/or wavelength information
	            DT=dt, $                        ; time step in seconds
              EXTS=exts, $                    ; exact timeslices keyword
              MNSPEC=mnspec, $                ; mean spectrum over selected scans
              SINGLE_CUBE=single_cube, $      ; single full cube call
              SCALE_STOKES=scale_stokes, $    ; scale Stokes spectra internally
              NO_WARP=no_warp, $              ; don't warp nonequidistant spectral slices
              SCALE_CUBES=scale_cubes, $      ; scale cubes
              XTITLE=xtitle, YTITLE=ytitle,$; custom detailed spectrum xtitle and ytitle
              WINDOW_LARGE=window_large, $    ; draw large windows for small cubes
              VERBOSE=verbose                 ; program verbosity

;========================= PROGRAM VERBOSITY CHECK
	IF (N_ELEMENTS(VERBOSE) NE 1) THEN BEGIN			
		IF (N_ELEMENTS(VERBOSE) GT 1) THEN $
      MESSAGE,'ERROR: The VERBOSE keyword may only be set to a single integer number. Reverting '+$
              'to default verbosity level 0.'
		verbose = 0
		verbosity = [0,0,0,0,0]
	ENDIF ELSE BEGIN
		verbose >= 0	&	verbose <= 26
	ENDELSE
	verbosity = CRISPEX_TRANSFORM_DEC2BIN(verbose)   ; Convert verbosity value to binary array
  IF verbosity[1] THEN setup_starttime = SYSTIME(/SECONDS)

;========================= CRISPEX DIRECTORY TREE CHECK
	file_crispex    = (ROUTINE_INFO('CRISPEX',/SOURCE)).PATH      ; Path to compiled CRISPEX
	dir_crispex     = FILE_DIRNAME(file_crispex,/MARK_DIRECTORY)
	dir_aux         = dir_crispex+'aux'+PATH_SEP()                ; Path to auxiliary routines
	dir_resources   = dir_crispex+'resources'+PATH_SEP()          ; Path to resources container
	dir_buttons     = dir_resources+'buttons'+PATH_SEP()          ; Path to button images
  dir_settings    = CRISPEX_CONFIG_DIR()+PATH_SEP()             ; Path to settings container
	dir_settings_write  = FILE_TEST(dir_settings, /WRITE)                 ; Check for cpft dir writeability
	IF (verbosity[1] EQ 1) THEN $
    CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK,'CRISPEX has been compiled from: '+file_crispex

;========================= VERSION AND REVISION NUMBER
  ; Version 1.6.3 (rev 571) == version 1.6.3.0
	base_version_number = '1.6.3'
  
  ; Get revision number from CVS $Id
  id_string='; $Id: crispex.pro,v 1.156 2014/11/20 16:18:01 gregal Exp $'
  split_id_string = STRSPLIT(id_string[0],' ',/EXTRACT)
  cvs_idn = split_id_string[3]
  cvs_rev = (STRSPLIT(cvs_idn,'.',/EXTRACT))[1]
  cvs_msg = STRJOIN(split_id_string[3:6],' ')
  ; Assumption: CVS committed revision number will always be 1.x, with x increasing linearly
  revnr = 634+FIX(cvs_rev)-64             ; rev_nr=634, cvs_rev=64 when implemented
 
  ; Change rev_nr and cvs_rev below whenever changing base_versions_number!
  subvnr = 652 + (FIX(cvs_rev)-82) - 571  ; rev_nr=652, cvs_rev=82 when implemented
  
  ; Convert revision and version numbers to strings
  revision_number = STRTRIM(revnr,2)   
  version_number = base_version_number +'.'+ STRTRIM(subvnr,2)
  vnr_msg = version_number+' (r'+revision_number+'; '+cvs_msg+')'
	IF (verbosity[1] EQ 1) THEN $
    CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK,'Version and revision number: '+vnr_msg

;========================= PROGRAM-INFO ON CALL W/O PARAMS
	IF N_PARAMS() LT 1 THEN BEGIN
    MESSAGE,'Version '+vnr_msg, /INFO
		MESSAGE,'Syntax: CRISPEX, Imcube, Spcube, REFCUBE=refcube, '+$
            'SJICUBE=sjicube, MASKCUBE=maskcube, SPECTFILE=spectfile, '+$
            'LINE_CENTER=line_center, DT=dt, EXTS=exts, MNSPEC=mnspec, '+$
            'SINGLE_CUBE=single_cube, SCALE_STOKES=scale_stokes, NO_WARP=no_warp, '+$
            'SCALE_CUBES=scale_cubes, XTITLE=xtitle, YTITLE=ytitle, '+$
            'WINDOW_LARGE=window_large, VERBOSE=verbose', /INFO
		RETURN
	ENDIF

;========================= LOAD PREFERENCES
  ; Define default preferences
	default_startupwin = 1      &  default_interpspslice = 1  ; Show startup win, interpolate slices
	default_autoplay = 0        &  default_defsaveid = 0      ; 0 = yyyymmdd, 1 = ddmmyyyy
	default_defipath = 0        &  default_defopath = 0			  ; 0 = local working directory, 1 = saved directory
	default_bgplotcol = 255     &  default_plotcol = 0
	default_phislice_update = 0 &  default_slices_imscale = 0
  default_histo_opt_val = 0.0001  & default_gamma_val = 1.0
  default_warnings = 2  ; 0=no startup warnings, 1=warnings on cmd line, 2=warnings in pop-up
	cpreffiles = FILE_SEARCH(dir_settings+'crispex.cpref', COUNT = cpreffilecount)
	IF (cpreffilecount GE 1) THEN BEGIN     ; If preference file is present, load preference file
		RESTORE, cpreffiles[0] 
		IF (verbosity[1] EQ 1) THEN $
      CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'Preferences restored from: '+dir_settings+'crispex.cpref'
		resave_preferences = ((N_ELEMENTS(phislice_update) NE 1) OR (N_ELEMENTS(slices_imscale) NE 1))
    ; Failsafe inheritances from older CRISPEX versions
    ; Automatic phislice update
		IF (N_ELEMENTS(phislice_update) NE 1) THEN phislice_update = default_phislice_update
    ; Scale slices with image scaling
		IF (N_ELEMENTS(slices_imscale) NE 1) THEN slices_imscale = default_slices_imscale
    ; HISTO_OPT value
		IF (N_ELEMENTS(histo_opt_val) NE 1) THEN histo_opt_val = default_histo_opt_val
    ; Gamma value
		IF (N_ELEMENTS(gamma_val) NE 1) THEN gamma_val = default_gamma_val
    ; Warnings
		IF (N_ELEMENTS(warnings) NE 1) THEN warnings = default_warnings
    ; Window offsets
		IF (N_ELEMENTS(window_offsets) NE 1) THEN window_offsets = {set:0}
	ENDIF ELSE BEGIN                        ; If no preference file is present, set defaults
		startupwin = default_startupwin           &  interpspslice = default_interpspslice
		autoplay = default_autoplay               &  defsaveid = default_defsaveid
		defipath = default_defipath               &  defopath = default_defopath
		bgplotcol = default_bgplotcol             &  plotcol = default_plotcol
		phislice_update = default_phislice_update &  slices_imscale = default_slices_imscale
    histo_opt_val = default_histo_opt_val     &  gamma_val = default_gamma_val
    warnings = default_warnings
		resave_preferences = 0
		window_offsets = {set:0}
	ENDELSE

;------------------------- SETTINGS FOR PERFORMANCE SAVE FILE
	hostname = GETENV('HOSTNAME')
  IF (STRLEN(STRCOMPRESS(hostname)) NE 0) THEN hostname += '.'
	cpftfile = FILE_SEARCH(dir_settings+'crispex.'+hostname+'cpft', COUNT = cpftfilecount)
	IF cpftfilecount THEN BEGIN   ; If cpft file is present, restore
		RESTORE, cpftfile[0] 
		IF (verbosity[1] EQ 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'Restored '+cpftfile[0]+'.'
	ENDIF ELSE BEGIN              ; If not, then initialise variables
		IF (verbosity[1] EQ 1) THEN BEGIN
			CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, ['No CRISPEX performance test file (crispex.'+hostname+$
                                             'cpft) found to restore in ',dir_settings]
		ENDIF
		estimate_lx = 0             ; Size variable for time estimate
		estimate_run = 0            ; Run counter for time estimate
		estimate_time = 0.          ; Updated time estimate per unit run and unit slice size
	ENDELSE 

;------------------------- SETTINGS FOR INSTANCES SAVE FILE
	instfilename = 'crispex.'+hostname+'inst'
	IF dir_settings_write THEN BEGIN    ; If instances directory is writeable, start procedures
		instfile = FILE_SEARCH(dir_settings+instfilename, COUNT = instfilecount)
		IF instfilecount THEN BEGIN   ; If inst file is present for current hostname, add current
			IF (verbosity[1] EQ 1) THEN $
        CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'Opening existing instance tracking file: '+$
                                               instfilename+'.'
			nlines = FILE_LINES(instfile)
			datarr = STRARR(1,nlines)
			OPENR,unit1,instfile,/GET_LUN
			READF,unit1,datarr
			FREE_LUN,unit1
			routine_name = STRARR(nlines)
			instance_id = LONARR(nlines)
			FOR i=1,nlines[0]-1 DO BEGIN
				splitline = STRSPLIT(datarr[i],'	',/EXTRACT)
				routine_name[i] = splitline[0]
				instance_id[i] = splitline[3]
			ENDFOR
			where_crispex = WHERE(routine_name EQ 'CRISPEX', count)
			OPENU, unit2, dir_settings+instfilename, WIDTH = 360, /GET_LUN, /APPEND
		ENDIF ELSE BEGIN              ; If no inst file present for current hostname, make one
			IF (verbosity[1] EQ 1) THEN BEGIN
				CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'No CRISPEX instance tracking file ('+instfilename+$
                                               ') found in '+dir_settings+'. Creating file.'
			ENDIF
			count = 0
			OPENW, unit2, dir_settings+instfilename, WIDTH = 360, /GET_LUN
			PRINTF, unit2, '# routine_name	version		revision	ID'
		ENDELSE
		IF (count GT 0) THEN $
      set_instance_id = STRTRIM((instance_id[where_crispex])[WHERE(instance_id[where_crispex] EQ $
                        MAX(instance_id[where_crispex], /NAN))] + 1,2) $
    ELSE $
      set_instance_id = STRTRIM(0,2)
		PRINTF, unit2, 'CRISPEX	'+version_number+'	'+revision_number+'	'+set_instance_id
		FREE_LUN, unit2
		IF (set_instance_id GE 1) THEN instance_label = '-'+set_instance_id ELSE instance_label = ''
		IF (verbosity[1] EQ 1) THEN $
      CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'Written instance ID ('+set_instance_id+') to '+$
                                             instfilename+'.'
	ENDIF ELSE BEGIN
		set_instance_id = ''
		instance_label = ''
		instfilecount = 0
		IF (verbosity[1] EQ 1) THEN BEGIN
 			CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'ERROR: Could not write CRISPEX instance tracking '+$
                                             'file '+instfilename+'to '+dir_settings+'. Permission denied.'
		ENDIF
	ENDELSE
	
;------------------------- INPUT/OUTPUT PATH SETTINGS
	CD, CURRENT=curpath
	default_prefipath = STRTRIM(curpath+PATH_SEP(),2)
	default_prefopath = default_prefipath
	IF (defipath EQ 0) THEN BEGIN
		prefipath = default_prefipath
		ipath = default_prefipath
	ENDIF ELSE ipath = prefipath
	IF (defopath EQ 0) THEN BEGIN
		prefopath = default_prefopath
		opath = default_prefopath
	ENDIF ELSE opath = prefopath
	opath_write = FILE_TEST(opath, /WRITE)
  IF verbosity[1] THEN BEGIN
    CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'Input path set to: '+STRTRIM(ipath,2), /NEWLINE, $
                                           /NO_ROUTINE
    CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'Output path set to: '+STRTRIM(opath,2), /NO_ROUTINE
  ENDIF

;========================= START-UP WINDOW AND SCREEN PARAMETERS
	screeninfo  = OBJ_NEW('IDLsysMonitorInfo')
	nmonitors    = screeninfo -> GetNumberOfMonitors()
	screensizes = screeninfo -> GetRectangles()
	IF (nmonitors GT 1) THEN BEGIN   ; Define monitor order if multiple monitors attached
		monitor_order       = (INDGEN(nmonitors))[SORT(screensizes[0,0:1])]
		monitor_xsize_order = (INDGEN(nmonitors))[SORT(screensizes[2,0:1])]
		monitor_ysize_order = (INDGEN(nmonitors))[SORT(screensizes[3,0:1])]
	ENDIF ELSE BEGIN                ; Default monitor order if only one monitor attached
		monitor_order       = 0
		monitor_ysize_order = 0
	ENDELSE
	x_screen_mid  = screensizes[2,monitor_order[0]]/2.    ; x-coordinate of central screen pixel
	y_screen_mid  = screensizes[3,monitor_order[0]]/2.    ; y-coordinate of central screen pixel
	startup_im    = REBIN(REFORM(TOTAL((CRISPEX_READ_BMP_BUTTONS('crispex_startup.bmp',$
                  dir_resources))[*,*,1:2],3)),400,300)
	startup_nx    = (SIZE(startup_im))[1]                 ; x-size of statup window image
	startup_ny    = (SIZE(startup_im))[2]                 ; y-size of statup window image
	startup_xpos  = FIX(x_screen_mid-startup_nx/2.)       ; x-position of startup window
	startup_ypos  = FIX(y_screen_mid-startup_ny/2.)       ; y-position of startup window
	xout          = REPLICATE(24,9)
	yout          = REPLICATE(FIX(startup_ny/2.5)+10,9)-INDGEN(9)*15
	IF startupwin THEN BEGIN  ; If startup window is to be shown, launch window
		CRISPEX_WINDOW, startup_nx, startup_ny, 0, 'CRISPEX', startuptlb, startupwid, startup_xpos, $
                    startup_ypos, DRAWID = startupdrawid, DRAWBASE = drawbase, $
                    /NO_TLB_KILL_REQUEST
		CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, 'Initializing... '
	ENDIF

;========================= READ-IN AND INITIALISATION OF FILES
  ; N.B.: After CRISPEX v1.6.3 FITS cubes have become the standard. Old read-in procedures 
  ; are retained in compatibility for older cubes. Differentiation is performed based on filename
  ; extension, where FITS cubes are assumed to have a *.fits extension (case insensitive).
  IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, 'Reading input files... '
  IF ((BYTE(1L,0,1))[0] EQ 1) THEN endian = 'l' ELSE endian = 'b' ; Check endianness of machine
  dt_keyword_set = (N_ELEMENTS(DT) EQ 1) 
  IF (dt_keyword_set EQ 0) THEN dt = 0.
  
  ; Handle input file headers by parsing them into the hdr structure; first initialise hdr
  hdr = {$
            ; Data types
            imtype:0, sptype:0, refimtype:0, refsptype:0, sjitype:0, $
            masktype:0, $
            ; Data offsets within file
            imoffset:0L, spoffset:0L, refimoffset:0L, refspoffset:0L, $
            sjioffset:0L, maskoffset:0L, $
            ; Endians, OBSID and DATE_OBS
            imendian:'b', spendian:'b', refimendian:'b', refspendian:'b', $
            sjiendian:'b', maskendian:'b',endian:endian, obsid:'0', $
            date_obs_main:'0', date_obs_ref:'0', date_obs_sji:'0', $
            ; Compatibility switches
            imcube_compatibility:0B, spcube_compatibility:0B, $
            refimcube_compatibility:0B, refspcube_compatibility:0B, $
            maskcube_compatibility:0B, multichannel:0B, $
            ; Data dimensions
            nx:0L, ny:0L, nlp:1L, mainnt:1L, ns:1L, imnt:0L, spnt:0L, imns:0L, $
            spns:0L, $ 
            refnx:0L, refny:0L, refnlp:0L, refnt:0L, refns:0L, refimnt:0L, $
            refspnt:0L, refspnx:0L, refspny:0L, sjinx:0L, sjiny:0L, sjint:1L, $
            masknx:0L, maskny:0L, masknt:0L, $
            ; Spatial reference values
            xpix:0L, ypix:0L, xval:0., yval:0., xpix_ref:0L, ypix_ref:0L, $
            xval_ref:0., yval_ref:0., xpix_sji:0L, ypix_sji:0L, $
            xval_sji:0., yval_sji:0., sjix0:0L, sjiy0:0L, $
            main2ref_no_map:1, wcs_set:0, ref_wcs_set:0, sji_wcs_set:0, $
            ; Pixel sizes
            dx:1., dy:1., dt:dt, dx_fixed:0B, refdx:1., refdy:1., $
            sjidx:1., sjidy:1., $
            ; Data scaling variables
            sjibscale:0., sjibzero:0., sjiscaled:0B, $
            ; Axes labels and units
            xunit:'arcsec', yunit:'arcsec', tunit:'', lpunit:'', sunit:'', $
            bunit:'counts', xlabel:'x', ylabel:'y', tlabel:'Frame number', $
            lplabel:'Spectral position', slabel:'', blabel:'Intensity', $
            refxunit:'arcsec', refyunit:'arcsec', reflpunit:'', $
            refbunit:'counts', refxlabel:'x', refylabel:'y', reftlabel:'', $
            reflplabel:'', refblabel:'Intensity', sjibunit:'counts', $
            xtitle:STRARR(2), ytitle:STRARR(2), refspxtitle:'', spxtitle:'', $
            spytitle:'', $
            ; Stokes and diagnostics parameters
            imstokes:'', spstokes:'', imdiagnostics:'', $
            stokes_enabled:[0,0,0,0], scalestokes_max:0, ndiagnostics:1, $
            nrefdiagnostics:1, $
            ; File units
            lunim:0, lunsp:0, lunrefim:0, lunrefsp:0, lunsji:0, lunmask:0, $
            ; File names
            imfilename:'', spfilename:'', refimfilename:'', refspfilename:'', $
            sjifilename:'', maskfilename:'', $
            ; File switches
            spfile:0, onecube:0, single_cube:[0,0], showref:0, refspfile:0, $
            sjifile:0, maskfile:0, $ 
            ; Data pointers
            imdata:PTR_NEW(0), scan:PTR_NEW(0), spdata:PTR_NEW(0), $
            spectra:PTR_NEW(0), refdata:PTR_NEW(0), refslice:PTR_NEW(0), $
            refspdata:PTR_NEW(0), refscan:PTR_NEW(0), refsspscan:PTR_NEW(0), $
            sjidata:PTR_NEW(0), sjislice:PTR_NEW(0), maskdata:PTR_NEW(0), $
            ; Miscellaneous
            ipath:ipath, opath:opath, instance_label:instance_label, $
            verbosity:verbosity $
            }

  CRISPEX_IO_OPEN_MAINCUBE, IMCUBE=imcube, SPCUBE=spcube, HDR_IN=hdr, HDR_OUT=hdr, $
                            SINGLE_CUBE=single_cube, STARTUPTLB=startuptlb, $
                            IO_FAILSAFE_MAIN_ERROR=io_failsafe_main_error
  IF (io_failsafe_main_error EQ 1) THEN BEGIN
    CRISPEX_CLOSE_FREE_LUN, hdr.lunim, hdr.lunsp, hdr.lunrefim, hdr.lunrefsp, $
      hdr.lunmask, hdr.lunsji, IMDISP=(hdr.lunim NE 0), SPDISP=(hdr.lunsp NE 0), $
      REFIMDISP=(hdr.lunrefim NE 0), REFSPDISP=(hdr.lunrefsp NE 0), $
      MASKDISP=(hdr.lunmask NE 0), SJIDISP=(hdr.lunsji NE 0)
    IF (hdr.lunsp NE 0) THEN FREE_LUN, hdr.lunsp
    WIDGET_CONTROL, startuptlb, /DESTROY
    RETURN
  ENDIF

  CRISPEX_IO_OPEN_REFCUBE, REFCUBE=refcube, HDR_IN=hdr, HDR_OUT=hdr, $
                            SINGLE_CUBE=single_cube, $
                            CUBE_COMPATIBILITY=refcube_compatibility, $
                            IO_FAILSAFE_REF_ERROR=io_failsafe_ref_error, $
                            IO_FAILSAFE_MAIN_REF_ERROR=io_failsafe_main_ref_error
  IF ((io_failsafe_ref_error EQ 1) OR (io_failsafe_main_ref_error EQ 1)) THEN BEGIN
    CRISPEX_CLOSE_FREE_LUN, hdr.lunim, hdr.lunsp, hdr.lunrefim, hdr.lunrefsp, $
      hdr.lunmask, hdr.lunsji, IMDISP=(hdr.lunim NE 0), SPDISP=(hdr.lunsp NE 0), $
      REFIMDISP=(hdr.lunrefim NE 0), REFSPDISP=(hdr.lunrefsp NE 0), $
      MASKDISP=(hdr.lunmask NE 0), SJIDISP=(hdr.lunsji NE 0)
    WIDGET_CONTROL, startuptlb, /DESTROY
    RETURN
  ENDIF
  IF (N_ELEMENTS(REFCUBE) LT 1) THEN $
    hdr = CREATE_STRUCT(hdr, 'refdiagnostics', 'N/A', 'refdiag_start', 0, $
            'refdiag_width', 1, 'tarr_ref', 0, 'tarr_raster_ref', 0, $
            'toffset_ref', 0, 'hdrs_ref', PTR_NEW(''), 'wcs_ref', 0, $
            'utc_ref', '0', 'utc_raster_ref', 0)

  CRISPEX_IO_OPEN_SJICUBE, SJICUBE=sjicube, HDR_IN=hdr, HDR_OUT=hdr, $  
                            STARTUPTLB=startuptlb, $
                            IO_FAILSAFE_SJI_ERROR=io_failsafe_sji_error
  IF (io_failsafe_sji_error EQ 1) THEN BEGIN
    CRISPEX_CLOSE_FREE_LUN, hdr.lunim, hdr.lunsp, hdr.lunrefim, hdr.lunrefsp, $
      hdr.lunmask, hdr.lunsji, IMDISP=(hdr.lunim NE 0), SPDISP=(hdr.lunsp NE 0), $
      REFIMDISP=(hdr.lunrefim NE 0), REFSPDISP=(hdr.lunrefsp NE 0), $
      MASKDISP=(hdr.lunmask NE 0), SJIDISP=(hdr.lunsji NE 0)
    WIDGET_CONTROL, startuptlb, /DESTROY
    RETURN
  ENDIF
  IF (N_ELEMENTS(sjicube) NE 1) THEN $
    hdr = CREATE_STRUCT(hdr, 'tarr_sji', 0, 'tsel_sji', 0, $
            'hdrs_sji', PTR_NEW(''), 'wcs_sji', 0, 'utc_sji', '0')

  ; If WCS information is present, use that to get conversion maps
  ; Set defaults first
  pix_main2ref = 0.
  pix_ref2main = 0.
  pix_main2sji = 0.
  pix_sji2main = 0. 
  pix_ref2sji = 0.
  pix_sji2ref = 0. 
  ; Compute values depending on availability of files
  IF hdr.showref THEN BEGIN
    IF (hdr.wcs_set AND hdr.ref_wcs_set) THEN BEGIN
      pix_main2ref = ROUND(WCS_GET_PIXEL(hdr.wcs_ref, WCS_GET_COORD(hdr.wcs_main)))
      pix_ref2main = ROUND(WCS_GET_PIXEL(hdr.wcs_main, WCS_GET_COORD(hdr.wcs_ref)))
    ENDIF ELSE BEGIN
      result = CRISPEX_TRANSFORM_GET_COORDMAPS(hdr, /MAINREF)
      pix_main2ref = ROUND(result.pix_a2b)
      pix_ref2main = ROUND(result.pix_b2a)
    ENDELSE
  ENDIF 
  IF hdr.sjifile THEN BEGIN
    IF (hdr.wcs_set AND hdr.sji_wcs_set) THEN BEGIN
      pix_main2sji = ROUND(WCS_GET_PIXEL(hdr.wcs_sji, WCS_GET_COORD(hdr.wcs_main)))
      pix_sji2main = ROUND(WCS_GET_PIXEL(hdr.wcs_main, WCS_GET_COORD(hdr.wcs_sji)))
    ENDIF ELSE BEGIN
      result = CRISPEX_TRANSFORM_GET_COORDMAPS(hdr, /MAINSJI)
      pix_main2sji = ROUND(result.pix_a2b)
      pix_sji2main = ROUND(result.pix_b2a)
    ENDELSE
    IF hdr.showref THEN BEGIN
      IF (hdr.ref_wcs_set AND hdr.sji_wcs_set) THEN BEGIN
        pix_ref2sji = ROUND(WCS_GET_PIXEL(hdr.wcs_sji, WCS_GET_COORD(hdr.wcs_ref)))
        pix_sji2ref = ROUND(WCS_GET_PIXEL(hdr.wcs_ref, WCS_GET_COORD(hdr.wcs_sji)))
      ENDIF ELSE BEGIN
        result = CRISPEX_TRANSFORM_GET_COORDMAPS(hdr, /REFSJI)
        pix_ref2sji = ROUND(result.pix_a2b)
        pix_sji2ref = ROUND(result.pix_b2a)
      ENDELSE
    ENDIF
  ENDIF 

  CRISPEX_IO_OPEN_MASKCUBE, MASKCUBE=maskcube, HDR_IN=hdr, HDR_OUT=hdr, STARTUPTLB=startuptlb, $
                            IO_FAILSAFE_MASK_ERROR=io_failsafe_mask_error
  IF (io_failsafe_mask_error EQ 1) THEN BEGIN
    CRISPEX_CLOSE_FREE_LUN, hdr.lunim, hdr.lunsp, hdr.lunrefim, hdr.lunrefsp, $
      hdr.lunmask, hdr.lunsji, IMDISP=(hdr.lunim NE 0), SPDISP=(hdr.lunsp NE 0), $
      REFIMDISP=(hdr.lunrefim NE 0), REFSPDISP=(hdr.lunrefsp NE 0), $
      MASKDISP=(hdr.lunmask NE 0), SJIDISP=(hdr.lunsji NE 0)
    WIDGET_CONTROL, startuptlb, /DESTROY
    RETURN
  ENDIF

	IF (hdr.refnlp NE hdr.nlp) THEN BEGIN
		eqnlps = 0 
		refslid_sens = (hdr.showref AND (hdr.refnlp GT 1)) 
	ENDIF ELSE BEGIN
		eqnlps = 1
		refslid_sens = 0
	ENDELSE
	showrefls = (hdr.refspfile OR (hdr.refnlp GT 1))
	
  IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, $
                                                      'Reading input files... done!'

	DEVICE, DECOMPOSE = 0	

;========================= SETTING START-UP OPTIONS 
;------------------------- PARAMETERS FROM MEAN SPEC
	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(parameters from/for mean spectrum)', /OPT, /OVER
	feedback_text = ['Setting start-up options... ','> Parameters from/for mean spectrum... ']
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text
	detspect_scale_enable = (hdr.nlp GT 1)
	detspect_scale = (hdr.nlp GT 1)
	ref_detspect_scale = (hdr.refnlp GT 1)

	scalestokes = (N_ELEMENTS(SCALE_STOKES) EQ 1) 
	IF (N_ELEMENTS(SCALE_STOKES) GT 1) THEN $
    PRINT, 'WARNING: The SCALE_STOKES keyword must either be set or supplied with a single '+$
           'number! Reverting to standard scaling.'

  ; Set final XTITLE and YTITLE variables for LS and SP windows
	IF (N_ELEMENTS(XTITLE) EQ 1) THEN BEGIN         ; Check whether XTITLE has 1 element
    IF (N_ELEMENTS(REFXTITLE) EQ 1) THEN $        ; Check whether REFXTITLE has 1 element
      hdr.xtitle = [xtitle[0],refxtitle[0]] $     ; If so, fill xtitle variable with both
    ELSE $                                        ; Else, fill xtitle variable only with main
      hdr.xtitle = [xtitle[0],''] 
  ENDIF ELSE IF (N_ELEMENTS(XTITLE) EQ 2) THEN $  ; Check whether XTITLE has 2 elements
    hdr.xtitle = xtitle $                         ; If so, use that
  ELSE IF (N_ELEMENTS(REFXTITLE) EQ 1) THEN $     ; If not, check whether REFXTITLE has 1 element
    hdr.xtitle = ['',refxtitle[0]]                ; If so, set 2nd xtitle element to that
	IF (N_ELEMENTS(YTITLE) EQ 1) THEN BEGIN         ; Check whether YTITLE has 1 element
    IF (N_ELEMENTS(REFYTITLE) EQ 1) THEN $        ; Check whether REFYTITLE has 1 element
      hdr.ytitle = [ytitle[0],refytitle[0]] $     ; If so, fill ytitle variable with both
    ELSE $                                        ; Else, fill ytitle variable only with main
      hdr.ytitle = [ytitle[0],''] 
  ENDIF ELSE IF (N_ELEMENTS(YTITLE) EQ 2) THEN $  ; Check whether YTITLE has 2 elements
    hdr.ytitle = ytitle $                         ; If so, use that
  ELSE IF (N_ELEMENTS(REFYTITLE) EQ 1) THEN $     ; If not, check whether REFYTITLE has 1 element
    hdr.ytitle = ['',refytitle[0]]                ; If so, set 2nd ytitle element to that
  
  CRISPEX_IO_SETTINGS_SPECTRAL, HDR_IN=hdr, HDR_OUT=hdr, MNSPEC=mnspec, SPECTFILE=spectfile,$
                                LINE_CENTER=line_center, NO_WARP=no_warp, STARTUPTLB=startuptlb, $
                                IO_FAILSAFE_MNSPEC_ERROR=io_failsafe_mnspec_error, $
                                IO_FAILSAFE_IMSPECTFILE_ERROR=io_failsafe_imspectfile_error, $
                                IO_FAILSAFE_REFSPECTFILE_ERROR=io_failsafe_refspectfile_error, $
                                IO_FAILSAFE_LINE_CENTER_ERROR=io_failsafe_line_center_error

  IF ((io_failsafe_mnspec_error EQ 1) OR (io_failsafe_imspectfile_error EQ 1) OR $
      (io_failsafe_refspectfile_error EQ 1) OR (io_failsafe_line_center_error EQ 1)) THEN BEGIN
    CRISPEX_CLOSE_FREE_LUN, hdr.lunim, hdr.lunsp, hdr.lunrefim, hdr.lunrefsp, $
      hdr.lunmask, hdr.lunsji, IMDISP=(hdr.lunim NE 0), SPDISP=(hdr.lunsp NE 0), $
      REFIMDISP=(hdr.lunrefim NE 0), REFSPDISP=(hdr.lunrefsp NE 0), $
      MASKDISP=(hdr.lunmask NE 0), SJIDISP=(hdr.lunsji NE 0)
    WIDGET_CONTROL, startuptlb, /DESTROY
    RETURN
  ENDIF
	
	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(parameters from/for mean spectrum)', /OPT, /OVER, /DONE, $
                                        REPEAT_STAGE=(verbosity[1] OR $
                                          (io_failsafe_imspectfile_error EQ 2) OR $
                                          (io_failsafe_refspectfile_error EQ 2))
	feedback_text = [feedback_text[0:N_ELEMENTS(feedback_text)-2],$
                   '> Parameters from/for mean spectrum... done!']
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text

;--------------------------------------------------------------------------------- INITIAL SLIT PARAMETERS
	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(initial slit parameters)', /OPT, /OVER
	feedback_text = [feedback_text,'> Initial slit parameters... ']
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text

  nphi	= LONG(CEIL(SQRT( FLOAT(hdr.nx)^2 + FLOAT(hdr.ny)^2 )))	; Determine maximum number of slitpositions
	angle = 90														; Set initial angle of the slit

  IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(initial slit parameters)', /OPT, /OVER, /DONE
	feedback_text = [feedback_text[0:N_ELEMENTS(feedback_text)-2],'> Initial slit parameters... done!']
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text

;--------------------------------------------------------------------------------- INITIAL PLAYBACK PARAMETERS
	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(initial playback parameters)', /OPT, /OVER
	feedback_text = [feedback_text,'> Initial playback parameters... ']
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text
	t_first		= 0L													; Set number of first frame		
  t_last = hdr.mainnt-1													; Set number of last frame
  t_slid_sens = (hdr.mainnt NE 1)
	t_step		= 1L													; Set initial timestep
	t_speed 	= 10													; Set initial animation speed
	direction 	= 1													; Set initial animation direction
	t_start = t_first

  ; Check setting of DT keyword; is superseded by FITS header information, if present
  IF dt_keyword_set THEN BEGIN
    dt_set = dt_keyword_set
    IF hdr.imcube_compatibility THEN BEGIN
			IF (N_ELEMENTS(SPYTITLE) NE 1) THEN spytitle = 'Time [s]'
    ENDIF ELSE spytitle = hdr.spytitle
  ; If no DT set, check whether supplied from FITS header (in which case hdr.dt ne 0)
  ENDIF ELSE BEGIN
    dt_set = (hdr.dt NE 0.)
    IF dt_set THEN $
      spytitle = hdr.spytitle $   ; FITS header: no override of SPYTITLE allowed
    ; If no DT set and no info from header, then set defaults
    ELSE BEGIN
      hdr.dt = 1.
			IF (N_ELEMENTS(SPYTITLE) NE 1) THEN spytitle = 'Frame number'
    ENDELSE
  ENDELSE

	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(initial playback parameters)', /OPT, /OVER, /DONE
	feedback_text = [feedback_text[0:N_ELEMENTS(feedback_text)-2],'> Initial playback parameters... done!']
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text

;--------------------------------------------------------------------------------- INITIAL SPECTRAL PARAMETERS
	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(initial spectral parameters)', /OPT, /OVER
	feedback_text = [feedback_text,'> Initial spectral parameters... ']
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text
	lp_first 	= 0L													; Set number of first lineposition
	lp_last		= hdr.nlp-1L													; Set number of last lineposition
	sp		= hdr.mainnt * hdr.nlp												; Set spectral dimension
	lp_start 	= hdr.lc
	lp_ref_first = lp_first
	IF showrefls THEN BEGIN
		lp_ref_last = hdr.refnlp - 1L
		lp_ref_start = hdr.reflc
	ENDIF ELSE IF (hdr.refnlp GT 1) THEN BEGIN
		lp_ref_last = lp_last
		lp_ref_start = hdr.lc
	ENDIF ELSE BEGIN
		lp_ref_last = 1L
		lp_ref_start = 0L
	ENDELSE
  lp_ref_lock = eqnlps ;(eqnlps AND (lp_ref_start EQ lp_start))
  IF (lp_ref_lock) THEN lp_ref_start = lp_start
	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(initial spectral parameters)', /OPT, /OVER, /DONE
	feedback_text = [feedback_text[0:N_ELEMENTS(feedback_text)-2],'> Initial spectral parameters... done!']
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text

;--------------------------------------------------------------------------------- WINDOW SIZES (CHANGE ONLY
;--------------------------------------------------------------------------------- NUMERICAL VALUES!)
	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(window sizes)', /OPT, /OVER
	feedback_text = [feedback_text,'> Window sizes... ']
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text
	
	heightset 	= 0
	refheightset 	= 0
	IF ((N_ELEMENTS(hdr.xtitle) GE 1) AND (N_ELEMENTS(hdr.xtitle) LE 2)) THEN BEGIN
		IF (STRCOMPRESS(hdr.xtitle[0]) NE '') THEN BEGIN
			heightset = (STRCMP(hdr.xtitle[0],'Height',6,/FOLD_CASE) OR $
                   STRCMP(hdr.xtitle[0],'z',1,/FOLD_CASE))
      IF heightset THEN BEGIN
  			hdr.v_dop_set[0] = 0
  			hdr.spxtitle = hdr.xtitle[0]
      ENDIF
		ENDIF
		IF (N_ELEMENTS(hdr.xtitle) EQ 2) THEN BEGIN
			IF (STRCOMPRESS(hdr.xtitle[1]) NE '') THEN BEGIN
				refheightset = (STRCMP(hdr.xtitle[1],'Height',6,/FOLD_CASE) OR $
                        STRCMP(hdr.xtitle[1],'z',1,/FOLD_CASE))
        IF refheightset THEN BEGIN
				  hdr.v_dop_set[1] = 0
				  hdr.refspxtitle = hdr.xtitle[1]
        ENDIF
			ENDIF
		ENDIF
	ENDIF
	IF heightset THEN detspect_scale = 0
	IF refheightset THEN ref_detspect_scale = 0

	sp_h 	= ['Spectral','Height']
	wav_h 	= ['Wavelength','Height']
	lp_h_capital	= ['S','H']
	but_tooltip = ['Spectrum','Height distribution']

  ; Load (ref)lsytitles from FITS cubes or SPECTFILE
	lsytitle	= hdr.ytitle[0]
	reflsytitle	= hdr.ytitle[1]
  ; Override by XTITLE and YTITLE keywords, if set
	IF ((N_ELEMENTS(YTITLE) GE 1) AND (N_ELEMENTS(YTITLE) LE 2)) THEN BEGIN
		IF (STRCOMPRESS(ytitle[0]) NE '') THEN lsytitle = ytitle[0]
		IF (N_ELEMENTS(YTITLE) EQ 2) THEN BEGIN
			IF (STRCOMPRESS(ytitle[1]) NE '') THEN reflsytitle = ytitle[1]
		ENDIF
	ENDIF

	xdelta		= 20					; Extra xoffset for positioning of windows
	ydelta		= 40					; Extra yoffset for positioning of windows
  minsize   = 200.
 
  ; Determine image and pixel aspect ratio
  ratio      = FLOAT(ABS(hdr.nx)) / FLOAT(ABS(hdr.ny))                  
  pixelratio = FLOAT(ABS(hdr.dx)) / FLOAT(ABS(hdr.dy))                  

  ; Determine default window sizes (i.e., regardless of monitor size)
  imwinx_default = hdr.nx
  imwiny_default = hdr.ny

  ; Handle pixel aspect ratio for default sizes
  IF (pixelratio GT 1) THEN imwinx_default *= pixelratio ELSE $
    IF (pixelratio LT 1) THEN imwiny_default *= pixelratio
  
  ; Check for extreme aspect ratio and small dimensions
  extreme_aspect = (((ratio GT 5.) AND (imwiny_default LT minsize)) OR $
                    ((ratio LT 0.2) AND (imwinx_default LT minsize))) 

  ; Get main screen sizes
  x_scr_size = screensizes[2,monitor_order[0]]
	y_scr_size = screensizes[3,monitor_order[0]]

  IF (N_ELEMENTS(WINDOW_LARGE) NE 1) THEN window_large = 0
  IF (window_large LE 1) THEN BEGIN
    ; Check whether window would in principle fit (only if xsize > nx+space for
    ; spectral windows AND ysize > ny), but override by WINDOW_LARGE if set:
  	IF ((x_scr_size GT (imwinx_default+2*xdelta+0.2*x_scr_size)) AND $
        (y_scr_size GT imwiny_default)) THEN BEGIN		
      ; If xsize is small, then still go to old settings procedures
  		IF ((imwinx_default LT 0.48 * x_scr_size) AND $
          (imwiny_default LT (0.48 * x_scr_size / ratio)) AND $
          (extreme_aspect OR (window_large EQ 1))) THEN BEGIN				
        ; Set maximum x- and y-extent of image window
        IF (extreme_aspect AND (hdr.nx EQ 1)) THEN $
          imwinx = 5*hdr.nx $
        ELSE $
  			  imwinx 	= 0.48 * x_scr_size											
  			imwiny 	= imwinx / ratio
        ; Failsafe to avoid a window larger than the screensize
  		  IF (imwiny GT y_scr_size) THEN BEGIN										
  			  imwiny = 0.9 * y_scr_size											
          IF (extreme_aspect AND (hdr.nx EQ 1)) THEN $
            imwinx = 5*hdr.nx $
          ELSE $
  			    imwinx = imwiny * ratio
  		  ENDIF
  			IF (verbosity[1] EQ 1) THEN $
          msg = 'User screen resolution allows 1:1 image window sizing, '+$
            'but dimensions are small. '
      ; Else fit the window with actual data dimensions
  		ENDIF ELSE BEGIN
        ; Use actual nx/ny as imwinx/imwiny
  			imwinx	= hdr.nx                  
        IF (extreme_aspect AND (hdr.nx EQ 1)) THEN imwinx *= 5
  			imwiny	= hdr.ny                 
  			IF (verbosity[1] EQ 1) THEN $
          msg = 'User screen resolution allows 1:1 image window sizing. '
  		ENDELSE
    ; Else use the old procedures to determine imwinx and imwiny
  	ENDIF ELSE BEGIN													
      ; Set maximum x- and y-extent of image window
  		imwinx 	= 0.48 * x_scr_size
  		imwiny 	= imwinx / ratio	 
      ; Failsafe to avoid a window larger than the screensize
  		IF (imwiny GT y_scr_size) THEN BEGIN										
  			imwiny = 0.9 * y_scr_size
        IF (extreme_aspect AND (hdr.nx EQ 1)) THEN $
          imwinx = 5*hdr.nx $
        ELSE $
  			  imwinx = imwiny * ratio
  		ENDIF
  		IF (verbosity[1] EQ 1) THEN $
        msg = 'User screen resolution does not allow for 1:1 image window sizing. '
  	ENDELSE
  ENDIF ELSE BEGIN
    ; Else set imwiny to WINDOW_LARGE value and scale imwinx accordingly, but
    ; with a failsafe for "ridiculously" small values
    IF (window_large GE imwiny_default) THEN BEGIN
      imwiny = window_large
      imwinx = imwiny / ratio
    ENDIF ELSE BEGIN
      imwinx = imwinx_default
      imwiny = imwiny_default
    ENDELSE
  ENDELSE
  ; Fix window sizes for pixelratio
  IF (pixelratio GT 1) THEN $
    imwinx *= pixelratio $
  ELSE IF (pixelratio LT 1) THEN $
    imwiny *= pixelratio
  IF (verbosity[1] EQ 1) THEN $
    CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, msg+'Main image window set to '+$
      STRTRIM(imwinx,2)+'x'+STRTRIM(imwiny,2)+'.', /NEWLINE, /NO_ROUTINE
                                
  ; Set zoomfactors
  zoomfactors = [1.,2.,3.,4.,6.,8.]
  factorswitch = [1B,BYTARR(N_ELEMENTS(zoomfactors)-1)]
  
  ; If reference cube supplied, determine sizes
  IF hdr.showref THEN BEGIN
    ; Determine image and pixel aspect ratio
    refratio      = FLOAT(ABS(hdr.refnx)) / FLOAT(ABS(hdr.refny))
    refpixelratio = FLOAT(ABS(hdr.refdx)) / FLOAT(ABS(hdr.refdy))
    IF hdr.main2ref_no_map THEN BEGIN
      refwinx = imwinx
      refwiny = imwiny
    ENDIF ELSE BEGIN
      refwinx_default = hdr.refnx
      refwiny_default = hdr.refny
      ; Handle pixel aspect ratio
      IF (refpixelratio GT 1) THEN refwinx_default *= refpixelratio ELSE $
        IF (refpixelratio LT 1) THEN refwiny_default *= refpixelratio
      ; Check for extreme aspect ratio and small dimensions
      extreme_aspect_ref = $
        (((refratio GT 5.) AND (refwiny_default LT minsize)) OR $
        ((refratio LT 0.2) AND (refwinx_default LT minsize))) 
      IF (ABS(hdr.refny*hdr.refdy/FLOAT(hdr.ny*hdr.dy)-1.) LT 1E-4) THEN $
        refwiny = refwiny_default/FLOAT(imwiny_default)*imwiny $
      ELSE $
        refwiny = refwiny_default < 0.9 * y_scr_size 
      IF (extreme_aspect_ref AND (hdr.refnx EQ 1)) THEN $
        refwinx = 5*hdr.refnx $
      ELSE $
        refwinx = refwiny * refratio 
      ; Handle pixel aspect ratio
      IF (refpixelratio GT 1) THEN refwinx *= refpixelratio ELSE $
        IF (refpixelratio LT 1) THEN refwiny *= refpixelratio
    ENDELSE
    result = CRISPEX_GET_IMREF_BLINK_BOUNDS(pix_main2ref, pix_ref2main, $
      0, (hdr.nx-1), 0, (hdr.ny-1), 0, (hdr.refnx-1), 0, (hdr.refny-1))
    x_main = result.x_main
    y_main = result.y_main
    x_ref = result.x_ref
    y_ref = result.y_ref
    imrefwinx = imwinx * result.nx_sel / FLOAT(hdr.nx)
    imrefwiny = imwiny * result.ny_sel / FLOAT(hdr.ny)
    IF (verbosity[1] EQ 1) THEN $
      CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, msg+'Reference image window set to '+$
        STRTRIM(refwinx,2)+'x'+STRTRIM(refwiny,2)+'.', /NEWLINE, /NO_ROUTINE
  ENDIF ELSE BEGIN
    refwinx = 0
    refwiny = 0
    imrefwinx = 0
    imrefwiny = 0
    x_main = 0
    y_main = 0
    x_ref = 0
    y_ref = 0
  ENDELSE

  ; If SJI cube supplied, determine sizes
  IF hdr.sjifile THEN BEGIN
    ; Determine image and pixel aspect ratio
    sjiratio      = FLOAT(ABS(hdr.sjinx)) / FLOAT(ABS(hdr.sjiny))
    sjipixelratio = FLOAT(ABS(hdr.sjidx)) / FLOAT(ABS(hdr.sjidy))
    sjiwinx_default = hdr.sjinx
    sjiwiny_default = hdr.sjiny
    ; Handle pixel aspect ratio
    IF (sjipixelratio GT 1) THEN sjiwinx_default *= sjipixelratio ELSE $
      IF (sjipixelratio LT 1) THEN sjiwiny_default *= sjipixelratio
    sjiwiny = sjiwiny_default/FLOAT(imwiny_default)*imwiny
    sjiwinx = sjiwinx_default/FLOAT(sjiwiny_default)*sjiwiny
  ENDIF ELSE BEGIN
    sjiwinx = 0
    sjiwiny = 0
  ENDELSE

  ; Set default tickmark length (fraction of window size)
  ticklen 	= 0.01

  ; ==================== Main detailed spectrum window ====================
  ; Set detailed spectrum window parameters
	lswinx 		= 0.2 * x_scr_size											; Set maximum x-extent of loc spec win
	lsmargin 	= 0.1
	lswall 		= 0.03
	lswintitle	= ['Detailed spectrum','Height distribution']
	xsize 		= 1.*lswinx
  ; Determine number of panels for detailed spectrum window
	IF (hdr.ns LE 2) THEN BEGIN
		npanels = hdr.ns	&	cols = hdr.ns	&	rowarr = REPLICATE(0,hdr.ns)
	ENDIF ELSE BEGIN
		npanels = 4	&	cols = 2	&	rowarr = [1,1,0,0]
	ENDELSE
	rows = CEIL(npanels / FLOAT(cols))
  ; Determine plot width and height, and consequent window height
	lswidth = (1. - (cols*lsmargin + lswall))/FLOAT(cols)
	lsheight = lswidth * 2D / (1 + SQRT(5))
	IF (hdr.v_dop_set[0] EQ 1) THEN $
    lswiny = (lsmargin + rows*lsheight + rows*lsmargin + (rows-1)*lswall) * lswinx $
  ELSE $
    lswiny = (lswall + rows*lsheight + rows*lsmargin) * lswinx
  ; Determine plot positions
	lsx0 		= lsmargin + (INDGEN(npanels) MOD cols) * (lswidth + lsmargin) 
	lsx1 		= lsx0 + lswidth 
	lsy0 		= (lsmargin + rowarr * (lsheight + lsmargin + hdr.v_dop_set[0]*lswall)) * lswinx/lswiny
	lsy1 		= lsy0 + lsheight * lswinx/lswiny
  ; Determine default margin, wall and tickmark length 
	lsxmargin_init	= lsmargin * lswinx
	lsxwall_init	= lswall * lswinx
	lsxticklen 	= ticklen / lsheight
	lsyticklen 	= ticklen / lswidth

  ; ==================== Reference detailed spectrum window ====================
  ; Set reference spectrum window parameters
	reflswintitle	= ['Reference detailed spectrum','Reference height distribution']
	reflswinx	= lswinx
  ; Determine plot width and height, and consequent window height
	reflswidth 	= (xsize/lswinx - (lsmargin + lswall))
	reflsheight 	= reflswidth * 2D / (1 + SQRT(5))
	IF (hdr.v_dop_set[1] EQ 1) THEN $
    reflswiny = (lsmargin + reflsheight + lsmargin) * lswinx $
  ELSE $
    reflswiny = (lsmargin + reflsheight + lswall) * lswinx
  ; Determine plot positions
	reflsx0 	= lsmargin 
	reflsx1 	= reflsx0 + reflswidth 
	reflsy0 	= lsmargin * reflswinx/reflswiny
	reflsy1 	= reflsy0 + reflsheight * reflswinx/reflswiny
  ; Determine default margin, wall and tickmark length 
	reflsxmargin_init= lsmargin * reflswinx
	reflsxwall_init	= lswall * reflswinx
	reflsxticklen 	= ticklen / reflsheight
	reflsyticklen 	= ticklen / reflswidth

  ; ==================== Lightcurve window ====================
  ; Set lightcurve window parameters
	intwidth 	= (xsize/lswinx - (lsmargin + lswall))
	intheight 	= intwidth * 2D / (1 + SQRT(5))
	intwinx		= lswinx
	intwiny 	= (lsmargin + intheight + lswall) * intwinx
  ; Determine plot positions
	intx0 		= lsmargin 
	intx1 		= intx0 + intwidth 
	inty0 		= lsmargin * intwinx/intwiny
	inty1	 	= inty0 + intheight * intwinx/intwiny
  ; Determine default margin, wall and tickmark length 
	intxmargin_init	= lsmargin * intwinx
	intxwall_init	= lswall * intwinx
	intxticklen 	= ticklen / intheight
	intyticklen 	= ticklen / intwidth

  ; ==================== Spectrum-time and Phi-slit window ====================
	spwintitle	= ['Spectral T-slice','Height T-slice']
  phiswintitle	= ['Spectral Phi-slice','Height Phi-slice']
  ; Window sizes	
  spwinx		= 0.2 * x_scr_size											; Set maximum x-extent of spectral win
  spwiny    = (imwiny - lswiny) > (y_scr_size/2.)
	phiswinx	= spwinx
  phiswiny  = spwiny
  ; Determine default margin adn wall 
	spxmargin_init	= lsmargin * lswinx * 1.3
	spxwall_init	= lswall * lswinx
	spmargin 	= spxmargin_init/spwinx
	spwall 		= spxwall_init/spwinx
  ; Plot sizes
	spwidth 	= (1. - (spmargin + spwall))
	IF ((hdr.v_dop_set[0] EQ 1) OR (hdr.ns GT 1)) THEN BEGIN
		spheight = (1. - (spmargin * 2.) * spwinx/spwiny)
		phisheight = (1. - (spmargin * 2.) * phiswinx/phiswiny)
	ENDIF ELSE BEGIN
		spheight = (1. - (spmargin + spwall) * spwinx/spwiny)
		phisheight = (1. - (spmargin + spwall) * phiswinx/phiswiny)
	ENDELSE
  ; Determine plot positions
	spx0 		= spmargin 
	spx1 		= spx0 + spwidth 
	spy0 		= spmargin * spwinx/spwiny
	spy1 		= spy0 + spheight; * spwinx/spwiny
	xplspw		= spx1 - spx0												; x-extent of the plot
	yplspw		= spy1 - spy0												; y-extent of the plot
  ; Determine default tickmark length 
	spxticklen 	= -1. * ticklen / spheight
	spyticklen 	= -1. * ticklen / spwidth
  ; Determine rebinning factors for display of slice
	IF ((hdr.spfile EQ 1) OR (hdr.single_cube[0] GE 1)) THEN $
    ntreb = yplspw * spwiny $
  ELSE $
    ntreb = 0						; actual nt rebinning factor
	nlpreb		= xplspw * spwinx							 				; actual nlp rebinning factor
	
  ; Determine plot positions: Phi-slit
	phisx0 		= spmargin * phiswinx/phiswinx 
	phisx1 		= phisx0 + spwidth * phiswinx/phiswinx
	phisy0 		= spmargin * phiswinx/phiswiny
	phisy1 		= phisy0 + phisheight; * spwinx/spwiny
	phisxplspw	= phisx1 - phisx0												; x-extent of the plot
	phisyplspw	= phisy1 - phisy0												; y-extent of the plot
  ; Determine default tickmark length 
	phisxticklen 	= -1. * ticklen / phisheight
	phisyticklen 	= -1. * ticklen / spwidth
  ; Determine rebinning factors for display of slice
	nphireb		= phisyplspw * phiswiny

  ; ==================== Reference spectrum-time window ====================
	refspwiny	= spwiny 
	refspwintitle	= ['Reference spectral T-slice','Reference height T-slice']
  ; Determine plot width and height
	IF (hdr.v_dop_set[1] EQ 1) THEN $
    refspheight = (1. - (spmargin * 2.) * spwinx/spwiny) $
  ELSE $
    refspheight = (1. - (spmargin + spwall) * spwinx/spwiny)
  ; Determine plot positions
	refspy0 	= spmargin * spwinx/refspwiny
	refspy1 	= refspy0 + refspheight; * spwinx/refspwiny
	refyplspw	= refspy1 - refspy0												; y-extent of the plot
  ; Determine rebinning factors for display of slice
	refntreb	= refyplspw * refspwiny
	
  ; ==================== Space-time diagram window ====================
	loopheight	= (1. - (spmargin + spwall) * spwinx/spwiny)
	loopy1		= spy0 + loopheight
	loopyplspw	= loopy1 - spy0
	loopntreb	= loopyplspw * spwiny

	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(window sizes)', /OPT, /OVER, /DONE, $
                                        REPEAT_STAGE=verbosity[1]
	feedback_text = [feedback_text[0:N_ELEMENTS(feedback_text)-2],'> Window sizes... done!']
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text

;--------------------------------------------------------------------------------- INITIAL SPATIAL PARAMETERS
	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(initial spatial parameters)', /OPT, /OVER
	feedback_text = [feedback_text,'> Initial spatial parameters... ']
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text
	x_first		= 0L													; Set number of first x-coordinate
	x_last		= hdr.nx-1L													; Set number of last x-coordinate
	y_first		= 0L												; Set number of first y-coordinate
	y_last		= hdr.ny-1L													; Set number of last y-coordinate
  ; Get default start coordinates
	x_start		= FLOAT(FLOOR(hdr.nx/2))												
	y_start		= FLOAT(FLOOR(hdr.ny/2))
	sx_start	= x_start * imwinx / FLOAT(hdr.nx)										
	sy_start	= y_start * imwiny / FLOAT(hdr.ny)

  ; Determine starting positions for reference image
  xyref_out_of_range = 0
  IF hdr.showref THEN BEGIN
    xref_first = 0L
    yref_first = 0L
    xref_last = hdr.refnx-1L
    yref_last = hdr.refny-1L
    IF hdr.main2ref_no_map THEN BEGIN
      xref_start = x_start
      yref_start = y_start
      sxref_start = sx_start
      syref_start = sy_start
    ENDIF ELSE BEGIN
      ; Get starting points directly from conversion maps
      xref_start = pix_main2ref[0,x_start,y_start];$
      yref_start = pix_main2ref[1,x_start,y_start];$
      xyref_out_of_range = ((xref_start LT 0) OR (yref_start LT 0) OR $
                            (xref_start GE hdr.refnx) OR $
                            (yref_start GE hdr.refny))
      ; If conversion of x/y_start to x/yref_start pushes the latter out of
      ; range adjust x/y(ref)_start to middle of overlapping area
      IF xyref_out_of_range THEN BEGIN
        ; x/y boundaries of reference in main coordinate system
        x_ref_on_main = [pix_ref2main[0,0,0],pix_ref2main[0,hdr.refnx-1,0]]
        y_ref_on_main = [pix_ref2main[1,0,0],pix_ref2main[1,0,hdr.refny-1]]
        ; Determine boundaries in main
        x_bound = [(x_ref_on_main[0] > 0), $
                   (x_ref_on_main[1] < (hdr.nx-1))]
        y_bound = [(y_ref_on_main[0] > 0), $
                   (y_ref_on_main[1] < (hdr.ny-1))]
        ; Set new x/y_start and convert to reference coordinate system
        x_start = FLOAT(FLOOR((x_bound[1]-x_bound[0]+1)/2.)+x_bound[0])
        y_start = FLOAT(FLOOR((y_bound[1]-y_bound[0]+1)/2.)+y_bound[0])
        xref_start = pix_main2ref[0,x_start,y_start]
        yref_start = pix_main2ref[1,x_start,y_start]
        xyref_out_of_range = 0
      ENDIF
      sxref_start = xref_start * refwinx / hdr.refnx
      syref_start = yref_start * refwiny / hdr.refny
    ENDELSE
  ENDIF ELSE BEGIN
    xref_first = 0L
    xref_last = 1L
    yref_first = 0L
    yref_last = 1L
    xref_start = 0L
    yref_start = 0L
    sxref_start = 0.
    syref_start = 0.
  ENDELSE

  ; Determine starting positions for slit-jaw image
  IF hdr.sjifile THEN BEGIN
    ; Get starting points directly from conversion maps
    xsji_start = pix_main2sji[0,x_start,y_start];$
    ysji_start = pix_main2sji[1,x_start,y_start];$
    xysji_out_of_range = ((xsji_start LT 0) OR (ysji_start LT 0) OR $
                          (xsji_start GE hdr.sjinx) OR $
                          (ysji_start GE hdr.sjiny))
    sxsji_start = xsji_start * sjiwinx / hdr.sjinx
    sysji_start = ysji_start * sjiwiny / hdr.sjiny
  ENDIF ELSE BEGIN
    xsji_start = 0L
    ysji_start = 0L
    sxsji_start = 0.
    sysji_start = 0.
    xysji_out_of_range = 0
  ENDELSE

	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(initial spatial parameters)', /OPT, /OVER, /DONE
	feedback_text = [feedback_text[0:N_ELEMENTS(feedback_text)-2],'> Initial spatial parameters... done!']
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text

;--------------------------------------------------------------------------------- SCALING PARAMETERS
	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(initial scaling parameters)', /OPT, /OVER
	feedback_text = [feedback_text,'> Initial scaling parameters... ']
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text
	imagescale = PTR_NEW([0,0,0,0])												; Image scaling based on first image
	relative_scaling = PTR_NEW([0,0,0,0])
	immin = DBLARR(hdr.nlp,hdr.ns,/NOZERO)
	immax = DBLARR(hdr.nlp,hdr.ns,/NOZERO)
	immean = DBLARR(hdr.nlp,hdr.ns,/NOZERO)
	imsdev = DBLARR(hdr.nlp,hdr.ns,/NOZERO)
	dopplermin = DBLARR(hdr.nlp,hdr.ns,/NOZERO)
	dopplermax = DBLARR(hdr.nlp,hdr.ns,/NOZERO)
  dopplerscan = FLTARR(hdr.nx,hdr.ny,hdr.nlp*hdr.ns,/NOZERO)
	ls_low_y = FLTARR(hdr.ns,/NOZERO)
	ls_upp_y = FLTARR(hdr.ns,/NOZERO)
	ls_yrange = FLTARR(hdr.ns,/NOZERO)
	int_low_y = FLTARR(hdr.ns,/NOZERO)
	int_upp_y = FLTARR(hdr.ns,/NOZERO)
  IF scalestokes THEN $
    tmp_ms = REPLICATE(hdr.ms,hdr.ns) $
  ELSE $
    tmp_ms = hdr.ms
	FOR s=0,hdr.ns-1 DO BEGIN
		FOR lp=0,lp_last DO BEGIN
			temp_image = (*hdr.imdata)[s*hdr.nlp + lp]
			immean[lp,s] = MEAN(temp_image, /NAN)
			imsdev[lp,s] = STDDEV(temp_image, /NAN)
  		immin[lp,s] = MIN(temp_image, MAX=max_val, /NAN)
  		immax[lp,s] = max_val
			temp_lp = 2*hdr.lc - lp
			IF ((temp_lp GE 0) AND (temp_lp LT lp_last)) THEN BEGIN
				mirror_temp_image = (*hdr.imdata)[s*hdr.nlp + temp_lp]
  			IF (temp_lp LT hdr.lc) THEN $
          dopplerim = temp_image - mirror_temp_image $
  			ELSE $
          dopplerim = mirror_temp_image - temp_image
        dopplerscan[*,*,s*hdr.nlp+lp] = dopplerim
  			dopplermin[lp,s] = MIN(dopplerim, MAX=max_val, /NAN)
  			dopplermax[lp,s] = max_val
      ENDIF
		ENDFOR
    dopplermin[hdr.lc,s] = 0.
    dopplermax[hdr.lc,s] = 0.
	  ls_low_y[s] = MIN((immean[*,s]-3.*imsdev[*,s])/tmp_ms[s], /NAN)
	  ls_upp_y[s] = MAX((immean[*,s]+3.*imsdev[*,s])/tmp_ms[s], /NAN)
		ls_yrange[s] = ls_upp_y[s] - ls_low_y[s]
		max_imsdev = MAX(imsdev[*,s], /NAN)
		int_low_y[s] = (MEAN(immean[*,s], /NAN)-3.*max_imsdev)/ABS(MEAN(immean[*,s], /NAN))
		int_upp_y[s] = (MEAN(immean[*,s], /NAN)+3.*max_imsdev)/ABS(MEAN(immean[*,s], /NAN))
	ENDFOR
	ls_low_y_init = ls_low_y[0]
	ls_upp_y_init = ls_upp_y[0]
  IF (hdr.ndiagnostics GT 1) THEN BEGIN
    ; Determine multiplicative factors
    ls_range_tmp = FLTARR(hdr.ndiagnostics,hdr.ns)
    FOR j=0,hdr.ns-1 DO BEGIN
      FOR d=0,hdr.ndiagnostics-1 DO BEGIN
        ls_low_tmp=MIN((immin[hdr.diag_start[d]:(hdr.diag_start[d]+(hdr.diag_width[d]-1)),$
          j]-3.*imsdev[hdr.diag_start[d]:(hdr.diag_start[d]+(hdr.diag_width[d]-1)),j])/$
          hdr.ms[j], /NAN)
        ls_upp_tmp=MAX((immax[hdr.diag_start[d]:(hdr.diag_start[d]+(hdr.diag_width[d]-1)),$
          j]+3.*imsdev[hdr.diag_start[d]:(hdr.diag_start[d]+(hdr.diag_width[d]-1)),j])/$
          hdr.ms[j], /NAN)
        ls_range_tmp[d,j] = ls_upp_tmp - ls_low_tmp
      ENDFOR
    ENDFOR
    main_mult_val = REPLICATE(ls_range_tmp[WHERE(ls_range_tmp EQ MAX(ls_range_tmp, /NAN))],$
      hdr.ndiagnostics)/ls_range_tmp
  ENDIF ELSE main_mult_val = REPLICATE(1.,hdr.ns)
	ls_low_y = PTR_NEW(ls_low_y,/NO_COPY)
	ls_upp_y = PTR_NEW(ls_upp_y,/NO_COPY)
	ls_yrange = PTR_NEW(ls_yrange,/NO_COPY)
	int_low_y = PTR_NEW(int_low_y,/NO_COPY)
	int_upp_y = PTR_NEW(int_upp_y,/NO_COPY)

	ls_low_y_ref = 0
	ls_upp_y_ref = 0
	IF hdr.showref THEN BEGIN
		IF (hdr.refnt EQ 0) THEN BEGIN
			refmin = MIN(*hdr.refdata, MAX=refmax, /NAN)
			refmean = MEAN(*hdr.refdata, /NAN)
			refdev = STDDEV(*hdr.refdata, /NAN)
		ENDIF ELSE IF (((hdr.refnt EQ 1) OR (hdr.refnt EQ hdr.mainnt)) AND (hdr.refnlp EQ 1)) THEN BEGIN
			refmin = MIN((*hdr.refdata)[0], MAX=refmax, /NAN)
			refmean = MEAN((*hdr.refdata)[0], /NAN)
			refdev = STDDEV((*hdr.refdata)[0], /NAN)
		ENDIF ELSE BEGIN
			refmin = FLTARR(hdr.refnlp)
			refmax = FLTARR(hdr.refnlp)
			refmean = FLTARR(hdr.refnlp)
			refdev = FLTARR(hdr.refnlp)
			FOR lp=0,hdr.refnlp-1 DO BEGIN
				temp_referencefile = (*hdr.refdata)[lp]
				refmean[lp] = MEAN(temp_referencefile, /NAN)
				refdev[lp] = STDDEV(temp_referencefile, /NAN)
				refmin[lp] = MIN(temp_referencefile, MAX=max_val, /NAN)
				refmax[lp] = max_val
			ENDFOR
		ENDELSE
		IF showrefls THEN BEGIN
			ls_low_y_ref = MIN((refmean-3.*refdev)/hdr.refms, /NAN)
			ls_upp_y_ref = MAX((refmean+3.*refdev)/hdr.refms, /NAN)
		ENDIF
    IF (hdr.nrefdiagnostics GT 1) THEN BEGIN
      ; Determine multiplicative factors
      ls_range_tmp = FLTARR(hdr.nrefdiagnostics,hdr.ns)
      FOR d=0,hdr.nrefdiagnostics-1 DO BEGIN
        ls_low_tmp=MIN((refmin[hdr.refdiag_start[d]:$
          (hdr.refdiag_start[d]+(hdr.refdiag_width[d]-1))]-$
          3.*refdev[hdr.refdiag_start[d]:(hdr.refdiag_start[d]+$
          (hdr.refdiag_width[d]-1))])/hdr.refms, /NAN)
        ls_upp_tmp=MAX((refmax[hdr.refdiag_start[d]:$
          (hdr.refdiag_start[d]+(hdr.refdiag_width[d]-1))]+$
          3.*refdev[hdr.refdiag_start[d]:(hdr.refdiag_start[d]+$
          (hdr.refdiag_width[d]-1))])/hdr.refms, /NAN)
        ls_range_tmp[d] = ls_upp_tmp - ls_low_tmp
      ENDFOR
      ref_mult_val = REPLICATE(ls_range_tmp[WHERE(ls_range_tmp EQ $
        MAX(ls_range_tmp, /NAN))],hdr.nrefdiagnostics)/ls_range_tmp
    ENDIF ELSE ref_mult_val = 1.
	ENDIF ELSE BEGIN
		refmin = 0
		refmax = 0
    ref_mult_val = 0
	ENDELSE
	ls_yrange_ref = ls_upp_y_ref - ls_low_y_ref 

  sjidata_tmp = (*hdr.sjidata)[0]
  ; If SJI data is scaled integer, descale and convert to float
  IF hdr.sjiscaled THEN $
    sjidata_tmp = CRISPEX_SCALING_DESCALE(sjidata_tmp, hdr.sjibscale, hdr.sjibzero)
  sjimin = MIN(sjidata_tmp, MAX=sjimax_val, /NAN)
  sjimax = sjimax_val
  IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(initial scaling parameters)', /OPT, /OVER, /DONE
	feedback_text = [feedback_text[0:N_ELEMENTS(feedback_text)-2],'> Initial scaling parameters... done!']
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text

;--------------------------------------------------------------------------------- OTHER PARAMETERS
	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(other parameters)', /OPT, /OVER
	feedback_text = [feedback_text,'> Other parameters... ']
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text
	IF KEYWORD_SET(EXTS) THEN exts_set = 1 ELSE exts_set = 0
	IF (hdr.single_cube[0] GE 1) THEN BEGIN
		IF (hdr.mainnt GT 1) THEN BEGIN
			exts_set = 1						; Automatically set EXTS when providing a (single lineposition) 3D cube
      CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, 'The exact timeslice (EXTS) keyword has been '+$
        'automatically set to enable the drawing of loop paths and extraction of timeslices!', $
        /WARNING, /NO_ROUTINE, /NEWLINE
		ENDIF ELSE exts_set=0
	ENDIF
	refexts_set = (hdr.refspfile NE 1)
	lp_slid_sens = (hdr.nlp GE 2)
	lp_blink_vals_sens = (hdr.nlp GT 2)
	lp_last_slid = (hdr.nlp-1) > 1
	lp_last_blink = (hdr.nlp-1) > 2
	lp_last_vals = hdr.nlp-1

	scale_cubes_vals = [1.,1.]
	IF (N_ELEMENTS(SCALE_CUBES) EQ 1) THEN scale_cubes_vals[0] = scale_cubes ELSE $
    IF (N_ELEMENTS(SCALE_CUBES) EQ 2) THEN scale_cubes_vals = scale_cubes
	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(other parameters)', /OPT, /OVER, /DONE,$
                                        REPEAT_STAGE=verbosity[1]
	feedback_text = [feedback_text[0]+'done!',feedback_text[1:N_ELEMENTS(feedback_text)-2],$
    '> Other parameters... done!']
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text
	WAIT,0.1

;================================================================================= SETTING UP WIDGET
;--------------------------------------------------------------------------------- INITIALISE CONTROL PANEL
	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(loading BMP buttons)', /WIDGET, /OVER
	feedback_text = ['Setting up widget... ','> Loading BMP buttons... ']
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text
	bmpbut_search = FILE_SEARCH(dir_buttons, '*.bmp', COUNT=bmpbut_count)
	IF (bmpbut_count EQ 16) THEN BEGIN
		bmpbut_fbwd_idle     = CRISPEX_READ_BMP_BUTTONS('fbwd_idle.bmp',dir_buttons)
		bmpbut_fbwd_pressed  = CRISPEX_READ_BMP_BUTTONS('fbwd_pressed.bmp',dir_buttons)
		bmpbut_bwd_idle      = CRISPEX_READ_BMP_BUTTONS('bwd_idle.bmp',dir_buttons)
		bmpbut_bwd_pressed   = CRISPEX_READ_BMP_BUTTONS('bwd_pressed.bmp',dir_buttons)
		bmpbut_pause_idle    = CRISPEX_READ_BMP_BUTTONS('pause_idle.bmp',dir_buttons)
		bmpbut_pause_pressed = CRISPEX_READ_BMP_BUTTONS('pause_pressed.bmp',dir_buttons)
		bmpbut_fwd_idle      = CRISPEX_READ_BMP_BUTTONS('fwd_idle.bmp',dir_buttons)
		bmpbut_fwd_pressed   = CRISPEX_READ_BMP_BUTTONS('fwd_pressed.bmp',dir_buttons)
		bmpbut_ffwd_idle     = CRISPEX_READ_BMP_BUTTONS('ffwd_idle.bmp',dir_buttons)
		bmpbut_ffwd_pressed  = CRISPEX_READ_BMP_BUTTONS('ffwd_pressed.bmp',dir_buttons)
		bmpbut_loop_idle     = CRISPEX_READ_BMP_BUTTONS('loop_idle.bmp',dir_buttons)
		bmpbut_loop_pressed  = CRISPEX_READ_BMP_BUTTONS('loop_pressed.bmp',dir_buttons)
		bmpbut_cycle_idle    = CRISPEX_READ_BMP_BUTTONS('cycle_idle.bmp',dir_buttons)
		bmpbut_cycle_pressed = CRISPEX_READ_BMP_BUTTONS('cycle_pressed.bmp',dir_buttons)
		bmpbut_blink_idle    = CRISPEX_READ_BMP_BUTTONS('blink_idle.bmp',dir_buttons)
		bmpbut_blink_pressed = CRISPEX_READ_BMP_BUTTONS('blink_pressed.bmp',dir_buttons)
    failed = 0
	ENDIF ELSE BEGIN
		bmpbut_fbwd_idle  = '<<'    & bmpbut_fbwd_pressed  = bmpbut_fbwd_idle
		bmpbut_bwd_idle   = '<'     & bmpbut_bwd_pressed   = bmpbut_bwd_idle
		bmpbut_pause_idle = '||'    & bmpbut_pause_pressed = bmpbut_pause_idle
		bmpbut_fwd_idle   = '>'     & bmpbut_fwd_pressed   = bmpbut_fwd_idle
		bmpbut_ffwd_idle  = '>>'    & bmpbut_ffwd_pressed  = bmpbut_ffwd_idle
		bmpbut_loop_idle  = 'Loop'  & bmpbut_loop_pressed  = bmpbut_loop_idle
		bmpbut_cycle_idle = 'Cycle' & bmpbut_cycle_pressed = bmpbut_cycle_idle
		bmpbut_blink_idle = 'Blink' & bmpbut_blink_pressed = bmpbut_blink_idle
    failed = 1
	ENDELSE
  IF failed THEN donetext = 'failed.' ELSE donetext = 'done!'
	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(loading BMP buttons)', /WIDGET, /OVER, /DONE, FAIL=failed
	feedback_text = [feedback_text[0:N_ELEMENTS(feedback_text)-2],'> Loading BMP buttons... '+donetext]
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text

;--------------------------------------------------------------------------------- INITIALISE CONTROL PANEL
	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(initialising control panel)', /WIDGET, /OVER
	feedback_text = [feedback_text,'> Initializing control panel... ']
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text
	cpanel		    = WIDGET_BASE(TITLE = 'CRISPEX'+instance_label+': Control Panel', $
    TLB_FRAME_ATTR = 1, /ROW, /FRAME, KILL_NOTIFY = 'CRISPEX_CLOSE_CLEANUP', $
    APP_MBAR = menubar, TLB_SIZE_EVENTS = 1)
  control_panel       = WIDGET_BASE(cpanel, /COLUMN)

  ; CRISPEX
  crispex_menu        = WIDGET_BUTTON(menubar, VALUE='CRISPEX', /MENU, UVALUE='crispex')
	about			          = WIDGET_BUTTON(crispex_menu, VALUE='About CRISPEX', $
                          EVENT_PRO='CRISPEX_ABOUT_WINDOW')
	preferences		      = WIDGET_BUTTON(crispex_menu, VALUE='Preferences', /SEPARATOR, $
                          EVENT_PRO='CRISPEX_PREFERENCES_WINDOW', ACCELERATOR='Ctrl+P')
	exitmenu		        = WIDGET_BUTTON(crispex_menu, VALUE='Quit', /SEPARATOR, $
                          EVENT_PRO='CRISPEX_CLOSE', ACCELERATOR='Ctrl+Q')
  ; Submenus in menu bar
  ; File
	filemenu		        = WIDGET_BUTTON(menubar, VALUE='File', /MENU, UVALUE='file')
;  openmenu            = WIDGET_BUTTON(filemenu, VALUE = 'Open', /MENU)
;  openref             = WIDGET_BUTTON(openmenu, VALUE = 'Reference cube(s)...', $
;                                      EVENT_PRO = 'CRISPEX_IO_OPEN_REFCUBE')
  header_button       = WIDGET_BUTTON(filemenu, VALUE='Show file header(s)', $
                          EVENT_PRO='CRISPEX_DISPLAYS_HEADER', SENSITIVE=($
                            (STRLEN((*hdr.hdrs_main[0])[0]) GT 0) OR $
                            (STRLEN((*hdr.hdrs_ref[0])[0]) GT 0) OR $
                            (STRLEN((*hdr.hdrs_sji[0])[0]) GT 0)))
	restore_session		  = WIDGET_BUTTON(filemenu, VALUE='Load session...', $
                          EVENT_PRO='CRISPEX_SESSION_RESTORE')
	save_session		    = WIDGET_BUTTON(filemenu, VALUE='Save session...', $
                          EVENT_PRO='CRISPEX_SESSION_SAVE_WINDOW')
	save_as_menu		    = WIDGET_BUTTON(filemenu, VALUE='Save as', /SEPARATOR, /MENU)
	save_as_png_menu	  = WIDGET_BUTTON(save_as_menu, VALUE='PNG', /MENU)
	save_as_png_sns		  = WIDGET_BUTTON(save_as_png_menu, VALUE='Snapshot', $
                          EVENT_PRO='CRISPEX_SAVE_PNG_SNAPSHOT')
	save_as_png_all		  = WIDGET_BUTTON(save_as_png_menu, VALUE='All frames', $
                          EVENT_PRO='CRISPEX_SAVE_PNG_ALL_FRAMES', SENSITIVE=(hdr.mainnt GT 1))
	save_as_png_linescan= WIDGET_BUTTON(save_as_png_menu, VALUE='Line scan', $
                          EVENT_PRO='CRISPEX_SAVE_PNG_LINESCAN', SENSITIVE=(hdr.nlp GT 1))
	save_as_jpg_menu	  = WIDGET_BUTTON(save_as_menu, VALUE='JPEG', /MENU)
	save_as_jpg_sns 	  = WIDGET_BUTTON(save_as_jpg_menu, VALUE='Snapshot', $
                          EVENT_PRO='CRISPEX_SAVE_JPEG_SNAPSHOT')
	save_as_jpg_all		  = WIDGET_BUTTON(save_as_jpg_menu, VALUE='All frames', $
                          EVENT_PRO='CRISPEX_SAVE_JPEG_ALL_FRAMES', SENSITIVE=(hdr.mainnt GT 1))
	save_as_jpg_linescan= WIDGET_BUTTON(save_as_jpg_menu, VALUE='Linescan', $
                          EVENT_PRO='CRISPEX_SAVE_JPEG_LINESCAN', SENSITIVE=(hdr.nlp GT 1))
	save_as_mpeg		    = WIDGET_BUTTON(filemenu, VALUE='Save movie...', $
                          EVENT_PRO='CRISPEX_SAVE_MPEG', SENSITIVE=(hdr.mainnt GT 1))
  ; View
  viewmenu            = WIDGET_BUTTON(menubar, VALUE='View', /MENU)
	sh_zoom_in		      = WIDGET_BUTTON(viewmenu, VALUE='Zoom in', EVENT_PRO='CRISPEX_ZOOMFAC_INCR',$
                          ACCELERATOR='Ctrl+Shift+I')
	sh_zoom_out		      = WIDGET_BUTTON(viewmenu, VALUE='Zoom out', EVENT_PRO='CRISPEX_ZOOMFAC_DECR',$
                          ACCELERATOR='Ctrl+Shift+O')
	focus_session_windows= WIDGET_BUTTON(viewmenu, VALUE='Bring all to front', /SEPARATOR, $
                          EVENT_PRO='CRISPEX_DISPLAYS_ALL_TO_FRONT', ACCELERATOR = 'Ctrl+F')
  ; Movie
  moviemenu           = WIDGET_BUTTON(menubar, VALUE='Movie', /MENU)
	sh_fbwd_button		  = WIDGET_BUTTON(moviemenu, VALUE='Step to previous frame', $
                          EVENT_PRO='CRISPEX_PB_FASTBACKWARD', ACCELERATOR='Shift+B')
	sh_backward_button	= WIDGET_BUTTON(moviemenu, VALUE='Play backwards', $
                          EVENT_PRO='CRISPEX_PB_BACKWARD', ACCELERATOR='Shift+Backspace')
	sh_pause_button		  = WIDGET_BUTTON(moviemenu, VALUE='Pause', $
                          EVENT_PRO='CRISPEX_PB_PAUSE', ACCELERATOR='Shift+Space')
	sh_forward_button	  = WIDGET_BUTTON(moviemenu, VALUE='Play forwards', $
                          EVENT_PRO='CRISPEX_PB_FORWARD', ACCELERATOR='Shift+Tab')
	sh_ffwd_button		  = WIDGET_BUTTON(moviemenu, VALUE='Step to next frame', $
                          EVENT_PRO='CRISPEX_PB_FASTFORWARD', ACCELERATOR='Shift+F')
	sh_lp_incr_button 	= WIDGET_BUTTON(moviemenu, VALUE='Main '+$
                          STRLOWCASE(sp_h[heightset])+' position +', $
                          EVENT_PRO='CRISPEX_SLIDER_LP_INCR', ACCELERATOR='Shift+S', /SEPARATOR)
	sh_lp_decr_button 	= WIDGET_BUTTON(moviemenu, VALUE='Main '+$
                          STRLOWCASE(sp_h[heightset])+' position -', $
                          EVENT_PRO='CRISPEX_SLIDER_LP_DECR', ACCELERATOR='Shift+A')
	sh_lp_ref_incr_button= WIDGET_BUTTON(moviemenu, VALUE='Reference '+$
                          STRLOWCASE(sp_h[refheightset])+' position +', $
                          EVENT_PRO='CRISPEX_SLIDER_LP_REF_INCR', ACCELERATOR='Ctrl+S', $
                          SENSITIVE=hdr.showref)
	sh_lp_ref_decr_button= WIDGET_BUTTON(moviemenu, VALUE='Reference '+$
                          STRLOWCASE(sp_h[refheightset])+' position -', $
                          EVENT_PRO='CRISPEX_SLIDER_LP_REF_DECR', ACCELERATOR='Ctrl+A', $
                          SENSITIVE=hdr.showref)
  ; Analysis                       
  analysismenu        = WIDGET_BUTTON(menubar, VALUE='Analysis', /MENU)
	int_toggle_but		  = WIDGET_BUTTON(analysismenu, VALUE = 'Lightcurve plot', $
                          EVENT_PRO='CRISPEX_DISPLAYS_INT_TOGGLE', SENSITIVE=(hdr.mainnt GT 1))
  spacetimemenu       = WIDGET_BUTTON(analysismenu, VALUE='Space-time diagram options', /MENU)
  timeslicemenu		    = WIDGET_BUTTON(spacetimemenu, VALUE = 'Save current space-time diagram', $
                          /MENU, SENSITIVE=0)
	approxmenu		      = WIDGET_BUTTON(timeslicemenu, VALUE = 'Approximated loop', /MENU)
	save_app_slab_but	  = WIDGET_BUTTON(approxmenu, VALUE='All '+STRLOWCASE(sp_h[heightset])+$
                          ' positions', EVENT_PRO='CRISPEX_SAVE_APPROX_LOOPSLAB')
	save_app_slice_but	= WIDGET_BUTTON(approxmenu, VALUE='Current '+STRLOWCASE(sp_h[heightset])+$
                          ' position', EVENT_PRO='CRISPEX_SAVE_APPROX_LOOPSLICE')
	interpolmenu		    = WIDGET_BUTTON(timeslicemenu, VALUE='Interpolated loop', /MENU)
	save_ex_slab_but	  = WIDGET_BUTTON(interpolmenu, VALUE='All '+STRLOWCASE(sp_h[heightset])+$
                          ' positions', EVENT_PRO='CRISPEX_SAVE_EXACT_LOOPSLAB_CHECK')
	save_ex_slice_but	  = WIDGET_BUTTON(interpolmenu, VALUE='Current '+STRLOWCASE(sp_h[heightset])+$
                          ' position', EVENT_PRO='CRISPEX_SAVE_EXACT_LOOPSLICE')
	save_loop_pts		    = WIDGET_BUTTON(spacetimemenu, VALUE='Save current path for later retrieval', $
                          EVENT_PRO='CRISPEX_SAVE_LOOP_PTS', SENSITIVE=0)
	sel_saved_loop		  = WIDGET_BUTTON(spacetimemenu, VALUE='Save from selected path(s)', /SEPARATOR, $
                          EVENT_PRO='CRISPEX_RETRIEVE_LOOP_MENU', SENSITIVE=0)
	all_saved_loop		  = WIDGET_BUTTON(spacetimemenu, VALUE='Save from all paths', /MENU, SENSITIVE=0)
	all_saved_all_pos	  = WIDGET_BUTTON(all_saved_loop, VALUE='At all '+STRLOWCASE(sp_h[heightset])+$
                          ' positions', EVENT_PRO = 'CRISPEX_RETRIEVE_LOOP_ALL_LOOPSLAB')
	all_saved_sel_pos	  = WIDGET_BUTTON(all_saved_loop, VALUE = 'At saved '+$
                          STRLOWCASE(sp_h[heightset])+' position', $
                          EVENT_PRO='CRISPEX_RETRIEVE_LOOP_ALL_LOOPSLICE')
	det_file_loop		    = WIDGET_BUTTON(spacetimemenu, VALUE='From detection file...', $
                          EVENT_PRO='CRISPEX_RETRIEVE_DET_FILE_MENU')
  ; Help
  helpmenu            = WIDGET_BUTTON(menubar, VALUE='Help', /MENU)
	open_help		        = WIDGET_BUTTON(helpmenu, VALUE='Open online help', $
                          EVENT_PRO='CRISPEX_HELP', ACCELERATOR='Ctrl+H')
	mailbugmenu		      = WIDGET_BUTTON(helpmenu, VALUE='Submit a bug report', $
                          EVENT_PRO='CRISPEX_HELP_MAIL_BUG')
	mailsugmenu		      = WIDGET_BUTTON(helpmenu, VALUE='Submit a suggestion', $
                          EVENT_PRO='CRISPEX_HELP_MAIL_SUGGESTION')
  shortcuts           = WIDGET_BUTTON(helpmenu, VALUE='Show shortcuts', /SEPARATOR, $
                          EVENT_PRO='CRISPEX_HELP_SHORTCUTS')
  ; Help: Developer
	developermenu   		= WIDGET_BUTTON(helpmenu, VALUE = 'Developer', /MENU, /SEPARATOR, $
                          UVALUE='developer')
	sh_runtime_interrupt= WIDGET_BUTTON(developermenu, VALUE='Interrupt', $
                          EVENT_PRO='CRISPEX_INTERRUPT', ACCELERATOR='Ctrl+Shift+C')
	sh_runtime_verb_menu= WIDGET_BUTTON(developermenu, VALUE='Verbosity', /MENU, UVALUE='verbosity')
	sh_verb_0		        = WIDGET_BUTTON(sh_runtime_verb_menu, VALUE='No verbosity', $
                          EVENT_PRO='CRISPEX_VERBOSE_SET', UVALUE=-1, /NO_RELEASE, /CHECKED_MENU, $
                          ACCELERATOR='Shift+0')
	sh_verb_4		        = WIDGET_BUTTON(sh_runtime_verb_menu, VALUE='Basic runtime verbosity', $
                          EVENT_PRO='CRISPEX_VERBOSE_SET', UVALUE=2, /NO_RELEASE, /CHECKED_MENU, $
                          ACCELERATOR='Shift+4')
	sh_verb_8		        = WIDGET_BUTTON(sh_runtime_verb_menu, VALUE='Extended runtime verbosity', $
                          EVENT_PRO='CRISPEX_VERBOSE_SET', UVALUE=3, /NO_RELEASE, /CHECKED_MENU, $
                          ACCELERATOR='Shift+8')
	sh_verb_16		      = WIDGET_BUTTON(sh_runtime_verb_menu, VALUE='Enable playback statistics', $
                          EVENT_PRO='CRISPEX_VERBOSE_SET', UVALUE=4, /NO_RELEASE, /CHECKED_MENU, $
                          ACCELERATOR='Shift+P')
  clear_menu		      = WIDGET_BUTTON(developermenu, VALUE='Clear', /MENU)
	clear_current_estimate= WIDGET_BUTTON(clear_menu, VALUE='Current time estimate', $
                          EVENT_PRO='CRISPEX_CLEAR_CURRENT_ESTIMATE', SENSITIVE=estimate_run)
	clear_current_cpft	= WIDGET_BUTTON(clear_menu, VALUE='CPFT file for current machine', $
                          EVENT_PRO='CRISPEX_CLEAR_CURRENT_CPFT', SENSITIVE=(cpftfilecount EQ 1))
	clear_current_inst	= WIDGET_BUTTON(clear_menu, VALUE='Instance file for current machine', $
                          EVENT_PRO='CRISPEX_CLEAR_CURRENT_INST', SENSITIVE=(instfilecount EQ 1))
	dispwid			        = WIDGET_BUTTON(developermenu, VALUE='Display window IDs', $
                          EVENT_PRO='CRISPEX_DISPWIDS', ACCELERATOR='Ctrl+I', /CHECKED_MENU)

  tab_width = 384
  pad = 3
	tab_tlb			= WIDGET_TAB(control_panel, LOCATION=0, MULTILINE=4, XSIZE=tab_width+2*pad)
 
  ; ==================== Define and order tabs ====================
	playback_tab        = WIDGET_BASE(tab_tlb, TITLE='Temporal', /COLUMN, XSIZE=tab_width)
	spectral_tab		    = WIDGET_BASE(tab_tlb, TITLE=sp_h[heightset], /COLUMN, XSIZE=tab_width)
	spatial_tab		      = WIDGET_BASE(tab_tlb, TITLE='Spatial', /COLUMN, XSIZE=tab_width)
	scaling_tab 		    = WIDGET_BASE(tab_tlb, TITLE='Scaling', /COLUMN, XSIZE=tab_width)
  diagnostics_tab     = WIDGET_BASE(tab_tlb, TITLE='Diagnostics', /COLUMN, XSIZE=tab_width)
	analysis_tab		    = WIDGET_BASE(tab_tlb, TITLE='Analysis',/COLUMN, XSIZE=tab_width)
	overlays_tab        = WIDGET_BASE(tab_tlb, TITLE='Overlays', /COLUMN, XSIZE=tab_width)
	display_tab		      = WIDGET_BASE(tab_tlb, TITLE='Displays', /COLUMN, XSIZE=tab_width)
  
  ; ==================== Always visible controls ====================
  ; Playback controls
	playback_contr		  = WIDGET_BASE(control_panel, /ROW)
	playback_field_basic= WIDGET_BASE(playback_contr, /FRAME, /GRID_LAYOUT, COLUMN=5)
	playback_field_add	= WIDGET_BASE(playback_contr, /FRAME, $
                          GRID_LAYOUT=(bmpbut_count EQ 16), COLUMN=3, EXCLUSIVE=(bmpbut_count NE 16))
	fbwd_button		      = WIDGET_BUTTON(playback_field_basic, VALUE = bmpbut_fbwd_idle, $
                          EVENT_PRO='CRISPEX_PB_FASTBACKWARD', TOOLTIP = 'Move one frame backward')
	backward_button		  = WIDGET_BUTTON(playback_field_basic, VALUE = bmpbut_bwd_idle, $
                          EVENT_PRO='CRISPEX_PB_BACKWARD', TOOLTIP = 'Play backward')
	pause_button		    = WIDGET_BUTTON(playback_field_basic, VALUE = bmpbut_pause_pressed, $
                          EVENT_PRO='CRISPEX_PB_PAUSE', TOOLTIP = 'Pause')
	forward_button		  = WIDGET_BUTTON(playback_field_basic, VALUE = bmpbut_fwd_idle, $
                          EVENT_PRO='CRISPEX_PB_FORWARD', TOOLTIP = 'Play forward')
	ffwd_button		      = WIDGET_BUTTON(playback_field_basic, VALUE = bmpbut_ffwd_idle, $
                          EVENT_PRO='CRISPEX_PB_FASTFORWARD', TOOLTIP = 'Move one frame forward')
	loop_button		      = WIDGET_BUTTON(playback_field_add, VALUE = bmpbut_loop_pressed, $
                          EVENT_PRO='CRISPEX_PB_LOOP', TOOLTIP = 'Loop')
	WIDGET_CONTROL, loop_button, SET_BUTTON = (bmpbut_count NE 16)
	cycle_button		    = WIDGET_BUTTON(playback_field_add, VALUE = bmpbut_cycle_idle, $
                          EVENT_PRO='CRISPEX_PB_CYCLE', TOOLTIP = 'Cycle')
	blink_button		    = WIDGET_BUTTON(playback_field_add, VALUE = bmpbut_blink_idle, $
                          EVENT_PRO='CRISPEX_PB_BLINK', TOOLTIP = 'Blink')
  tlp_slider_base     = WIDGET_BASE(control_panel, /GRID_LAYOUT, COLUMN=2)
	t_slid			        = WIDGET_SLIDER(tlp_slider_base, TITLE = 'Frame number', MIN=t_first, $
                          MAX=(t_last>(t_first+1)), VALUE=t_start, EVENT_PRO='CRISPEX_SLIDER_T', /DRAG, $
                          SENSITIVE=t_slid_sens, XSIZE=FLOOR((tab_width+2*pad)/2.))
  ; Spectral control
	lp_slid			        = WIDGET_SLIDER(tlp_slider_base, $
                          TITLE = 'Main '+STRLOWCASE(sp_h[heightset])+' position', MIN = lp_first, $
                          MAX = lp_last_slid, VALUE = lp_start, EVENT_PRO = 'CRISPEX_SLIDER_LP', $
					                /DRAG, SENSITIVE = lp_slid_sens)
  ; Cursor lock controls
	lock_field		      = WIDGET_BASE(control_panel, /FRAME, /ROW, /EXCLUSIVE)
	lockbut			        = WIDGET_BUTTON(lock_field, VALUE = 'Lock to position', $
                          EVENT_PRO = 'CRISPEX_CURSOR_LOCK', TOOLTIP = 'Lock cursor to current position')
	WIDGET_CONTROL, lockbut, SET_BUTTON = 0
	unlockbut		        = WIDGET_BUTTON(lock_field, VALUE = 'Unlock from position', $
                          TOOLTIP = 'Unlock cursor from current position')
	WIDGET_CONTROL, unlockbut, SET_BUTTON = 1
	
  ; ==================== Playback Tab ====================
  ; Temporal range base
  t_ranges		        = WIDGET_BASE(playback_tab, /COLUMN);, /FRAME, XSIZE=tab_width)
	t_range_field		    = WIDGET_BASE(t_ranges, /ROW, XSIZE=sub_tab_width)
	lower_t_label		    = WIDGET_LABEL(t_range_field, VALUE = 'Lower index:', /ALIGN_LEFT)
	lower_t_text		    = WIDGET_TEXT(t_range_field, VALUE = STRTRIM(t_first,2), /EDITABLE, $
                          XSIZE = 5, EVENT_PRO = 'CRISPEX_DISPRANGE_T_LOW', SENSITIVE = t_slid_sens)
	upper_t_label		    = WIDGET_LABEL(t_range_field, VALUE = 'Upper index:', /ALIGN_LEFT)
;	upper_t_text		    = WIDGET_TEXT(t_range_field, VALUE = STRTRIM(t_last_tmp,2),  /EDITABLE, $
	upper_t_text		    = WIDGET_TEXT(t_range_field, VALUE = STRTRIM(t_last,2),  /EDITABLE, $
                          XSIZE = 5, EVENT_PRO = 'CRISPEX_DISPRANGE_T_UPP', SENSITIVE = t_slid_sens)
	reset_trange_but	  = WIDGET_BUTTON(t_range_field, VALUE = '  Reset  ', $
                          EVENT_PRO = 'CRISPEX_DISPRANGE_T_RESET', SENSITIVE = 0)
  playback_divider1   = CRISPEX_WIDGET_DIVIDER(playback_tab)
	slice_update_but	  = WIDGET_BUTTON(playback_tab, $
                          VALUE='Update '+STRLOWCASE(sp_h[heightset])+' windows', $
                          EVENT_PRO = 'CRISPEX_UPDATE_SLICES', SENSITIVE = 0)
	t_speed_slid		    = WIDGET_SLIDER(playback_tab, TITLE = 'Animation speed [frame/s]', MIN = 1, $
                          MAX = 100, VALUE = t_speed, EVENT_PRO = 'CRISPEX_SLIDER_SPEED', /DRAG)
	t_step_slid		      = WIDGET_SLIDER(playback_tab, TITLE = 'Frame increment', MIN = 1, $
                          MAX = (t_last>2), VALUE = t_step, EVENT_PRO = 'CRISPEX_SLIDER_STEP', $
                          SENSITIVE = t_slid_sens)
	imref_blink_field	  = WIDGET_BASE(playback_tab, /ROW,/NONEXCLUSIVE)
	imref_blink_but		  = WIDGET_BUTTON(imref_blink_field, $
                          VALUE = 'Blink between main and reference image', $
                          EVENT_PRO = 'CRISPEX_DISPLAYS_IMREFBLINK_TOGGLE', SENSITIVE = hdr.showref)
  playback_divider2   = CRISPEX_WIDGET_DIVIDER(playback_tab)
  ; Master timing base
  master_time_base    = WIDGET_BASE(playback_tab, /COLUMN);, XSIZE=sub_tab_width)
  master_time_opts    = WIDGET_BASE(master_time_base, /ROW)
  master_time_lab     = WIDGET_LABEL(master_time_opts, VALUE='Master time:', /ALIGN_LEFT)
  master_time_labels  = ['Main', 'Reference', 'SJI']
  master_time_buts    = CW_BGROUP(master_time_opts, master_time_labels, $
                          BUTTON_UVALUE=INDGEN(N_ELEMENTS(master_time_labels)), IDS=master_time_ids, $
                          /EXCLUSIVE, /ROW, EVENT_FUNC='CRISPEX_BGROUP_MASTER_TIME', /NO_RELEASE)
  showdata = [(hdr.showref OR hdr.sjifile), hdr.showref, hdr.sjifile]
  nrasterdims = [SIZE(hdr.tarr_raster_main,/N_DIMENSIONS), $
                  SIZE(hdr.tarr_raster_ref,/N_DIMENSIONS), 1]
  setbutton = [1,0,0]
  FOR i=0,N_ELEMENTS(master_time_labels)-1 DO $
    WIDGET_CONTROL, master_time_ids[i], SET_BUTTON=setbutton[i], $
    SENSITIVE=(showdata[i] AND (nrasterdims[i] GE 1))
  ; Raster (nx>1) without time evolution or raster/sit-and-stare with time evolution
  IF (((nrasterdims[0] EQ 1) AND (hdr.nx GT 1) AND (hdr.mainnt EQ 1)) OR $  
    (nrasterdims[0] EQ 2)) THEN $                     
    toffset_max = N_ELEMENTS(hdr.tarr_raster_main[*,0])-1 $
  ELSE $
    toffset_max = 1
  time_offset_slid  = WIDGET_SLIDER(playback_tab, $
                        TITLE='Raster timing offset [raster position]', $
                        VALUE=hdr.toffset_main, MIN=0, MAX=toffset_max>1,$
                        EVENT_PRO='CRISPEX_SLIDER_TIME_OFFSET', $
                        SENSITIVE=((toffset_max GT 1) AND (TOTAL(showdata) GT 1)), /DRAG)
  playback_divider3 = CRISPEX_WIDGET_DIVIDER(playback_tab)

  ; ==================== Spectral Tab ====================
  ; Spectral range base
	lp_ranges		        = WIDGET_BASE(spectral_tab, /COLUMN);, /FRAME)
	lp_range_field		  = WIDGET_BASE(lp_ranges, /ROW)
	lower_lp_label		  = WIDGET_LABEL(lp_range_field, VALUE = 'Lower index:', /ALIGN_LEFT)
	lower_lp_text		    = WIDGET_TEXT(lp_range_field, VALUE = STRTRIM(lp_first,2), /EDITABLE, $
                          XSIZE = 5, EVENT_PRO = 'CRISPEX_DISPRANGE_LP_LOW', $
                          SENSITIVE = lp_blink_vals_sens)
	upper_lp_label		  = WIDGET_LABEL(lp_range_field, VALUE = 'Upper index:', /ALIGN_LEFT)
	upper_lp_text		    = WIDGET_TEXT(lp_range_field, VALUE = STRTRIM(lp_last_vals,2),  /EDITABLE, $
                          XSIZE = 5, EVENT_PRO = 'CRISPEX_DISPRANGE_LP_UPP', $
                          SENSITIVE = lp_blink_vals_sens)
	reset_lprange_but	  = WIDGET_BUTTON(lp_range_field, $
                          VALUE = '  Reset  ',$
                          EVENT_PRO = 'CRISPEX_DISPRANGE_LP_RESET', SENSITIVE = 0)
  spectral_divider1   = CRISPEX_WIDGET_DIVIDER(spectral_tab)
  ; Spectral blink base
	lp_blink_field		  = WIDGET_BASE(spectral_tab, /ROW,/NONEXCLUSIVE)
	lp_blink_but		    = WIDGET_BUTTON(lp_blink_field, $
                          VALUE = 'Blink between '+STRLOWCASE(sp_h[heightset])+' positions', $
                          EVENT_PRO = 'CRISPEX_PB_SPECTBLINK', SENSITIVE = lp_slid_sens)
	lp_blink_slid		    = WIDGET_SLIDER(spectral_tab, $
                          TITLE=sp_h[heightset]+' position to blink against', MIN=lp_first, $
                          MAX=lp_last_slid, VALUE=lp_start, EVENT_PRO='CRISPEX_SLIDER_SPECTBLINK', $
                          /DRAG, SENSITIVE = lp_blink_vals_sens)
  spectral_divider2   = CRISPEX_WIDGET_DIVIDER(spectral_tab)
  ; Reference spectral base
	lp_ref_but_field	  = WIDGET_BASE(spectral_tab, /ROW, /NONEXCLUSIVE)
	IF (heightset NE refheightset) THEN reflab = STRLOWCASE(sp_h[refheightset])+' ' ELSE reflab = ''
	lp_ref_but		      = WIDGET_BUTTON(lp_ref_but_field, VALUE = 'Lock reference '+reflab+'to main '+$
                          STRLOWCASE(sp_h[heightset])+' position', $
                          EVENT_PRO = 'CRISPEX_SLIDER_LP_REF_LOCK', SENSITIVE = lp_ref_lock) 
	WIDGET_CONTROL, lp_ref_but, SET_BUTTON = lp_ref_lock 
	lp_ref_slid         = WIDGET_SLIDER(spectral_tab, $
                          TITLE = 'Reference '+STRLOWCASE(sp_h[refheightset])+' position', $
                          MIN = lp_ref_first, MAX = lp_ref_last, VALUE = lp_ref_start, $
                          EVENT_PRO = 'CRISPEX_SLIDER_LP_REF', /DRAG, $
                          SENSITIVE = (refslid_sens AND ABS(eqnlps-1)))
  spectral_divider3   = CRISPEX_WIDGET_DIVIDER(spectral_tab)
  ; Phi-slit base
	slit_label		      = WIDGET_LABEL(spectral_tab, VALUE = 'Slit controls:', /ALIGN_LEFT)
  phi_slid_base       = WIDGET_BASE(spectral_tab, /GRID_LAYOUT, COLUMN=2, /ALIGN_CENTER) 
	phi_slid		        = WIDGET_SLIDER(phi_slid_base, TITLE = 'Slit angle [degrees]', MIN = 0, MAX = 179, $
                          VALUE=angle, EVENT_PRO = 'CRISPEX_SLIDER_PHI_ANGLE', SENSITIVE=0, /DRAG, $
                          XSIZE=FLOOR((tab_width-2*pad)/2.))
	nphi_slid		        = WIDGET_SLIDER(phi_slid_base, TITLE = 'Slit length [pixel]', MIN = 2, MAX = nphi, $
                          VALUE=LONG(hdr.ny/3.), EVENT_PRO = 'CRISPEX_SLIDER_NPHI', SENSITIVE = 0, /DRAG)
	slit_move_field		  = WIDGET_BASE(spectral_tab,/GRID_LAYOUT, COLUMN=2,/ALIGN_CENTER)
	bwd_move_slit		    = WIDGET_BUTTON(slit_move_field, VALUE = '< Move slit backwards', $
                          EVENT_PRO = 'CRISPEX_PHISLIT_MOVE_BWD', SENSITIVE= 0, $
                          TOOLTIP = 'Move slit backward along slit direction')
	fwd_move_slit		    = WIDGET_BUTTON(slit_move_field, VALUE = 'Move slit forwards >', $
                          EVENT_PRO = 'CRISPEX_PHISLIT_MOVE_FWD', SENSITIVE = 0, $
                          TOOLTIP = 'Move slit forward along slit direction')

  ; ==================== Spatial Tab ====================
  ; Cursor base 
  main_slid_base      = WIDGET_BASE(spatial_tab, /GRID_LAYOUT, COLUMN=2)
	x_slid			        = WIDGET_SLIDER(main_slid_base, $
                          TITLE='Main X-position [pixel]', MIN=x_first, $
                          MAX=(x_last > 1), VALUE=x_start, $
                          EVENT_PRO='CRISPEX_SLIDER_X', /DRAG, $
                          SENSITIVE=(x_last GT x_first),$
                          XSIZE=FLOOR((tab_width-2*pad)/2.))
	y_slid			        = WIDGET_SLIDER(main_slid_base, $
                          TITLE='Main Y-position [pixel]', MIN=y_first, $
                          MAX=(y_last > 1), VALUE=y_start, $
                          EVENT_PRO='CRISPEX_SLIDER_Y', /DRAG, $
                          SENSITIVE=(y_last GT y_first),$
                          XSIZE=FLOOR((tab_width-2*pad)/2.))
  ref_slid_base       = WIDGET_BASE(spatial_tab, /GRID_LAYOUT, COLUMN=2)
	xref_slid			      = WIDGET_SLIDER(ref_slid_base, $
                          TITLE='Reference X-position [pixel]', MIN=xref_first, $
                          MAX=(xref_last > 1), VALUE=xref_start, $
                          EVENT_PRO='CRISPEX_SLIDER_XREF', /DRAG, $
                          SENSITIVE=((xref_last GT xref_first) AND $
                          (hdr.main2ref_no_map EQ 0)),$
                          XSIZE=FLOOR((tab_width-2*pad)/2.))
	yref_slid			      = WIDGET_SLIDER(ref_slid_base, $
                          TITLE='Reference Y-position [pixel]', MIN=yref_first, $
                          MAX=(yref_last > 1), VALUE=yref_start, $
                          EVENT_PRO='CRISPEX_SLIDER_YREF', /DRAG, $
                          SENSITIVE=((yref_last GT yref_first) AND $
                          (hdr.main2ref_no_map EQ 0)),$
                          XSIZE=FLOOR((tab_width-2*pad)/2.))
  spatial_divider1    = CRISPEX_WIDGET_DIVIDER(spatial_tab)
  ; Zoom base
	zoom_frame		      = WIDGET_BASE(spatial_tab, /ROW)
	zoom_label		      = WIDGET_LABEL(zoom_frame, VALUE = 'Zoom:', /ALIGN_LEFT)
	zoom_but_field      = WIDGET_BASE(zoom_frame, /ROW )
	zoom_buts	          = CW_BGROUP(zoom_but_field,STRTRIM(FIX(zoomfactors),2)+REPLICATE('x',$
                          N_ELEMENTS(zoomfactors)), BUTTON_UVALUE=INDGEN(N_ELEMENTS(zoomfactors)), $
                          IDS=zoom_button_ids,/EXCLUSIVE, /ROW, $
                          EVENT_FUNC = 'CRISPEX_BGROUP_ZOOMFAC_SET')
  spatial_divider2    = CRISPEX_WIDGET_DIVIDER(spatial_tab)

  ; ==================== Diagnostics Tab ====================
  ; Stokes part
	stokes_disp_label		= WIDGET_LABEL(diagnostics_tab, VALUE = 'Stokes parameter:', /ALIGN_LEFT)
	stokes_main			    = WIDGET_BASE(diagnostics_tab, /ROW)
	stokes_main_label		= WIDGET_LABEL(stokes_main, VALUE = 'Main image:',/ALIGN_LEFT)
	stokes_xy_but_field = WIDGET_BASE(stokes_main, /ROW )
  stokes_button_labels= ['I','Q','U','V']
  stokes_xy_buts      = CW_BGROUP(stokes_xy_but_field, stokes_button_labels, $
                          BUTTON_UVALUE=INDGEN(N_ELEMENTS(stokes_button_labels)), IDS=stokes_button_ids,$
                          /EXCLUSIVE, /ROW, EVENT_FUNC = 'CRISPEX_BGROUP_STOKES_SELECT_XY')
	stokes_sp			      = WIDGET_BASE(diagnostics_tab, /ROW)
	stokes_sp_label		  = WIDGET_LABEL(stokes_sp, VALUE = 'Detailed spectra:',/ALIGN_LEFT)
  stokes_sp_buts      = CW_BGROUP(stokes_sp, stokes_button_labels, $
                          BUTTON_UVALUE=INDGEN(N_ELEMENTS(stokes_button_labels)), $
                          IDS=stokes_spbutton_ids, /NONEXCLUSIVE, /ROW, $
                          EVENT_FUNC = 'CRISPEX_BGROUP_STOKES_SELECT_SP')
  diagnostics_divider1= CRISPEX_WIDGET_DIVIDER(diagnostics_tab)
  ; Setting Stokes buttons
	spconstraint		= (hdr.nlp GT 1)
  FOR i=0,N_ELEMENTS(stokes_button_labels)-1 DO BEGIN
    WIDGET_CONTROL, stokes_button_ids[i], SENSITIVE=hdr.stokes_enabled[i], SET_BUTTON=(i EQ 0)
    IF (hdr.multichannel OR (i GT 0)) THEN $
      set_constraint = (spconstraint AND hdr.stokes_enabled[i]) $
    ELSE $
      set_constraint = spconstraint
    WIDGET_CONTROL, stokes_spbutton_ids[i], SENSITIVE=(spconstraint AND hdr.stokes_enabled[i]), $
      SET_BUTTON=set_constraint
  ENDFOR
  ; Spectral window part
  specwin_disp_label  = WIDGET_LABEL(diagnostics_tab, VALUE = 'Spectral windows:', /ALIGN_LEFT)
  specwin_sub_frame   = WIDGET_BASE(diagnostics_tab, /GRID_LAYOUT, COLUMN=2)
  main_select_base    = WIDGET_BASE(specwin_sub_frame,/COLUMN,/FRAME, $
                          Y_SCROLL_SIZE=(hdr.ndiagnostics GT 1)*200, $
                          X_SCROLL_SIZE=FLOOR(tab_width/2.5))
	main_specwin_label  = WIDGET_LABEL(main_select_base, VALUE = 'Main:', /ALIGN_LEFT)
  IF (hdr.ndiagnostics GT 1) THEN $
    vals = ['Display all',hdr.diagnostics] $
  ELSE $
    vals = 'Display all'
  specwin_buts        = CW_BGROUP(main_select_base, vals, $
                          BUTTON_UVALUE=INDGEN(N_ELEMENTS(vals)), IDS=specwin_button_ids, $
                          /NONEXCLUSIVE, /COLUMN, EVENT_FUNC='CRISPEX_BGROUP_DIAGNOSTICS_SELECT')
  FOR i=0,N_ELEMENTS(vals)-1 DO $
    WIDGET_CONTROL, specwin_button_ids[i], SENSITIVE=(i GT 0), /SET_BUTTON
  ref_select_base     = WIDGET_BASE(specwin_sub_frame,/COLUMN,/FRAME, $
                          Y_SCROLL_SIZE=(hdr.nrefdiagnostics GT 1)*200, $
                          X_SCROLL_SIZE=FLOOR(tab_width/2.5))
	ref_specwin_label   = WIDGET_LABEL(ref_select_base, VALUE = 'Reference:', /ALIGN_LEFT)
  IF (hdr.nrefdiagnostics GT 1) THEN $
    vals = ['Display all',hdr.refdiagnostics] $
  ELSE IF hdr.showref THEN $
    vals = 'Display all' $
  ELSE $
    vals = 'N/A        '
  refspecwin_buts     = CW_BGROUP(ref_select_base, vals, $
                          BUTTON_UVALUE=INDGEN(N_ELEMENTS(vals)), IDS=refspecwin_button_ids, $
                          /NONEXCLUSIVE, /COLUMN, EVENT_FUNC='CRISPEX_BGROUP_REFDIAGNOSTICS_SELECT')
  FOR i=0,N_ELEMENTS(vals)-1 DO $
    WIDGET_CONTROL, refspecwin_button_ids[i], SENSITIVE=(i GT 0), /SET_BUTTON
  diagnostics_divider2= CRISPEX_WIDGET_DIVIDER(diagnostics_tab)

  ; ==================== Displays Tab ====================
  ; LS base
	detspect_label_imref= WIDGET_BASE(display_tab, /ROW)
	detspect_label		  = WIDGET_LABEL(detspect_label_imref, VALUE = lswintitle[heightset]+':',$
                          /ALIGN_LEFT, /DYNAMIC_RESIZE)
	detspect_imref		  = WIDGET_BASE(detspect_label_imref, /ROW, /EXCLUSIVE)
	detspect_im_but		  = WIDGET_BUTTON(detspect_imref, VALUE = 'Main', $
                          EVENT_PRO = 'CRISPEX_DISPLAYS_DETSPECT_IM_SELECT', /NO_RELEASE, $
                          SENSITIVE = (hdr.nlp GT 1), $
					                TOOLTIP = 'Main '+STRLOWCASE(lswintitle[heightset])+' display options')
	WIDGET_CONTROL, detspect_im_but, SET_BUTTON = (hdr.nlp GT 1)
	detspect_ref_but	  = WIDGET_BUTTON(detspect_imref, VALUE = 'Reference', $
                          EVENT_PRO = 'CRISPEX_DISPLAYS_DETSPECT_REF_SELECT', /NO_RELEASE, $
                          SENSITIVE = showrefls, $
                          TOOLTIP = 'Reference '+STRLOWCASE(lswintitle[refheightset])+' display options')
	detspect_buts		    = WIDGET_BASE(display_tab, /ROW, /NONEXCLUSIVE)
	ls_toggle_but		    = WIDGET_BUTTON(detspect_buts, $
                          VALUE = 'Display '+STRLOWCASE(lswintitle[heightset]), $
                          EVENT_PRO = 'CRISPEX_DISPLAYS_IMREF_LS_TOGGLE', /DYNAMIC_RESIZE)
	subtract_but		    = WIDGET_BUTTON(detspect_buts, VALUE = 'Subtract average', $
                          EVENT_PRO = 'CRISPEX_DISPRANGE_LS_SUBTRACT', $
                          TOOLTIP = 'Subtract detailed spectrum from average spectrum')
	detspect_range		  = WIDGET_BASE(display_tab, /ROW)
	lower_y_label		    = WIDGET_LABEL(detspect_range, VALUE = 'Lower y-value:', /ALIGN_LEFT)
	lower_y_text		    = WIDGET_TEXT(detspect_range, VALUE = STRTRIM(ls_low_y_init,2), /EDITABLE, $
                          XSIZE = 5, EVENT_PRO = 'CRISPEX_DISPRANGE_LS_LOW')
	upper_y_label		    = WIDGET_LABEL(detspect_range, VALUE = 'Upper y-value:', /ALIGN_LEFT)
	upper_y_text		    = WIDGET_TEXT(detspect_range, VALUE = STRTRIM(ls_upp_y_init,2), /EDITABLE, $
                          XSIZE = 5, EVENT_PRO = 'CRISPEX_DISPRANGE_LS_UPP')
	scale_detspect_buts = WIDGET_BASE(display_tab, /ROW, /NONEXCLUSIVE)
	scale_detspect_but  = WIDGET_BUTTON(scale_detspect_buts, $
                          VALUE='Scale '+STRLOWCASE(lswintitle[heightset])+' to maximum of average',$
                          EVENT_PRO = 'CRISPEX_DISPRANGE_LS_SCALE_SELECT', $
					                SENSITIVE = detspect_scale_enable, /DYNAMIC_RESIZE)
	WIDGET_CONTROL, scale_detspect_but, SET_BUTTON = detspect_scale
  displays_divider1   = CRISPEX_WIDGET_DIVIDER(display_tab)
  ; Other displays base
	other_label		      = WIDGET_LABEL(display_tab, VALUE = 'Other displays:', /ALIGN_LEFT)
	images_disp		      = WIDGET_BASE(display_tab, /ROW)
	images_label		    = WIDGET_LABEL(images_disp, VALUE = 'Images:')
	images_buts		      = WIDGET_BASE(images_disp, /ROW, /NONEXCLUSIVE)
	reference_but		    = WIDGET_BUTTON(images_buts, VALUE = 'Reference', $
                          EVENT_PRO = 'CRISPEX_DISPLAYS_REF_TOGGLE', SENSITIVE = hdr.showref, $
                          TOOLTIP = 'Toggle display reference image')
	WIDGET_CONTROL, reference_but, SET_BUTTON = hdr.showref
	doppler_but		      = WIDGET_BUTTON(images_buts, VALUE = 'Doppler', $
                          EVENT_PRO='CRISPEX_DISPLAYS_DOPPLER_TOGGLE', SENSITIVE = (hdr.nlp GT 1), $
                          TOOLTIP = 'Toggle display Doppler image')
  sji_but             = WIDGET_BUTTON(images_buts, VALUE = 'Slit-jaw', $
                          EVENT_PRO='CRISPEX_DISPLAYS_SJI_TOGGLE', SENSITIVE = hdr.sjifile, $
                          TOOLTIP='Toggle display slit-jaw image')
  WIDGET_CONTROL, sji_but, SET_BUTTON = hdr.sjifile
	other_disp		      = WIDGET_BASE(display_tab, /COLUMN, /NONEXCLUSIVE)
	sp_toggle_but		    = WIDGET_BUTTON(other_disp, VALUE = but_tooltip[heightset]+'-time diagram', $
                          EVENT_PRO = 'CRISPEX_DISPLAYS_SP_TOGGLE', $
                          TOOLTIP = 'Toggle display temporal '+STRLOWCASE(but_tooltip[heightset]))
	phis_toggle_but		  = WIDGET_BUTTON(other_disp, VALUE = but_tooltip[heightset]+' along a slit', $
                          EVENT_PRO = 'CRISPEX_DISPLAYS_PHIS_TOGGLE', $
                          TOOLTIP = 'Toggle display '+STRLOWCASE(but_tooltip[heightset])+' along a slit')
	refsp_toggle_but	  = WIDGET_BUTTON(other_disp, VALUE='Reference '+$$
                          STRLOWCASE(but_tooltip[refheightset])+'-time diagram',$
                          EVENT_PRO = 'CRISPEX_DISPLAYS_REFSP_TOGGLE', $        
                          TOOLTIP = 'Toggle display reference temporal '+$
                          STRLOWCASE(but_tooltip[refheightset]))
  displays_divider2   = CRISPEX_WIDGET_DIVIDER(display_tab)

  ; ==================== Scaling Tab ====================
  scaling_cbox        = WIDGET_COMBOBOX(scaling_tab, $
                          VALUE=['Main image','Reference image','Doppler image','Slit-jaw image'], $
                          EVENT_PRO='CRISPEX_SCALING_SELECT_DATA')
  imagescale_cbox     = WIDGET_COMBOBOX(scaling_tab, $
                          VALUE=['Based on first image','Based on current image','Per time step'],$
                          EVENT_PRO='CRISPEX_SCALING_SELECT_TYPE')
  diagscale_label_vals= REPLICATE('Spectral window: ',2*hdr.ndiagnostics+hdr.nrefdiagnostics+1)+$
                          [hdr.diagnostics,hdr.refdiagnostics,hdr.diagnostics,'N/A']
  diagscale_label     = WIDGET_LABEL(scaling_tab, VALUE=diagscale_label_vals[0], /ALIGN_LEFT, $
                          /DYNAMIC_RESIZE)
  histo_base          = WIDGET_BASE(scaling_tab, /ROW)
  histo_opt_label     = WIDGET_LABEL(histo_base, VALUE='Histogram optimisation', /ALIGN_LEFT)
  histo_opt_txt       = WIDGET_TEXT(histo_base, VALUE=STRTRIM(histo_opt_val,2), /EDITABLE, $
                          XSIZE=11, EVENT_PRO='CRISPEX_SCALING_HISTO_OPT_VALUE')
  minmax_sliders      = WIDGET_BASE(scaling_tab, /GRID_LAYOUT, COLUMN=2)
  scalemin_slider     = WIDGET_SLIDER(minmax_sliders, TITLE='Image minimum [%]', MIN=0, MAX=99, $
                          VALUE=0, EVENT_PRO='CRISPEX_SCALING_SLIDER_MIN', /DRAG, $
                          XSIZE=FLOOR((tab_width-2*pad)/2.))
  scalemax_slider     = WIDGET_SLIDER(minmax_sliders, TITLE='Image maximum [%]', MIN=1, MAX=100, $
                          VALUE=100, EVENT_PRO='CRISPEX_SCALING_SLIDER_MAX', /DRAG)
  gamma_label         = WIDGET_LABEL(scaling_tab, VALUE=STRING(gamma_val, FORMAT='(F6.3)'), $
                          /ALIGN_CENTER,XSIZE=250)
  gamma_slider        = WIDGET_SLIDER(scaling_tab, TITLE='Gamma', MIN=0, MAX=1000, $
                          VALUE=500*(ALOG10(gamma_val)+1), EVENT_PRO='CRISPEX_SCALING_GAMMA_SLIDER', $
                          /SUPPRESS, /DRAG,XSIZE=250)
  reset_buts          = WIDGET_BASE(scaling_tab, /ROW, /GRID, /ALIGN_CENTER)
  scaling_reset_but   = WIDGET_BUTTON(reset_buts, VALUE='Reset current', $
                          EVENT_PRO='CRISPEX_SCALING_RESET_DEFAULTS', $
                          TOOLTIP='Reset scaling of current diagnostic to defaults')
  scaling_reset_all_but= WIDGET_BUTTON(reset_buts, VALUE='Reset all', $
                          EVENT_PRO='CRISPEX_SCALING_RESET_ALL_DEFAULTS', $
                          TOOLTIP='Reset scaling of all diagnostics to defaults', $
                          SENSITIVE=(hdr.ndiagnostics GT 1))
  scaling_divider1    = CRISPEX_WIDGET_DIVIDER(scaling_tab)
  ; LS scaling base
  ls_scale_opts       = WIDGET_BASE(scaling_tab, /COLUMN)
  ls_scale_label      = WIDGET_LABEL(ls_scale_opts, VALUE='Detailed spectrum:', /ALIGN_LEFT)
  ls_mult_opts        = WIDGET_BASE(ls_scale_opts, /ROW)
  ls_mult_label       = WIDGET_LABEL(ls_mult_opts, VALUE='Multiply', /ALIGN_LEFT, $
                          SENSITIVE=((hdr.ndiagnostics GT 1) OR (hdr.nrefdiagnostics GT 1)))
  IF (hdr.refdiagnostics[0] NE 'N/A') THEN $
    ls_mult_list  = [REPLICATE('Main ',hdr.ndiagnostics)+hdr.diagnostics, $
                      REPLICATE('Reference ',hdr.nrefdiagnostics)+hdr.refdiagnostics] $
  ELSE $
    ls_mult_list  = [REPLICATE('Main ',hdr.ndiagnostics)+hdr.diagnostics]
  ls_mult_cbox        = WIDGET_COMBOBOX(ls_mult_opts, VALUE=ls_mult_list, $
                          EVENT_PRO='CRISPEX_SCALING_MULTIPLY_LS_SELECT', /DYNAMIC_RESIZE, $
                          SENSITIVE=((hdr.ndiagnostics GT 1) OR (hdr.nrefdiagnostics GT 1)))
  ls_mult_by          = WIDGET_LABEL(ls_mult_opts, VALUE='by', /ALIGN_CENTER, $
                          SENSITIVE=((hdr.ndiagnostics GT 1) OR (hdr.nrefdiagnostics GT 1)))
  ls_mult_txt         = WIDGET_TEXT(ls_mult_opts, VALUE=STRTRIM(main_mult_val[0],2), /EDITABLE, $
                          XSIZE=5, EVENT_PRO='CRISPEX_SCALING_MULTIPLY_LS_VALUE', $
                          SENSITIVE=((hdr.ndiagnostics GT 1) OR (hdr.nrefdiagnostics GT 1)))
  scaling_divider2    = CRISPEX_WIDGET_DIVIDER(scaling_tab)
	
  ; ==================== Analysis Tab ====================
  ; Space-time diagram controls
	loop_label		      = WIDGET_LABEL(analysis_tab, VALUE = 'Space-time diagram along a path:', $
                          /ALIGN_LEFT)
	loop_but_frame		  = WIDGET_BASE(analysis_tab, /NONEXCLUSIVE, /GRID_LAYOUT, COLUMN=2)
	loop_slit_but		    = WIDGET_BUTTON(loop_but_frame, VALUE = 'Draw path  ', $
                          EVENT_PRO = 'CRISPEX_LOOP_DEFINE') 
	loop_feedb_but		  = WIDGET_BUTTON(loop_but_frame, VALUE = 'Path feedback', $
                          EVENT_PRO = 'CRISPEX_LOOP_FEEDBACK')
	WIDGET_CONTROL, loop_feedb_but, /SET_BUTTON
	loop_buts_frame		  = WIDGET_BASE(analysis_tab, /ROW)
	rem_loop_pt_but		  = WIDGET_BUTTON(loop_buts_frame, VALUE = 'Remove last loop point', $
                          EVENT_PRO = 'CRISPEX_LOOP_REMOVE_POINT', SENSITIVE = 0)
	loop_slice_but		  = WIDGET_BUTTON(loop_buts_frame, VALUE = 'Time slice along loop', $
                          EVENT_PRO = 'CRISPEX_DISPLAYS_LOOPSLAB_GET', SENSITIVE = 0)
  analysis_divider1   = CRISPEX_WIDGET_DIVIDER(analysis_tab)
  ; Measurement tool controls
	measure_label	      = WIDGET_LABEL(analysis_tab, VALUE = 'Spatial measurement tool:', /ALIGN_LEFT)
	measure_buts	      = WIDGET_BASE(analysis_tab, /ROW, /NONEXCLUSIVE)
	measure_but		      = WIDGET_BUTTON(measure_buts, VALUE = 'Start measurement', $
                          EVENT_PRO = 'CRISPEX_MEASURE_ENABLE')
	apix_base		        = WIDGET_BASE(analysis_tab, /ROW)
	apix_label		      = WIDGET_LABEL(apix_base, VALUE = 'Pixel size:', /ALIGN_LEFT, SENSITIVE = 0)
  IF hdr.dx_fixed THEN BEGIN
  	dx_text		        = WIDGET_LABEL(apix_base, VALUE=STRTRIM(hdr.dx,2), $
                          /ALIGN_LEFT, XSIZE=7, SENSITIVE=0) 
	  x_label		        = WIDGET_LABEL(apix_base, VALUE = 'X', /ALIGN_CENTER, SENSITIVE = 0)
  	dy_text		        = WIDGET_LABEL(apix_base, VALUE=STRTRIM(hdr.dy,2), $
                          /ALIGN_LEFT, XSIZE=7, SENSITIVE = 0) 
  ENDIF ELSE BEGIN
  	dx_text		= WIDGET_TEXT(apix_base, VALUE = STRTRIM(hdr.dx,2), /EDITABLE, XSIZE=7, $
                    EVENT_PRO = 'CRISPEX_MEASURE_DX', SENSITIVE = 0)
	  x_label		        = WIDGET_LABEL(apix_base, VALUE = 'X', /ALIGN_CENTER, SENSITIVE = 0)
  	dy_text		= WIDGET_TEXT(apix_base, VALUE = STRTRIM(hdr.dy,2), /EDITABLE, XSIZE=7, $
                    EVENT_PRO = 'CRISPEX_MEASURE_DY', SENSITIVE = 0)
  ENDELSE
	apix_unit		        = WIDGET_LABEL(apix_base, VALUE = '['+hdr.xunit+']', /ALIGN_LEFT, SENSITIVE = 0)
	measure_asec		    = WIDGET_BASE(analysis_tab, /ROW)
	measure_asec_lab	  = WIDGET_LABEL(measure_asec, VALUE = 'Distance [arcsec]:', /ALIGN_LEFT, $
                          SENSITIVE = 0)
	measure_asec_text	  = WIDGET_LABEL(measure_asec, VALUE = '0.00', /DYNAMIC_RESIZE, SENSITIVE = 0)
	measure_km		      = WIDGET_BASE(analysis_tab, /ROW)
	measure_km_lab		  = WIDGET_LABEL(measure_km, VALUE = 'Distance [km]:', /ALIGN_LEFT, SENSITIVE = 0)
	measure_km_text		  = WIDGET_LABEL(measure_km, VALUE = '0.00', /DYNAMIC_RESIZE, SENSITIVE = 0)
  analysis_divider2   = CRISPEX_WIDGET_DIVIDER(analysis_tab)

  ; ==================== Overlays Tab ====================
  ; Mask overlays base
  masks_overlay_label = WIDGET_LABEL(overlays_tab, VALUE='Mask:',/ALIGN_LEFT)
	masks_overlay		    = WIDGET_BASE(overlays_tab, /ROW)
	masks_overlay_label	= WIDGET_LABEL(masks_overlay, VALUE = 'Overlay on:',/ALIGN_LEFT)
	masks_overlay_buts	= CW_BGROUP(masks_overlay, ['Main','Reference','Doppler'],$
                          BUTTON_UVALUE=INDGEN(3),IDS=mask_button_ids,/NONEXCLUSIVE, /ROW, $
                          EVENT_FUNC = 'CRISPEX_BGROUP_MASK_OVERLAY')
	LOADCT,GET_NAMES=ctnames,/SILENT
	masks_overlay_ct_cbox= WIDGET_COMBOBOX(overlays_tab, $
                          VALUE = STRTRIM(INDGEN(N_ELEMENTS(ctnames)),2)+REPLICATE(': ',$
                          N_ELEMENTS(ctnames))+ctnames, $
                          EVENT_PRO = 'CRISPEX_MASK_OVERLAY_SELECT_COLOR_TABLE', $
                          SENSITIVE = maskfile)
	maskct = 13
	WIDGET_CONTROL, masks_overlay_ct_cbox, SET_COMBOBOX_SELECT = maskct
	masks_overlay_col_slid= WIDGET_SLIDER(overlays_tab, MIN = 0, MAX = 255, VALUE = 255, $
                            TITLE = 'Color index', EVENT_PRO='CRISPEX_MASK_OVERLAY_COLOR_SLIDER',$
                            /DRAG, SENSITIVE = maskfile)
  overlays_divider1   = CRISPEX_WIDGET_DIVIDER(overlays_tab)
  ; Loop overlays base                            
	overlay_label		    = WIDGET_LABEL(overlays_tab, VALUE = 'Paths:', /ALIGN_LEFT)
	overlay_buts		    = WIDGET_BASE(overlays_tab, /ROW)
	overlay_onebut		  = WIDGET_BASE(overlay_buts, /NONEXCLUSIVE)
	overlay_but 		    = WIDGET_BUTTON(overlay_onebut, VALUE = 'Saved paths:', $
                          EVENT_PRO = 'CRISPEX_RESTORE_LOOPS_MAIN')
	overlay_actbuts	    = WIDGET_BASE(overlay_buts, /ROW, /EXCLUSIVE)
	loop_overlay_al		  = WIDGET_BUTTON(overlay_actbuts, VALUE = 'Always', $
                          EVENT_PRO = 'CRISPEX_RESTORE_LOOPS_ALWAYS', SENSITIVE = 0)
	WIDGET_CONTROL, loop_overlay_al, SET_BUTTON = 1
	loop_overlay_sav	  = WIDGET_BUTTON(overlay_actbuts, $
                          VALUE = 'At saved '+STRLOWCASE(wav_h[heightset]), SENSITIVE = 0)
	linestyle_base		  = WIDGET_BASE(overlays_tab, /ROW)
	linestyle_label		  = WIDGET_LABEL(linestyle_base, VALUE = 'Paths linestyle:', /ALIGN_LEFT)
	linestyle_buts		  = WIDGET_BASE(linestyle_base, /ROW, /EXCLUSIVE)
	linestyle_0		      = WIDGET_BUTTON(linestyle_buts, VALUE = 'solid', $
                          EVENT_PRO = 'CRISPEX_DRAW_LOOP_LINESTYLE_0')
	linestyle_1		      = WIDGET_BUTTON(linestyle_buts, VALUE = 'dotted', $
                          EVENT_PRO = 'CRISPEX_DRAW_LOOP_LINESTYLE_1')
	linestyle_2		      = WIDGET_BUTTON(linestyle_buts, VALUE = 'dashed', $
                          EVENT_PRO = 'CRISPEX_DRAW_LOOP_LINESTYLE_2')
	WIDGET_CONTROL, linestyle_0, SET_BUTTON = 1
  overlays_divider2   = CRISPEX_WIDGET_DIVIDER(overlays_tab)
  ; Raster overlays base
  raster_overlay_label= WIDGET_LABEL(overlays_tab, VALUE='Raster:',/ALIGN_LEFT)
  raster_overlay      = WIDGET_BASE(overlays_tab, /COLUMN)
  raster_but_labels   = ['Overlay slit positions on reference image', $
                          'Overlay slit positions on slit-jaw image', $
                          'Overlay timing markers on rasters'] 
  raster_buts         = CW_BGROUP(raster_overlay, raster_but_labels, $
                          BUTTON_UVALUE=INDGEN(N_ELEMENTS(raster_but_labels)), $
                          IDS=raster_button_ids, $
                          /NONEXCLUSIVE, /COLUMN, $
                          EVENT_FUNC='CRISPEX_BGROUP_RASTER_OVERLAY')
  WIDGET_CONTROL, raster_button_ids[0], $
    SET_BUTTON=(hdr.showref AND ((nrasterdims[0] GT 1) OR (hdr.nx EQ 1))), $
    SENSITIVE=(hdr.showref AND ((nrasterdims[0] GT 1) OR (hdr.nx EQ 1)))
  WIDGET_CONTROL, raster_button_ids[1], $
    SET_BUTTON=(hdr.sjifile AND ((nrasterdims[0] GT 1) OR (hdr.nx EQ 1))),$
    SENSITIVE=(hdr.sjifile AND ((nrasterdims[0] GT 1) OR (hdr.nx EQ 1)))
  WIDGET_CONTROL, raster_button_ids[2], $
    SET_BUTTON=((nrasterdims[0] GT 1) OR (nrasterdims[1] GT 1)), $
    SENSITIVE=((nrasterdims[0] GT 1) OR (nrasterdims[1] GT 1))
  overlays_divider3   = CRISPEX_WIDGET_DIVIDER(overlays_tab)

  ; ==================== Parameters Overview ====================
    ; Position parameters
    params_position_base = WIDGET_BASE(control_panel, /ROW,/FRAME, /GRID_LAYOUT)
    verlabel_base = WIDGET_BASE(params_position_base, /COLUMN)
      no_label    = WIDGET_LABEL(verlabel_base, VALUE='Position', /ALIGN_LEFT)
      pixel_label = WIDGET_LABEL(verlabel_base, VALUE='Index [px]', /ALIGN_RIGHT)
      IF (hdr.wcs_set OR hdr.ref_wcs_set OR hdr.sji_wcs_set) THEN $
        real_label  = WIDGET_LABEL(verlabel_base, VALUE='Solar XY ["]', $
          /ALIGN_RIGHT) $
      ELSE $
        real_label  = WIDGET_LABEL(verlabel_base, VALUE='Value ["]', $
          /ALIGN_RIGHT) 
    params_main_base = WIDGET_BASE(params_position_base, /COLUMN)
      main_label  = WIDGET_LABEL(params_main_base, VALUE='Main', /ALIGN_RIGHT)
        xcoord_format = '(I'+STRTRIM(FLOOR(ALOG10(hdr.nx))+1,2)+')'
        ycoord_format = '(I'+STRTRIM(FLOOR(ALOG10(hdr.ny))+1,2)+')'
        coord_txt = '    ('+STRING(LONG(x_start),FORMAT=xcoord_format)+$
          ','+STRING(LONG(y_start),FORMAT=ycoord_format)+')'
		    xycoord_val = WIDGET_LABEL(params_main_base, VALUE=coord_txt, $
          /ALIGN_RIGHT)
        IF hdr.wcs_set THEN BEGIN
          xy_real = CRISPEX_TRANSFORM_GET_WCS(x_start, y_start, hdr.wcs_main, $
            /COORD, /NO_ROUND)
          xcoord_real_format = '(F6.1)'
          ycoord_real_format = '(F6.1)'
          real_coord_txt = '('+STRING(xy_real.x,FORMAT=xcoord_real_format)+$
            ','+STRING(xy_real.y,FORMAT=ycoord_real_format)+')'
        ENDIF ELSE BEGIN
          xcoord_real_format = '(F'+STRTRIM(FLOOR(ALOG10(hdr.nx*hdr.dx))+3+$
            (hdr.nx*hdr.dx LT 1),2)+'.1)'
          ycoord_real_format = '(F'+STRTRIM(FLOOR(ALOG10(hdr.ny*hdr.dy))+3+$
            (hdr.ny*hdr.dy LT 1),2)+'.1)'
          real_coord_txt = '('+STRING(FLOAT(x_start*hdr.dx),FORMAT=xcoord_real_format)+$
            ','+STRING(FLOAT(y_start*hdr.dy),FORMAT=ycoord_real_format)+')' 
        ENDELSE
		    xycoord_real_val = WIDGET_LABEL(params_main_base, VALUE=real_coord_txt, $
          /ALIGN_RIGHT)
    params_ref_base = WIDGET_BASE(params_position_base, /COLUMN, /ALIGN_RIGHT)
      ref_label   = WIDGET_LABEL(params_ref_base, VALUE='Reference', /ALIGN_RIGHT)
      IF hdr.showref THEN BEGIN
        refxcoord_format = '(I'+STRTRIM(FLOOR(ALOG10(hdr.refnx))+1,2)+')'
        refycoord_format = '(I'+STRTRIM(FLOOR(ALOG10(hdr.refny))+1,2)+')'
        refcoord_txt = '    ('+STRING(LONG(xref_start),FORMAT=refxcoord_format)+$
          ','+STRING(LONG(yref_start),FORMAT=refycoord_format)+')'
        IF hdr.ref_wcs_set THEN BEGIN
          xyref_real = CRISPEX_TRANSFORM_GET_WCS(xref_start, yref_start, hdr.wcs_ref, $
            /COORD, /NO_ROUND)
          refxcoord_real_format = '(F6.1)'
          refycoord_real_format = '(F6.1)'
          refcoord_real_txt = '('+STRING(xyref_real.x,FORMAT=refxcoord_real_format)+$
            ','+STRING(xyref_real.y,FORMAT=refycoord_real_format)+')'
        ENDIF ELSE BEGIN
          refxcoord_real_format = '(F'+STRTRIM(FLOOR(ALOG10(hdr.refnx*hdr.dx))+3+$
            (hdr.refnx*hdr.dx LT 1),2)+'.1)'
          refycoord_real_format = '(F'+STRTRIM(FLOOR(ALOG10(hdr.refny*hdr.dy))+3+$
            (hdr.refny*hdr.dy LT 1),2)+'.1)'
          refcoord_real_txt = '('+STRING(FLOAT(xref_start*hdr.dx),FORMAT=refxcoord_real_format)+$
            ','+STRING(FLOAT(yref_start*hdr.dy),FORMAT=refycoord_real_format)+')'
        ENDELSE
      ENDIF ELSE BEGIN
        refcoord_txt = 'N/A'
        refxcoord_format = ''
        refycoord_format = ''
        refcoord_real_txt = 'N/A'
        refxcoord_real_format = ''
        refycoord_real_format = ''
      ENDELSE
		  refxycoord_val = WIDGET_LABEL(params_ref_base, VALUE=refcoord_txt, $
        /ALIGN_RIGHT)
		  refxycoord_real_val = WIDGET_LABEL(params_ref_base, VALUE=refcoord_real_txt, $
        /ALIGN_RIGHT)
    params_sji_base = WIDGET_BASE(params_position_base, /COLUMN, /ALIGN_RIGHT)
      sji_label   = WIDGET_LABEL(params_sji_base, VALUE='Slit-jaw', /ALIGN_RIGHT)
      IF hdr.sjifile THEN BEGIN
        sjixcoord_format = '(I'+STRTRIM(FLOOR(ALOG10(hdr.sjinx))+1,2)+')'
        sjiycoord_format = '(I'+STRTRIM(FLOOR(ALOG10(hdr.sjiny))+1,2)+')'
        sjicoord_txt = '    ('+STRING(LONG(xsji_start),FORMAT=sjixcoord_format)+$
          ','+STRING(LONG(ysji_start),FORMAT=sjiycoord_format)+')'
        IF hdr.sji_wcs_set THEN BEGIN
          xysji_real = CRISPEX_TRANSFORM_GET_WCS(xsji_start, ysji_start, hdr.wcs_sji, $
            /COORD, /NO_ROUND)
          sjixcoord_real_format = '(F6.1)'
          sjiycoord_real_format = '(F6.1)'
          sjicoord_real_txt = '('+STRING(xysji_real.x,FORMAT=sjixcoord_real_format)+$
            ','+STRING(xysji_real.y,FORMAT=sjiycoord_real_format)+')'
        ENDIF ELSE BEGIN
          sjixcoord_real_format = '(F'+STRTRIM(FLOOR(ALOG10(hdr.sjinx*hdr.sjidx))+3,2)+'.1)'
          sjiycoord_real_format = '(F'+STRTRIM(FLOOR(ALOG10(hdr.sjiny*hdr.sjidy))+3,2)+'.1)'
          sjicoord_real_txt = '('+STRING(FLOAT(xsji_start*hdr.sjidx),$
            FORMAT=sjixcoord_real_format)+'",'+STRING(FLOAT(ysji_start*hdr.sjidy),$
            FORMAT=sjiycoord_real_format)+'")'
        ENDELSE
      ENDIF ELSE BEGIN
        sjicoord_txt = 'N/A'
        sjixcoord_format = ''
        sjiycoord_format = ''
        sjicoord_real_txt = 'N/A'
        sjixcoord_real_format = ''
        sjiycoord_real_format = ''
      ENDELSE
		  sjixycoord_val = WIDGET_LABEL(params_sji_base, VALUE=sjicoord_txt, $
        /ALIGN_RIGHT)
		  sjixycoord_real_val = WIDGET_LABEL(params_sji_base, VALUE=sjicoord_real_txt, $
        /ALIGN_RIGHT)

    ; Spectral parameters
;      divider_label = WIDGET_LABEL(verlabel_base, VALUE=' ')
      no_label    = WIDGET_LABEL(verlabel_base, VALUE=wav_h[heightset[0]], /ALIGN_LEFT)
      pixel_label = WIDGET_LABEL(verlabel_base, VALUE='Index [px]', /ALIGN_RIGHT)
		  IF ((TOTAL(heightset) GE 1) OR (TOTAL(hdr.v_dop_set) GE 1)) THEN $
        real_label  = WIDGET_LABEL(verlabel_base, VALUE='Value', /ALIGN_RIGHT)
      IF ((heightset[0] EQ 0) AND (TOTAL(hdr.v_dop_set) GE 1)) THEN $
        vdop_label  = WIDGET_LABEL(verlabel_base, VALUE='Doppler [km/s]', /ALIGN_RIGHT)
      main_label  = WIDGET_LABEL(params_main_base, VALUE=' ', /ALIGN_RIGHT)
      lp_idx_format = '(I'+STRTRIM(FLOOR(ALOG10(hdr.nlp))+1,2)+')'
      IF hdr.v_dop_set[0] THEN BEGIN
        lp_real_format = '(F'+STRTRIM(FLOOR(ALOG10(hdr.lps[lp_last]))+3,2)+'.1)'
        lp_vdop_format = '(F'+STRTRIM(FLOOR(ALOG10(hdr.lps[lp_last]))+4,2)+'.2)'
        lp_real_txt = STRING(hdr.lps[lp_start], FORMAT=lp_real_format)
        lp_vdop_txt = STRING((*hdr.v_dop[0])[lp_start-hdr.diag_start[0]],$
          FORMAT=lp_vdop_format)
      ENDIF ELSE BEGIN
        lp_real_format = ''
        lp_vdop_format = ''
        lp_real_val = 0
        lp_vdop_val = 0
        lp_real_txt = 'N/A'
        lp_vdop_txt = 'N/A'
      ENDELSE
		  lp_idx_val = WIDGET_LABEL(params_main_base, VALUE=STRING(LONG(lp_start),$
        FORMAT=lp_idx_format), /ALIGN_RIGHT)
		  IF ((TOTAL(heightset) GE 1) OR (TOTAL(hdr.v_dop_set) GE 1)) THEN $
		    lp_real_val = WIDGET_LABEL(params_main_base, VALUE=lp_real_txt, /ALIGN_RIGHT)
		  IF (TOTAL(hdr.v_dop_set) GE 1) THEN $
        lp_vdop_val = WIDGET_LABEL(params_main_base, VALUE=lp_vdop_txt, /ALIGN_RIGHT)
      ref_label   = WIDGET_LABEL(params_ref_base, VALUE=' ', /ALIGN_RIGHT)
      IF (hdr.refnlp GT 1) THEN BEGIN
        lp_ref_idx_format = '(I'+STRTRIM(FLOOR(ALOG10(hdr.refnlp))+1,2)+')'
        lp_ref_idx_txt = STRING(LONG(lp_ref_start), FORMAT=lp_ref_idx_format)
      ENDIF ELSE BEGIN
        lp_ref_idx_format = ''
        lp_ref_idx_txt = 'N/A'
      ENDELSE
      IF ((hdr.refnlp GT 1) AND hdr.v_dop_set[1]) THEN BEGIN
        lp_ref_real_format = '(F'+STRTRIM(FLOOR(ALOG10(hdr.reflps[lp_ref_last]))+3,2)+'.1)'
        lp_ref_vdop_format = '(F'+STRTRIM(FLOOR(ALOG10(hdr.reflps[lp_ref_last]))+4,2)+'.2)'
        lp_ref_real_txt = STRING(hdr.reflps[lp_ref_start], FORMAT=lp_ref_real_format)
        lp_ref_vdop_txt = STRING((*hdr.v_dop_ref[0])[lp_ref_start-hdr.diag_start[0]],$
          FORMAT=lp_ref_vdop_format)
      ENDIF ELSE BEGIN
        lp_ref_real_format = ''
        lp_ref_vdop_format = ''
        lp_ref_real_val = 0
        lp_ref_vdop_val = 0
        lp_ref_real_txt = 'N/A'
        lp_ref_vdop_txt = 'N/A'
      ENDELSE
		  lp_ref_idx_val = WIDGET_LABEL(params_ref_base, VALUE=lp_ref_idx_txt, /ALIGN_RIGHT)
		  IF ((TOTAL(heightset) GE 1) OR (TOTAL(hdr.v_dop_set) GE 1)) THEN $
        lp_ref_real_val = WIDGET_LABEL(params_ref_base, VALUE=lp_ref_real_txt, $
          /ALIGN_RIGHT)
		  IF (TOTAL(hdr.v_dop_set) GE 1) THEN $
        lp_ref_vdop_val = WIDGET_LABEL(params_ref_base, VALUE=lp_ref_vdop_txt, $
          /ALIGN_RIGHT)
      ; SJI placeholders
      sji_label   = WIDGET_LABEL(params_sji_base, VALUE=' ', /ALIGN_RIGHT)
		  lp_sji_idx_val = WIDGET_LABEL(params_sji_base, VALUE=' ', /ALIGN_RIGHT)
		  IF ((TOTAL(heightset) GE 1) OR (TOTAL(hdr.v_dop_set) GE 1)) THEN $
        lp_sji_real_val = WIDGET_LABEL(params_sji_base, VALUE=' ', /ALIGN_RIGHT)
		  IF (TOTAL(hdr.v_dop_set) GE 1) THEN $
        lp_sji_vdop_val = WIDGET_LABEL(params_sji_base, VALUE=' ', /ALIGN_RIGHT)
    
    ; Time parameters
;    params_time_base = WIDGET_BASE(control_panel, /ROW,/FRAME)
;    verlabel_base = WIDGET_BASE(params_time_base, /COLUMN)
      no_label    = WIDGET_LABEL(verlabel_base, VALUE='Time', /ALIGN_LEFT)
      pixel_label = WIDGET_LABEL(verlabel_base, VALUE='Index [px]', /ALIGN_RIGHT)
      IF dt_set THEN BEGIN
        label_val = 'Value '
        IF ((hdr.date_obs_main NE '0') OR $
            (hdr.date_obs_ref NE '0') OR $
            (hdr.date_obs_sji NE '0')) THEN $
          label_val += '(UTC)' $
        ELSE $
          label_val += '[s]'
        real_label  = WIDGET_LABEL(verlabel_base, VALUE=label_val, /ALIGN_RIGHT)
      ENDIF
      raster_time_fb = ((N_ELEMENTS(hdr.tarr_raster_main) NE $
        N_ELEMENTS(hdr.tarr_main)))
      refraster_time_fb = ((N_ELEMENTS(hdr.tarr_raster_ref) NE $
        N_ELEMENTS(hdr.tarr_ref)))
      IF (raster_time_fb OR refraster_time_fb) THEN BEGIN
        label_val = 'Raster '
        IF ((hdr.date_obs_main NE '0') OR $
            (hdr.date_obs_ref NE '0') OR $
            (hdr.date_obs_sji NE '0')) THEN $
          label_val += '(UTC)' $
        ELSE $
          label_val += '[s]'
        raster_label = WIDGET_LABEL(verlabel_base, VALUE=label_val, /ALIGN_RIGHT)
      ENDIF
      ; ==================== Time feedback ==================== 
;    params_main_base = WIDGET_BASE(params_time_base, /COLUMN)
      main_label  = WIDGET_LABEL(params_main_base, VALUE=' ', /ALIGN_RIGHT)
      t_idx_format = '(I'+STRTRIM(FLOOR(ALOG10(hdr.mainnt))+1,2)+')'
		  t_idx_val = WIDGET_LABEL(params_main_base, VALUE=STRING(LONG(t_start),$
        FORMAT=t_idx_format), /ALIGN_RIGHT)
      ; -------------------- Main time feedback -------------------- 
      IF dt_set THEN BEGIN
        wheretgt0 = WHERE(hdr.tarr_main GT 0, count)
        IF (count GT 0) THEN $
          t_sel = wheretgt0[count-1] $
        ELSE $
          t_sel = 0
        IF (hdr.date_obs_main NE '0') THEN $
          t_real_format = '(A'+STRTRIM(STRLEN(hdr.utc_main[t_sel]),2)+')'  $
        ELSE $
          t_real_format = '(F'+STRTRIM(FLOOR(ALOG10(hdr.tarr_main[$
            t_sel]))+3,2)+'.1)' 
        t_real_txt = STRING(hdr.utc_main[t_start], FORMAT=t_real_format)
		    t_real_val = WIDGET_LABEL(params_main_base, VALUE=t_real_txt, /ALIGN_RIGHT)
      ENDIF ELSE BEGIN
        t_real_format = ''
        t_real_txt = 'N/A'
        t_real_val = 0
      ENDELSE
      ; -------------------- Main raster time feedback -------------------- 
      IF raster_time_fb THEN BEGIN
        ; Check where raster times greater than 0
        IF (hdr.mainnt GT 1) THEN $
          wheretgt0 = WHERE(hdr.tarr_raster_main[x_start,*] GT 0, count) $
        ELSE $
          wheretgt0 = WHERE(hdr.tarr_raster_main[x_start] GT 0, count)
        IF (count GT 0) THEN $
          t_sel = wheretgt0[count-1] $
        ELSE $
          t_sel = 0
        IF (hdr.date_obs_main NE '0') THEN BEGIN
          IF (hdr.mainnt GT 1) THEN $
            dumval = hdr.utc_raster_main[x_start,t_sel] $
          ELSE $
            dumval = hdr.utc_raster_main[x_start]
          t_raster_real_format = '(A'+STRTRIM(STRLEN(dumval),2)+')' 
        ENDIF ELSE BEGIN
          IF (hdr.mainnt GT 1) THEN $
            dumval = hdr.tarr_raster_main[x_start,t_sel] $
          ELSE $
            dumval = hdr.tarr_raster_main[x_start]
          t_raster_real_format = '(F'+STRTRIM(FLOOR(ALOG10(dumval))+3,2)+'.1)'
        ENDELSE
        t_raster_real_txt = STRING(dumval, FORMAT=t_raster_real_format)
      ENDIF ELSE BEGIN
        t_raster_real_format = ''
        t_raster_real_txt = 'N/A'
      ENDELSE
      IF (raster_time_fb OR refraster_time_fb) THEN $
        t_raster_real_val = WIDGET_LABEL(params_main_base, $
          VALUE=t_raster_real_txt, /ALIGN_RIGHT) $
      ELSE $
        t_raster_real_val = 0
      ; -------------------- Reference time feedback --------------------
      ref_label   = WIDGET_LABEL(params_ref_base, VALUE=' ', /ALIGN_RIGHT)
      IF hdr.showref THEN BEGIN
        t_ref_idx_format = '(I'+STRTRIM(FLOOR(ALOG10(hdr.refnt))+1,2)+')'
        t_ref_idx_txt = STRING(LONG(t_start), FORMAT=t_ref_idx_format)
        IF dt_set THEN BEGIN
          wheretgt0 = WHERE(hdr.tarr_ref GT 0, count)
          IF (count GT 0) THEN $
            t_sel = wheretgt0[count-1] $
          ELSE $
            t_sel = 0
          IF (hdr.date_obs_ref NE '0') THEN $
            t_ref_real_format = '(A'+STRTRIM(STRLEN(hdr.utc_ref[t_sel]),2)+')'  $
          ELSE BEGIN
            IF (hdr.refnt GT 1) THEN $
              t_ref_real_format = '(F'+STRTRIM(FLOOR(ALOG10(hdr.tarr_ref[$
                t_sel]))+3,2)+'.1)' $
            ELSE $
              t_ref_real_format = '(F3.1)'
          ENDELSE
          t_ref_real_txt = STRING(hdr.utc_ref[t_start], FORMAT=t_ref_real_format)
        ENDIF ELSE BEGIN
          t_ref_real_format = ''
          t_ref_real_txt = 'N/A'
          t_ref_real_val = 0
        ENDELSE
      ENDIF ELSE BEGIN
        t_ref_idx_format = ''
        t_ref_idx_txt = 'N/A'
        t_ref_real_format = ''
        t_ref_real_txt = 'N/A'
        t_ref_real_val = 0
      ENDELSE
		  t_ref_idx_val = WIDGET_LABEL(params_ref_base, VALUE=t_ref_idx_txt, $
        /ALIGN_RIGHT)
      IF dt_set THEN $
        t_ref_real_val = WIDGET_LABEL(params_ref_base, VALUE=t_ref_real_txt, $
          /ALIGN_RIGHT)
      ; -------------------- Reference raster time feedback --------------------
      IF refraster_time_fb THEN BEGIN
        ; Check where raster times greater than 0
        IF (hdr.refnt GT 1) THEN $
          wheretgt0 = WHERE(hdr.tarr_raster_ref[xref_start,*] GT 0, count) $
        ELSE $
          wheretgt0 = WHERE(hdr.tarr_raster_ref[xref_start] GT 0, count) 
        IF (count GT 0) THEN $
          t_sel = wheretgt0[count-1] $
        ELSE $
          t_sel = 0
        IF (hdr.date_obs_main NE '0') THEN BEGIN
          IF (hdr.refnt GT 1) THEN $
            dumval = hdr.utc_raster_ref[xref_start,t_sel] $
          ELSE $
            dumval = hdr.utc_raster_ref[xref_start]
          t_raster_ref_real_format = '(A'+STRTRIM(STRLEN(dumval),2)+')'  
        ENDIF ELSE BEGIN
          IF (hdr.refnt GT 1) THEN $
            dumval = hdr.tarr_raster_ref[xref_start,t_sel] $
          ELSE $
            dumval = hdr.tarr_raster_ref[xref_start]
          t_raster_ref_real_format = $
            '(F'+STRTRIM(FLOOR(ALOG10(dumval))+3,2)+'.1)'
        ENDELSE
        t_raster_ref_real_txt = STRING(dumval, FORMAT=t_raster_ref_real_format)
      ENDIF ELSE BEGIN
        t_raster_ref_real_format = ''
        t_raster_ref_real_txt = 'N/A'
      ENDELSE
      IF (raster_time_fb OR refraster_time_fb) THEN $
        t_raster_ref_real_val = WIDGET_LABEL(params_ref_base, $
          VALUE=t_raster_ref_real_txt, /ALIGN_RIGHT) $
      ELSE $
        t_raster_ref_real_val = 0
      ; -------------------- SJI time feedback --------------------
      sji_label   = WIDGET_LABEL(params_sji_base, VALUE=' ', /ALIGN_RIGHT)
      IF (hdr.sjint GT 1) THEN BEGIN
        t_sji_idx_format = '(I'+STRTRIM(FLOOR(ALOG10(hdr.sjint))+1,2)+')'
        t_sji_idx_txt = STRING(LONG(t_start), FORMAT=t_sji_idx_format)
      ENDIF ELSE BEGIN
        t_sji_idx_format = ''
        t_sji_idx_txt = 'N/A'
      ENDELSE
      IF ((hdr.sjint GT 1) AND dt_set) THEN BEGIN
        wheretgt0 = WHERE(hdr.tarr_sji GT 0, count)
        IF (count GT 0) THEN $
          t_sel = wheretgt0[count-1] $
        ELSE $
          t_sel = 0
        IF (hdr.date_obs_sji NE '0') THEN $
          t_sji_real_format = '(A'+STRTRIM(STRLEN(hdr.utc_sji[t_sel]),2)+')'  $
        ELSE $
          t_sji_real_format = '(F'+STRTRIM(FLOOR(ALOG10(hdr.tarr_sji[$
            t_sel]))+3,2)+'.1)'
        t_sji_real_txt = STRING(hdr.utc_sji[hdr.tsel_sji[t_start]], $
          FORMAT=t_sji_real_format)
      ENDIF ELSE BEGIN
        t_sji_real_format = ''
        t_sji_real_val = 0
        t_sji_real_txt = 'N/A'
      ENDELSE
		  t_sji_idx_val = WIDGET_LABEL(params_sji_base, VALUE=t_sji_idx_txt, $
        /ALIGN_RIGHT)
		  IF dt_set THEN $
        t_sji_real_val = WIDGET_LABEL(params_sji_base, VALUE=t_sji_real_txt, $
          /ALIGN_RIGHT)
      IF (raster_time_fb OR refraster_time_fb) THEN $
        t_sji_raster_real_val = WIDGET_LABEL(params_sji_base, VALUE='N/A', $
          /ALIGN_RIGHT)

  ; Data value parameters
      no_label    = WIDGET_LABEL(verlabel_base, VALUE='Data values', /ALIGN_LEFT)
      real_label  = WIDGET_LABEL(verlabel_base, VALUE='Value', /ALIGN_RIGHT)
      main_label  = WIDGET_LABEL(params_main_base, VALUE=' ', /ALIGN_RIGHT)
      dataval_real_txt = STRING(((*hdr.imdata)[lp_start])[x_start,y_start], $
        FORMAT='(E10.4)')
		  dataval_real_val = WIDGET_LABEL(params_main_base, VALUE=dataval_real_txt, $
        /ALIGN_RIGHT)
      ; dataval_unit_txt = WIDGET_LABEL(params_main_base, VALUE='['+hdr.bunit+']', /ALIGN_RIGHT)
      ref_label   = WIDGET_LABEL(params_ref_base, VALUE=' ', /ALIGN_RIGHT)
      IF hdr.showref THEN BEGIN
        dataval_ref_real_txt = STRING(((*hdr.refdata)[lp_ref_start])[$
          xref_start,yref_start], FORMAT='(E10.4)')
        ; dataval_ref_unit_txt = '['+hdr.refbunit+']'
      ENDIF ELSE BEGIN
        dataval_ref_real_format = ''
        dataval_ref_real_txt = 'N/A'
        ; dataval_ref_unit_txt = ' '
      ENDELSE
		  dataval_ref_real_val = WIDGET_LABEL(params_ref_base, VALUE=dataval_ref_real_txt, $
        /ALIGN_RIGHT)
      ;dataval_ref_unit_txt = WIDGET_LABEL(params_ref_base, VALUE=dataval_ref_unit_txt, $
      ;  /ALIGN_CENTER)
      sji_label   = WIDGET_LABEL(params_sji_base, VALUE=' ', /ALIGN_RIGHT)
      ;dataval_sji_unit_txt = ' '
      IF hdr.sjifile THEN BEGIN
        dataval_sji_real_txt = STRING(sjidata_tmp[xsji_start,ysji_start], $
          FORMAT='(E10.4)')
        ;IF (STRTRIM(hdr.sjibunit,2) NE '0') THEN dataval_sji_unit_txt = '['+hdr.sjibunit+']'
      ENDIF ELSE BEGIN
        dataval_sji_real_format = ''
        dataval_sji_real_txt = 'N/A'
      ENDELSE
      dataval_sji_real_val = WIDGET_LABEL(params_sji_base, VALUE=dataval_sji_real_txt, $
        /ALIGN_RIGHT)
      ;dataval_sji_unit_txt = WIDGET_LABEL(params_sji_base, VALUE=dataval_sji_unit_txt, $
      ;  /ALIGN_CENTER)

   param_base = WIDGET_BASE(control_panel, /ROW)
    ; Column 1 of parameters overview containing cursor x,y and zoomfactor
    ; Zommfactor info
		zoom_base = WIDGET_BASE(param_base, /ROW, /FRAME)
		zoom_txt = WIDGET_LABEL(zoom_base, VALUE = 'Zoom:')
		zoom_val = WIDGET_LABEL(zoom_base, $
      VALUE = STRING(zoomfactors[0]*100.,FORMAT='(I4)')+'%', /DYNAMIC_RESIZE)
    ; DATE_OBS
    date_base = WIDGET_BASE(param_base, /ROW, /FRAME)
    date_txt = WIDGET_LABEL(date_base, VALUE='Date:')
    IF (hdr.date_obs_main NE '0') THEN $
      dateval = STRMID(hdr.date_obs_main,0,STRPOS(hdr.date_obs_main,'T')) $
    ELSE $
      dateval = 'N/A'
    date_val = WIDGET_LABEL(date_base, VALUE=dateval, /DYNAMIC_RESIZE)
    ; OBSID
		obsid_base = WIDGET_BASE(param_base, /ROW, /FRAME)
		obsid_txt = WIDGET_LABEL(obsid_base, VALUE = 'OBSID:')
    IF (hdr.obsid NE '0') THEN $
      obsidval = hdr.obsid $
    ELSE $
      obsidval = 'N/A'
		obsid_val = WIDGET_LABEL(obsid_base, VALUE = obsidval, /DYNAMIC_RESIZE)

	bg = WIDGET_BASE(cpanel, EVENT_PRO = 'CRISPEX_PB_BG')
	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(initialising control panel)', /WIDGET, /OVER, /DONE
	feedback_text = [feedback_text[0:N_ELEMENTS(feedback_text)-2],'> Initializing control panel... done!']
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text

;-------------------- SETTING UP DATA POINTERS
	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(setting up data pointers)', /WIDGET, /OVER
	feedback_text = [feedback_text,'> Setting up data pointers... ']
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text
	index = INTARR(hdr.nx,hdr.ny,2,/NOZERO)
	xarr = INDGEN(hdr.nx)
	yarr = INDGEN(hdr.ny)
	FOR i=0,hdr.nx-1 DO index[i,*,1] = yarr
	FOR j=0,hdr.ny-1 DO index[*,j,0] = xarr
	indexmap= PTR_NEW(index, /NO_COPY)
	indices = PTR_NEW(INTARR(hdr.nx,hdr.ny,2))

	xyslice	= PTR_NEW(BYTARR(hdr.nx,hdr.ny,/NOZERO))
	sel_xyslice	= PTR_NEW(BYTARR(hdr.nx,hdr.ny,/NOZERO))
	dopslice= PTR_NEW(BYTARR(hdr.nx,hdr.ny,/NOZERO))
	sel_dopslice= PTR_NEW(BYTARR(hdr.nx,hdr.ny,/NOZERO))
	emptydopslice= PTR_NEW(BYTARR(hdr.nx,hdr.ny))
	maskslice= PTR_NEW(BYTARR(hdr.nx,hdr.ny,/NOZERO))

  phiscan = PTR_NEW(MAKE_ARRAY(hdr.nx,hdr.ny,hdr.nlp, TYPE=hdr.imtype,/NOZERO))
  sspscan = PTR_NEW(MAKE_ARRAY(hdr.nx,hdr.ny,hdr.nlp*hdr.ns, $
    TYPE=hdr.imtype,/NOZERO))
	phislice= PTR_NEW(BYTARR(hdr.nlp,nphi,/NOZERO))
	IF ((hdr.spfile EQ 1) OR (hdr.single_cube[0] GE 1)) THEN BEGIN
		loopslab= PTR_NEW(0)
		loopslice = PTR_NEW(0)
		refloopslab= PTR_NEW(0)
		refloopslice = PTR_NEW(0)
		crossloc = PTR_NEW(INTARR(nphi))
		exact_loopslab= PTR_NEW(0)
		exact_loopslice = PTR_NEW(BYTARR(nphi,hdr.mainnt))
		exact_crossloc= PTR_NEW(INTARR(nphi))
		rest_loopslab = PTRARR(nphi,/ALLOCATE_HEAP)
		rest_loopslice = PTRARR(nphi,/ALLOCATE_HEAP)
		rest_crossloc = PTRARR(nphi,/ALLOCATE_HEAP)
		FOR i=0,nphi-1 DO BEGIN
			*rest_loopslab[i]= PTR_NEW(0)
			*rest_loopslice[i] = PTR_NEW(0)
			*rest_crossloc[i]= PTR_NEW(0)
		ENDFOR
		det_loopslab= PTR_NEW(0)
		det_loopslice = PTR_NEW(BYTARR(nphi,hdr.mainnt))
		det_crossloc= PTR_NEW(INTARR(nphi))
	ENDIF ELSE BEGIN
		loopslab = 0		&	loopslice = 0		&	crossloc = 0
		rest_loopslab = 0	&	rest_loopslice = 0	& 	rest_crossloc = 0
		det_loopslab = 0	&	det_loopslice = 0	& 	det_crossloc = 0
		exact_loopslice = 0	& 	exact_loopslab = 0	&	exact_crossloc = 0
		refloopslab = 0		&	refloopslice = 0
		WIDGET_CONTROL, loop_slit_but, SENSITIVE = 0
		WIDGET_CONTROL, loop_feedb_but, SENSITIVE = 0
	ENDELSE
	xp = PTR_NEW(FLTARR(1))
	yp = PTR_NEW(FLTARR(1))
	sxp = PTR_NEW(FLTARR(1))
	syp = PTR_NEW(FLTARR(1))
	
	IF hdr.showref THEN $
		sel_refslice= PTR_NEW(BYTARR(hdr.refnx,hdr.refny)) $
  ELSE $
    sel_refslice = 0
  IF hdr.sjifile THEN $
		sel_sjislice= PTR_NEW(BYTARR(hdr.sjinx,hdr.sjiny)) $
  ELSE $
    sel_sjislice = 0
	
  imwintitle = 'CRISPEX'+instance_label+': Main image'
  ; Create location for main image including scroll bars
  main = WIDGET_BASE(cpanel,/COLUMN)
  draw_verslid_base = WIDGET_BASE(main,/ROW)
  draw_horslid_base = WIDGET_BASE(main,/ROW)
	xydrawid = WIDGET_DRAW(draw_verslid_base, XSIZE=imwinx, YSIZE=imwiny, RETAIN = 2)
  ypos_slider = WIDGET_SLIDER(draw_verslid_base,VALUE=0,MIN=0,MAX=1,/SUPPRESS,/DRAG,$
                          EVENT_PRO='CRISPEX_SLIDER_YPOS',/VERTICAL, YSIZE=imwiny)
  xpos_slider = WIDGET_SLIDER(draw_horslid_base,VALUE=0,MIN=0,MAX=1,/SUPPRESS,/DRAG,$
                          EVENT_PRO='CRISPEX_SLIDER_XPOS', XSIZE=imwinx)
	WIDGET_CONTROL, cpanel, /REALIZE, TLB_GET_SIZE=cpanel_size
  ; Determine window offsets based on realised control panel size and position
  ; If reference cube present, check if it would fit next to main image
  IF (window_offsets.set NE 0) THEN BEGIN
    spxoffset = window_offsets.spxoffset
    spyoffset = window_offsets.spyoffset
    lsxoffset = window_offsets.lsxoffset
    lsyoffset = window_offsets.lsyoffset
    dopxoffset = window_offsets.dopxoffset
    dopyoffset = window_offsets.dopyoffset
    imrefxoffset = window_offsets.imrefxoffset
    imrefyoffset = window_offsets.imrefyoffset
    refxoffset = window_offsets.refxoffset
    refyoffset = window_offsets.refyoffset
    refspxoffset = window_offsets.refspxoffset
    refspyoffset = window_offsets.refspyoffset
    reflsxoffset = window_offsets.reflsxoffset
    reflsyoffset = window_offsets.reflsyoffset
    sjixoffset = window_offsets.sjixoffset
    sjiyoffset = window_offsets.sjiyoffset
    phisxoffset = window_offsets.phisxoffset
    phisyoffset = window_offsets.phisyoffset
    intxoffset = window_offsets.intxoffset
    intyoffset = window_offsets.intyoffset
    loopxoffset = window_offsets.loopxoffset
    loopyoffset = window_offsets.loopyoffset
  ENDIF ELSE BEGIN
    refxoffset = cpanel_size[0]
    refyoffset = ydelta
    IF hdr.showref THEN BEGIN
      windows_xextent = cpanel_size[0]+ spwinx + imwinx + lswinx + xdelta*3
      IF (windows_xextent LE x_scr_size) THEN refxoffset += xdelta 
    ENDIF 
  
    ; Set offsets for other windows
    showsp_local = ((hdr.nlp GT 1) AND (hdr.mainnt GT 1)) 
    spxoffset = refxoffset+(hdr.showref*imwinx)+xdelta
    spyoffset = lswiny + ydelta
    lsxoffset = spxoffset
    lsyoffset = 0
    phisxoffset = spxoffset 
    phisyoffset = (hdr.nlp GT 1) * lswiny + ydelta + showsp_local * ydelta
    dopxoffset = xdelta
    dopyoffset = ydelta
    intxoffset = lsxoffset
    intyoffset = 0
    loopxoffset = imwinx + xdelta
    loopyoffset = showsp_local * ydelta
    ; Reference related
    imrefxoffset = xdelta
    imrefyoffset = ydelta
    refspxoffset = spxoffset
    refspyoffset = spyoffset + showsp_local * ydelta
    reflsxoffset = lsxoffset
    reflsyoffset = showsp_local * ydelta
    ; SJI related
    sjixoffset = lsxoffset + lswinx + xdelta
    sjiyoffset = 0
  ENDELSE
  
  WIDGET_CONTROL, xydrawid, GET_VALUE=imwid

	WIDGET_CONTROL, xydrawid, EVENT_PRO = 'CRISPEX_CURSOR', /SENSITIVE, /DRAW_MOTION_EVENTS, $
    /TRACKING_EVENTS, /DRAW_BUTTON_EVENTS
	
	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(setting up data pointers)', /WIDGET, /OVER, /DONE
	IF startupwin THEN BEGIN
		WSET, startupwid
		WSHOW, startupwid
		feedback_text = [feedback_text[0:N_ELEMENTS(feedback_text)-2],'> Setting up data pointers... done!']
		CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text
	ENDIF

;-------------------- DEFINE INFO POINTER
	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(defining main pointer)', /WIDGET, /OVER
	feedback_text = [feedback_text,'> Defining info pointer... ']
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text

;-------------------- CONTROL PANEL BUTTON/TEXT REFERENCES
	ctrlscp = { $
		save_loop_pts:save_loop_pts, timeslicemenu:timeslicemenu, clear_current_estimate:clear_current_estimate, $			
		sel_saved_loop:sel_saved_loop, all_saved_loop:all_saved_loop, det_file_but:det_file_loop, $
		fbwd_button:fbwd_button, bwd_button:backward_button, pause_button:pause_button, $
		fwd_button: forward_button, ffwd_button:ffwd_button, $
		loop_button:loop_button, blink_button:blink_button, cycle_button:cycle_button, $
		t_slider:t_slid, lower_t_text:lower_t_text, upper_t_text:upper_t_text, $		
		reset_trange_but:reset_trange_but, slice_button:slice_update_but, $			
		t_speed_slider:t_speed_slid, t_step_slider:t_step_slid, imref_blink_but:imref_blink_but, $					
    master_time_ids:master_time_ids, time_offset_slider:time_offset_slid, $
		lower_lp_text:lower_lp_text, upper_lp_text:upper_lp_text, $	
		reset_lprange_but:reset_lprange_but, lp_slider:lp_slid, lp_blink_slider:lp_blink_slid, $	
		lp_blink_but:lp_blink_but, lp_ref_but:lp_ref_but, lp_ref_slider:lp_ref_slid, $
		x_slider:x_slid, y_slider:y_slid, xref_slider:xref_slid, $
    yref_slider:yref_slid, lock_button:lockbut, unlock_button:unlockbut, $
		zoom_button_ids:zoom_button_ids, xpos_slider:xpos_slider, ypos_slider:ypos_slider, $			
    stokes_button_ids:stokes_button_ids, stokes_spbutton_ids:stokes_spbutton_ids, $
    specwin_buts:specwin_buts, refspecwin_buts:refspecwin_buts, $
    specwin_button_ids:specwin_button_ids, refspecwin_button_ids:refspecwin_button_ids, $
		detspect_label:detspect_label, scale_detspect_but:scale_detspect_but, $
		detspect_im_but:detspect_im_but, detspect_ref_but:detspect_ref_but, $
		ls_toggle_but:ls_toggle_but, subtract_but:subtract_but, $		
		lower_y_text:lower_y_text, upper_y_text:upper_y_text, $	
		sp_toggle_but:sp_toggle_but, refsp_toggle_but:refsp_toggle_but, int_toggle_but:int_toggle_but, $
		phis_toggle_but:phis_toggle_but, reference_but:reference_but, doppler_but:doppler_but, $						
    scaling_cbox:scaling_cbox, imagescale_cbox:imagescale_cbox, $
    histo_opt_txt:histo_opt_txt, $
    gamma_label:gamma_label, gamma_slider:gamma_slider, scalemin_slider:scalemin_slider, $
    scalemax_slider:scalemax_slider, $
    scaling_reset_button:scaling_reset_but, scaling_reset_all_but:scaling_reset_all_but, $
    diagscale_label:diagscale_label, ls_mult_cbox:ls_mult_cbox, ls_mult_txt:ls_mult_txt, $
		phi_slider:phi_slid, nphi_slider:nphi_slid, loop_feedb_but:loop_feedb_but, $	
		bwd_move_slit:bwd_move_slit, fwd_move_slit:fwd_move_slit, $
		loop_slit_but:loop_slit_but, rem_loop_pt_but:rem_loop_pt_but, loop_slice_but:loop_slice_but, $	
		overlay_but:overlay_but, loop_overlay_all:loop_overlay_al, loop_overlay_sav:loop_overlay_sav, $		
		linestyle_0:linestyle_0, linestyle_1:linestyle_1, linestyle_2:linestyle_2, $			
		measure_but:measure_but, apix_label:apix_label, apix_unit:apix_unit,$
    dx_text:dx_text, dy_text:dy_text, x_label:x_label, $
		measure_asec_lab:measure_asec_lab, measure_asec_text:measure_asec_text, $
		measure_km_lab:measure_km_lab, measure_km_text:measure_km_text, $					
		mask_button_ids:mask_button_ids, masks_overlay_ct_cbox:masks_overlay_ct_cbox, $
		masks_overlay_col_slid:masks_overlay_col_slid, raster_button_ids:raster_button_ids, $
    dispwid:dispwid, clear_current_inst:clear_current_inst, $
		verbose_set:PTR_NEW([sh_verb_0,sh_verb_4,sh_verb_8,sh_verb_16]) $
	}
;-------------------- RETRIEVE LOOPS CONTROLS 
	ctrlsdet = { $
		sel_all:0, sel_none:0, disp_list:0, overlay_all:0, overlay_sel:0, all_pos:0, saved_pos:0, $
		sel_range_pos:0, save_imonly:0, save_refonly:0, save_imref:0, $
		dtmin_text:0, dtmax_text:0, dlpmin_text:0, dlpmax_text:0, refdlpmin_text:0, refdlpmax_text:0, $	
		width_slider:0, get_dets:0 $
	}
;-------------------- FEEDBACK CONTROLS
	ctrlsfeedb = { $
		estimate_label:0, feedback_text:0, close_button:0 $
	}
;-------------------- HEADER CONTROLS 
	ctrlshdr = { $
		header_select:0, header_txt:0 $
	}
;-------------------- INT CONTROLS 
	ctrlsint = { $
    sel_allnone_ids:[0,0], int_sel_save:0, lower_y_int_text:0, upper_y_int_text:0, $
    dg_box:0, lp_box:0, ls_box:0, cl_box:0, remove_button:0 $
	}
;-------------------- RETRIEVE DETECTIONS CONTROLS 
	ctrlsloop = { $
		get_loops:0, sel_all:0, sel_none:0, all_pos:0, saved_pos:0, del_files:0, keep_files:0, $
		save_imonly:0, save_refonly:0, save_imref:0 $
	}
;-------------------- BMP BUTTON IMAGES
	ctrlspbbut = { $
		fbwd_pressed:bmpbut_fbwd_pressed, fbwd_idle:bmpbut_fbwd_idle, $
		bwd_pressed:bmpbut_bwd_pressed, bwd_idle:bmpbut_bwd_idle, $
		pause_pressed:bmpbut_pause_pressed, pause_idle:bmpbut_pause_idle, $
		fwd_pressed:bmpbut_fwd_pressed, fwd_idle:bmpbut_fwd_idle, $
		ffwd_pressed:bmpbut_ffwd_pressed, ffwd_idle:bmpbut_ffwd_idle, $
		loop_pressed:bmpbut_loop_pressed, loop_idle:bmpbut_loop_idle, $
		cycle_pressed:bmpbut_cycle_pressed, cycle_idle:bmpbut_cycle_idle, $
		blink_pressed:bmpbut_blink_pressed, blink_idle:bmpbut_blink_idle $
	}
;-------------------- PARAMETER WINDOW REFERENCES
	ctrlsparam = { $
    xycoord_val:xycoord_val, xycoord_real_val:xycoord_real_val,  $
    refxycoord_val:refxycoord_val, refxycoord_real_val:refxycoord_real_val,  $
    sjixycoord_val:sjixycoord_val, sjixycoord_real_val:sjixycoord_real_val,  $
    lp_idx_val:lp_idx_val, lp_real_val:lp_real_val, lp_vdop_val:lp_vdop_val, $
    lp_ref_idx_val:lp_ref_idx_val, lp_ref_real_val:lp_ref_real_val, $
    lp_ref_vdop_val:lp_ref_vdop_val, $
    t_idx_val:t_idx_val, t_real_val:t_real_val, $ 
    t_raster_real_val:t_raster_real_val, $
    t_ref_idx_val:t_ref_idx_val, t_ref_real_val:t_ref_real_val, $
    t_raster_ref_real_val:t_raster_ref_real_val, $
    t_sji_idx_val:t_sji_idx_val, t_sji_real_val:t_sji_real_val, $
    dataval_real_val:dataval_real_val, dataval_ref_real_val:dataval_ref_real_val, $
    dataval_sji_real_val:dataval_sji_real_val, $
    zoom_val:zoom_val $
	}
;-------------------- PREFERENCE BUTTONS
	ctrlspref = { $
		startup_autopl:0, startup_win:0, displays_bgcols:0, displays_plcols:0, displays_interp:0, $
		displays_phislice:0, displays_slices:0, displays_offsets:0, $
    histo_opt_txt:0, gamma_slid:0, gamma_label:0,  $	
		paths_i_def_but:0, paths_i_sav_but:0, paths_ipath_text:0, $
		paths_o_def_but:0, paths_o_sav_but:0, paths_opath_text:0, $
		paths_iopath:0, save_defsaveid:0, save_defsaveid_sample:0, $
		set_defaults:0, warnings_cbox:0 $
	}
;-------------------- REFERENCE CONTROLS
	ctrlsref = { $
		xrefpos_slider:0, yrefpos_slider:0 $
	}
;-------------------- RESTORE LOOPS CONTROLS 
	ctrlsrestore = { $
		disp_list:0, sel_all:0, sel_none:0, open_tanat:0 $	
	}
;-------------------- SAVING CONTROLS 
	ctrlssav = { $
		path_textlab:0, savopt_path_textlab:0, overlays_num_but:0, overlays_curs_but:0, overlays_thick_slider:0, $
		overlays_pts_but:0, overlays_symsize_slider:0, overlays_asecbar_but:0, overlays_asecbar_slider:0 $
	}
;-------------------- SJI CONTROLS
	ctrlssji = { $
		xsjipos_slider:0, ysjipos_slider:0 $
	}
;-------------------- CONTROL SWITCHES
	ctrlsswitch = { $
		imrefdetspect:0, lp_ref_lock:lp_ref_lock, bwd_insensitive:1, $
    fwd_insensitive:1 $
	}
;-------------------- CURSOR 
	curs = { $
		sx:sx_start, sy:sy_start, sxlock:sx_start, sylock:sx_start, $		
    sxsji:sxsji_start, sysji:sysji_start, sxref:sxref_start, syref:syref_start,$
    sxreflock:sxref_start, syreflock:syref_start, xlock:x_start, ylock:y_start,$
    sxsjilock:sxsji_start, sysjilock:sysji_start, xsjilock:xsji_start, $
    ysjilock:ysji_start, xreflock:xref_start, yreflock:yref_start,  $
    lockset:0 $
	}
;-------------------- DATA 
	data = { $
    imagedata:hdr.imdata, xyslice:xyslice, refdata:hdr.refdata, $
    refslice:hdr.refslice, maskdata:hdr.maskdata, maskslice:maskslice, $
    dopslice:dopslice, dopplerscan:dopplerscan, spdata:hdr.spdata, $
    sspscan:sspscan, ssp_cur:PTRARR(hdr.imns), refspdata:hdr.refspdata, $
    refscan:hdr.refscan, refsspscan:hdr.refsspscan, refssp_cur:PTR_NEW(0), $
    spslice:PTR_NEW(0), spslice_congrid:PTR_NEW(0), $
    refspslice:PTR_NEW(0), refspslice_congrid:PTR_NEW(0), $
		emptydopslice:emptydopslice, scan:hdr.scan, phiscan:phiscan, $
    phislice:phislice, sjidata:hdr.sjidata, sjislice:hdr.sjislice, $
		indexmap:indexmap, indices:indices, ratio:ratio, $
		lunsp:hdr.lunsp, lunim:hdr.lunim, lunrefim:hdr.lunrefim, $
    lunrefsp:hdr.lunrefsp, lunsji:hdr.lunsji, lunmask:hdr.lunmask $
	}
;-------------------- DATA PARAMETERS
	dataparams = { $
    ; Filenames
		imfilename:hdr.imfilename, spfilename:hdr.spfilename, $
    refimfilename:hdr.refimfilename, $
    refspfilename:hdr.refspfilename, maskfilename:hdr.maskfilename, $	
    ; Headers, OBSID and DATE_OBS
    hdrs:[PTR_NEW(hdr.hdrs_main),PTR_NEW(hdr.hdrs_ref),PTR_NEW(hdr.hdrs_sji)], $
    next:[N_ELEMENTS(hdr.hdrs_main),N_ELEMENTS(hdr.hdrs_ref),$
    N_ELEMENTS(hdr.hdrs_sji)], obsid:hdr.obsid, $
    date_obs_main:hdr.date_obs_main, date_obs_ref:hdr.date_obs_ref, $
    date_obs_sji:hdr.date_obs_sji, $
    ; Spatial dimensions
		x:DOUBLE(x_start), y:DOUBLE(y_start), d_nx:hdr.nx-1, d_ny:hdr.ny-1, $
    nx:hdr.nx, ny:hdr.ny, $
    sjinx:hdr.sjinx, sjiny:hdr.sjiny, sjidx:hdr.sjidx, sjidy:hdr.sjidy, $
    refnx:hdr.refnx, refny:hdr.refny, refdx:hdr.refdx, refdy:hdr.refdy, $
    d_refnx:hdr.refnx-1, d_refny:hdr.refny-1, $
    d_sjinx:hdr.sjinx-1, d_sjiny:hdr.sjiny-1, $
    xval:hdr.xval, yval:hdr.yval, xval_ref:hdr.xval_ref, yval_ref:hdr.yval_ref,$
    xval_sji:hdr.xval_sji, yval_sji:hdr.yval_sji, $
    xpix:hdr.xpix, ypix:hdr.ypix, xpix_ref:hdr.xpix_ref, ypix_ref:hdr.ypix_ref,$
    xpix_sji:hdr.xpix_sji, ypix_sji:hdr.ypix_sji, $
    pix_main2ref:pix_main2ref, pix_ref2main:pix_ref2main, $
    pix_main2sji:pix_main2sji, pix_sji2main:pix_sji2main, $
    pix_ref2sji:pix_ref2sji, pix_sji2ref:pix_sji2ref, $
    wcs_main:hdr.wcs_main, wcs_ref:hdr.wcs_ref, wcs_sji:hdr.wcs_sji, $
    xref:DOUBLE(xref_start), yref:DOUBLE(yref_start), $
    xsji:DOUBLE(xsji_start), ysji:DOUBLE(ysji_start), tarr_sji:hdr.tarr_sji, $
    tarr_raster_main:hdr.tarr_raster_main, tarr_raster_ref:hdr.tarr_raster_ref,$
    utc_raster_main:hdr.utc_raster_main, utc_raster_ref:hdr.utc_raster_ref,$
    utc_sji:hdr.utc_sji, $
		lc:hdr.lc, lp:lp_start, lp_ref:lp_ref_start, lp_dop:lp_start, nlp:hdr.nlp,$
    refnlp:hdr.refnlp, ns:hdr.ns, s:0L, $					
		lps:hdr.lps, ms:hdr.ms, spec:hdr.mainspec, $
		reflps:hdr.reflps, refms:hdr.refms, refspec:hdr.refspec, $
		nt:hdr.mainnt, mainnt:hdr.mainnt, refnt:hdr.refnt, masknt:hdr.masknt, $
    sjint:hdr.sjint, $		
    default_toffset_main:hdr.toffset_main, default_toffset_ref:hdr.toffset_ref, $
    dx:hdr.dx, dy:hdr.dy, $
    bunit:[hdr.bunit,hdr.refbunit], lpunit:[hdr.lpunit,hdr.reflpunit], $
    xunit:hdr.xunit, yunit:hdr.yunit, tunit:hdr.tunit $
	}
;-------------------- DATA SWITCH
	dataswitch = { $
		onecube:hdr.onecube, reffile:hdr.showref, refspfile:hdr.refspfile, spfile:hdr.spfile, $
    maskfile:hdr.maskfile, sjifile:hdr.sjifile, $							
    wcs_set:hdr.wcs_set, ref_wcs_set:hdr.ref_wcs_set, $
    sji_wcs_set:hdr.sji_wcs_set $
	}
;-------------------- DET PARAMS
	detparams = { $
		nr_dets:0, sel_dets:PTR_NEW(INTARR(nphi*3)), t:PTR_NEW(0), $
		detfilename:'', idx:0, nr_sel_loops:0, sel_loops:PTR_NEW(INTARR(nphi)), $
    overlay_dets:PTR_NEW(0), $
		xlr:PTR_NEW(0), ylr:PTR_NEW(0), xlp:PTR_NEW(0), ylp:PTR_NEW(0), $	
		width:0, mid:0, delta_t_dn:10, delta_t_up:10, lp_dn:lp_first, lp_up:lp_last, $					
		lp_ref_dn:lp_ref_first, lp_ref_up:lp_ref_last, $
    w_lpts:PTR_NEW(0), ngaps:0, databounds:PTR_NEW(0), wdatabounds:PTR_NEW(0) $
	}
;-------------------- DATA DISPLAY PARAMETERS
	dispparams = { $
		t_first:t_first, t_last:t_last, t_range:hdr.mainnt, t_low:t_first, t_upp:t_last, $					
		x_first:x_first, x_last:x_last, y_first:y_first, y_last:y_last, $				
		lp_first:lp_first, lp_last:lp_last, lp_range:hdr.nlp, lp_low:lp_first, lp_upp:lp_last, $
		lp_ref_first:lp_ref_first, lp_ref_last:lp_ref_last, lp_ref_low:lp_ref_first, $
    lp_ref_upp:(hdr.refnlp-1), lp_ref_range:hdr.refnlp, $
		nlpreb:nlpreb, ntreb:ntreb, refnlpreb:nlpreb, refntreb:refntreb, $
    refloopnlxreb:nlpreb, refloopntreb:loopntreb, $
		loopnlxreb:nlpreb, loopntreb:loopntreb, restloopnlxreb:nlpreb, restloopntreb:loopntreb, $
		retrdetnlxreb:nlpreb, retrdetntreb:loopntreb, phisnlpreb:nlpreb, nphireb:nphireb, $					
		xi:hdr.xi, yi:hdr.yi, xo:hdr.xo, yo:hdr.yo, xi_ref:hdr.xi_ref, yi_ref:hdr.yi_ref, $
    xo_ref:hdr.xo_ref, yo_ref:hdr.yo_ref, phisxtri:PTR_NEW(0), phisytri:PTR_NEW(0), $
    phisxi:PTR_NEW(0), phisyi:PTR_NEW(0), phisxo:PTR_NEW(0), phisyo:PTR_NEW(0), $
    sjix0:hdr.sjix0, sjiy0:hdr.sjiy0, $
    xsji_first:0L, xsji_last:(hdr.sjinx-1), $
    ysji_first:0L, ysji_last:(hdr.sjiny-1),  $
    xref_first:xref_first, xref_last:xref_last, $
    yref_first:yref_first, yref_last:yref_last, $
		interpspslice:interpspslice, phislice_update:phislice_update, slices_imscale:slices_imscale, $
    tsel_main:PTR_NEW(hdr.tsel_main), tsel_ref:PTR_NEW(hdr.tsel_ref), $
    tsel_sji:PTR_NEW(hdr.tsel_sji), master_time:0, $
    tarr_main:PTR_NEW(hdr.tarr_main[hdr.tsel_main]), $
    tarr_ref:PTR_NEW(hdr.tarr_ref[hdr.tsel_ref]), $
    tarr_sji:PTR_NEW(hdr.tarr_sji[hdr.tsel_sji]), $
    utc_main:PTR_NEW(hdr.utc_main[hdr.tsel_main]), $
    utc_ref:PTR_NEW(hdr.utc_ref[hdr.tsel_ref]), $
    utc_sji:PTR_NEW(hdr.utc_sji[hdr.tsel_sji]), $
    t:t_start, t_main:hdr.tsel_main[0], t_ref:hdr.tsel_ref[0], t_sji:hdr.tsel_sji[0], $
    t_low_main:hdr.tarr_main[0], t_upp_main:hdr.tarr_main[(hdr.mainnt-1)>0], $
    t_low_ref:hdr.tarr_ref[0], t_upp_ref:hdr.tarr_ref[(hdr.refnt-1)>0], $
    toffset_main:hdr.toffset_main, toffset_ref:hdr.toffset_ref, $
    sjibscale:hdr.sjibscale, sjibzero:hdr.sjibzero, $
    x_main:x_main, y_main:y_main, x_ref:x_ref, y_ref:y_ref $
	}
;-------------------- DATA DISPLAY SWITCHES
	dispswitch = { $
		restricted_t_range:PTR_NEW(0), restricted_lp_range:PTR_NEW(0), $
    restricted_lp_ref_range:PTR_NEW(0), exts:exts_set, refexts:refexts_set, $
    warpspslice:hdr.warpspslice, warprefspslice:hdr.warprefspslice, $
		detspect_scale:detspect_scale, ref_detspect_scale:ref_detspect_scale, $
    drawdop:0, sjiscaled:hdr.sjiscaled, main2ref_no_map:hdr.main2ref_no_map, $
    xy_out_of_range:0, xyref_out_of_range:xyref_out_of_range, $
    xysji_out_of_range:xysji_out_of_range $
	}
;-------------------- FEEDBACK PARAMS
	feedbparams = { $
		estimate_lx:estimate_lx, estimate_time:estimate_time, estimate_run:estimate_run, $		
		startup_im:startup_im, xout:xout, yout:yout, verbosity:verbosity, last_routine:'', last_routine_count:0, $
		pbstats:DOUBLE(SYSTIME(/SECONDS)), sum_pbstats:PTR_NEW(DBLARR(10)), av_pbstats:0D, count_pbstats:0 $	
	}
;-------------------- INT PARAMS
	intparams = { $
		sel_diagnostics:PTR_NEW(hdr.sel_diagnostics), $ 
    seldisp_diagnostics:PTR_NEW(REPLICATE(1B,N_ELEMENTS(hdr.sel_diagnostics))), $
	  linlab_diagnostics:['Solid', 'Dotted', 'Dashed', 'Dash Dot', 'Dash Dot Dot', 'Long Dashes'],$
    sellines_diagnostics:PTR_NEW(hdr.sellines_diagnostics), $
	  colors_diagnostics:[0,200,135,120,100,90,230,40],$
	  collab_diagnostics:['Black', 'Red', 'Pink', 'Purple', 'Blue', 'Turquoise', 'Grey', 'Green'],$
    selcol_diagnostics:PTR_NEW(hdr.selcol_diagnostics), $
    sellp_diagnostics:PTR_NEW(hdr.sellp_diagnostics), $
    disp_diagnostics:REPLICATE(1,hdr.ndiagnostics), ndisp_diagnostics:hdr.ndiagnostics, $
    disp_refdiagnostics:REPLICATE(1,hdr.nrefdiagnostics), ndisp_refdiagnostics:hdr.nrefdiagnostics, $
		diagnostics:hdr.diagnostics, ndiagnostics:hdr.ndiagnostics, lock_t:1, $ 
    diag_start:hdr.diag_start, diag_width:hdr.diag_width, $
    diag_starts:PTR_NEW(hdr.diag_start), diag_widths:PTR_NEW(hdr.diag_width), $
    wheredispdiag:PTR_NEW(LONARR(hdr.ndiagnostics)), $
    refdiagnostics:hdr.refdiagnostics, nrefdiagnostics:hdr.nrefdiagnostics, $
    refdiag_start:hdr.refdiag_start, refdiag_width:hdr.refdiag_width, $
    refdiag_starts:PTR_NEW(hdr.refdiag_start), refdiag_widths:PTR_NEW(hdr.refdiag_width), $
    wheredisprefdiag:PTR_NEW(LONARR(hdr.nrefdiagnostics)), $
    lp_diag_all:0, lp_ref_diag_all:0 $
	}
;-------------------- I/O PARAMS
	ioparams = { $
		hdr:hdr $
  }
;-------------------- LOOP PARAMS
	loopparams = { $
		xp:xp, yp:yp, xr:PTR_NEW(FLTARR(nphi)), yr:PTR_NEW(FLTARR(nphi)), np:0, $			
		xpdisp:xp, ypdisp:yp, xrdisp:PTR_NEW(FLTARR(nphi)), $
    yrdisp:PTR_NEW(FLTARR(nphi)), $
    npdisp:0, ngaps:0L, databounds:PTR_NEW(0L), wdatabounds:PTR_NEW(0L), $
		w_lpts:PTR_NEW(BYTARR(nphi)), nw_lpts:0, $						
    xp_ref:PTR_NEW(0), yp_ref:PTR_NEW(0), xr_ref:PTR_NEW(0.), $
    yr_ref:PTR_NEW(0.), np_ref:0, w_lpts_ref:PTR_NEW(0), nw_lpts_ref:0, $
		xpdisp_ref:PTR_NEW(0), ypdisp_ref:PTR_NEW(0), xrdisp_ref:PTR_NEW(0.), $
    yrdisp_ref:PTR_NEW(0.), $
    npdisp_ref:0, ngaps_ref:0L, databounds_ref:PTR_NEW(0L), $
    wdatabounds_ref:PTR_NEW(0L), $
    xp_sji:PTR_NEW(0), yp_sji:PTR_NEW(0), xr_sji:PTR_NEW(0.), $
    yr_sji:PTR_NEW(0.), np_sji:0, w_lpts_sji:PTR_NEW(0), nw_lpts_sji:0, $
		xpdisp_sji:PTR_NEW(0), ypdisp_sji:PTR_NEW(0), xrdisp_sji:PTR_NEW(0.), $
    yrdisp_sji:PTR_NEW(0.), $
    npdisp_sji:0, ngaps_sji:0L, databounds_sji:PTR_NEW(0L) $
	}
;-------------------- LOOPS DATA
	loopsdata = { $
		loopsize:0, rest_loopsize:PTR_NEW(INTARR(10)), exact_loopsize:0, det_loopsize:0, $				
		crossloc:PTR_NEW(0), rest_crossloc:rest_crossloc, exact_crossloc:exact_crossloc, $		
		det_crossloc:det_crossloc, $
		loopslab:loopslab, loopslice:loopslice, $			
		refloopsize:0, refloopslab:refloopslab, refloopslice:refloopslice, $			
    refcrossloc:PTR_NEW(0), $
		rest_loopslab:rest_loopslab, rest_loopslice:rest_loopslice, $
		exact_loopslab:exact_loopslab, exact_loopslice:exact_loopslice, $	
		det_loopslab:det_loopslab, det_loopslice:det_loopslice, $	
    empty_slice:PTR_NEW(0), rest_empty_slice:PTR_NEW(0), $
    det_empty_slice:PTR_NEW(0) $
	}
;-------------------- LOOPS SWITCHES
	loopswitch = { $
		retrieve_loops:0, restore_loops:0, was_restore_loops:0, retrieve_detfile:0 $		
	}
;-------------------- MEASUREMENT
	meas = { $
		spatial_measurement:0, np:0, $					
		xp:PTR_NEW(0), yp:PTR_NEW(0), sxp:PTR_NEW(0), syp:PTR_NEW(0), $					
		xp_ref:PTR_NEW(0), yp_ref:PTR_NEW(0), sxp_ref:PTR_NEW(0), syp_ref:PTR_NEW(0), $					
		xp_sji:PTR_NEW(0), yp_sji:PTR_NEW(0), sxp_sji:PTR_NEW(0), syp_sji:PTR_NEW(0) $					
	}
;-------------------- OVERLAY PARAMS
	overlayparams = { $
		sxp:sxp, syp:syp, sxr:PTR_NEW(FLTARR(nphi)), syr:PTR_NEW(FLTARR(nphi)), $
    sxp_ref:PTR_NEW(0.), syp_ref:PTR_NEW(0.), $
    sxr_ref:PTR_NEW(0.), syr_ref:PTR_NEW(0.), $
    sxp_sji:PTR_NEW(0.), syp_sji:PTR_NEW(0.), $
    sxr_sji:PTR_NEW(0.), syr_sji:PTR_NEW(0.), $
    loop_linestyle:0, maskcolor:255, maskct:maskct $				
	}
;-------------------- OVERLAY SWITCHES
	overlayswitch = { $
		det_overlay_all:0, loopslit:0, overlalways:1, looppath_feedback:1, $
    mask:hdr.maskfile, maskim:[hdr.maskfile,hdr.showref,0], $
    sjiraster:(hdr.sjifile AND ((nrasterdims[0] GT 1) OR (hdr.nx EQ 1))), $
    refraster:(hdr.showref AND ((nrasterdims[0] GT 1) OR (hdr.nx EQ 1))), $		
    rastertiming:((nrasterdims[0] GT 1) OR (nrasterdims[1] GT 1)) $
	}
;-------------------- PARAMETER WINDOW CONTROLS 
	paramparams = { $
		wav_h:wav_h, sp_h:sp_h, scale_cubes:scale_cubes_vals, $
    xcoord_format:xcoord_format, ycoord_format:ycoord_format, $
    xcoord_real_format:xcoord_real_format, ycoord_real_format:ycoord_real_format, $
    refxcoord_format:refxcoord_format, refycoord_format:refycoord_format, $
    refxcoord_real_format:refxcoord_real_format, $
    refycoord_real_format:refycoord_real_format, $
    sjixcoord_format:sjixcoord_format, sjiycoord_format:sjiycoord_format, $
    sjixcoord_real_format:sjixcoord_real_format, $
    sjiycoord_real_format:sjiycoord_real_format, $
    lp_idx_format:lp_idx_format, lp_real_format:lp_real_format, $
    lp_vdop_format:lp_vdop_format, $
    lp_ref_idx_format:lp_ref_idx_format, lp_ref_real_format:lp_ref_real_format, $
    lp_ref_vdop_format:lp_ref_vdop_format, $
    t_idx_format:t_idx_format, t_real_format:t_real_format, $
    t_raster_real_format:t_raster_real_format, $
    t_ref_idx_format:t_ref_idx_format, t_ref_real_format:t_ref_real_format, $
    t_raster_ref_real_format:t_raster_ref_real_format, $
    t_sji_idx_format:t_sji_idx_format, t_sji_real_format:t_sji_real_format $
	}
;-------------------- PARAM SWITCHES
	paramswitch = { $
    dt_set:dt_set, t_raster:raster_time_fb, t_raster_ref:refraster_time_fb $ 
	}
;-------------------- PATHS AND DIRECTORIES
	paths = { $
		ipath:ipath, opath:opath, opath_write:opath_write, hostname:hostname, $
    dir_settings:dir_settings, dir_settings_write:dir_settings_write, $
		dir_aux:dir_aux, dir_tanat:dir_aux, tanat_repointed:0 $
	}
;-------------------- PLAYBACK
	pbparams = { $
		t_step:t_step, t_speed:t_speed, direction:direction, bg:bg, mode:'PAUSE', lmode:'LOOP', $				
		imrefmode:0, lp_blink:lp_start, lp_blink_init:lp_start, spmode:0, spdirection:1 $						
	}
;-------------------- PHI SLIT VARIABLES 
	phiparams = { $
		d_nphi_set:nphi, nphi:nphi, angle:angle, nphi_set:LONG(hdr.ny/3.)-1, sphi:0, $			
		x_pts:PTR_NEW(0.), y_pts:PTR_NEW(0.), nw_cur:LONG(hdr.ny/3.), curindex:0, maxindex:0 $				
	}
;-------------------- PLOTAXES
	plotaxes = { $
		ticklen:ticklen, lsxticklen:lsxticklen, lsyticklen:lsyticklen, $
		reflsxticklen:reflsxticklen, reflsyticklen:reflsyticklen, $
		spxticklen:spxticklen, spyticklen:spyticklen, $
		refspxticklen:spxticklen, refspyticklen:spyticklen, $
		phisxticklen:phisxticklen, phisyticklen:phisyticklen, $
		loopxticklen:spxticklen, loopyticklen:spyticklen, $
		refloopxticklen:spxticklen, refloopyticklen:spyticklen, $
		restloopxticklen:spxticklen, restloopyticklen:spyticklen, $
		retrdetxticklen:spxticklen, retrdetyticklen:spyticklen, $
		intxticklen:intxticklen, intyticklen:intyticklen, $
    xtickinterval:PTR_NEW(0.), xdoptickinterval:PTR_NEW(0.), $
    xtickvals:PTRARR(hdr.ndiagnostics), $ 
    xdoptickvals:PTRARR(hdr.ndiagnostics), xdoptickloc:PTRARR(hdr.ndiagnostics), $
    xreftickinterval:PTR_NEW(0.), xrefdoptickinterval:PTR_NEW(0.), $
    xreftickvals:PTRARR(hdr.nrefdiagnostics), $ 
    xrefdoptickvals:PTRARR(hdr.nrefdiagnostics), $
    xrefdoptickloc:PTRARR(hdr.nrefdiagnostics), $
		ls_low_y:ls_low_y, ls_upp_y:ls_upp_y, ls_yrange:ls_yrange, $		
		ls_low_y_ref:ls_low_y_ref, ls_upp_y_ref:ls_upp_y_ref, ls_yrange_ref:ls_yrange_ref, $
		int_low_y:int_low_y, int_upp_y:int_upp_y, int_low_t:t_first, int_upp_t:t_last, $
		dt:hdr.dt, v_dop:hdr.v_dop, v_dop_ref:hdr.v_dop_ref, $		
    diag_ratio:PTR_NEW(hdr.diag_width/FLOAT(hdr.diag_width)), $
    diag_range_sp:PTR_NEW((hdr.diag_width/FLOAT(TOTAL(hdr.diag_width)))*xplspw), $
    refdiag_ratio:PTR_NEW(hdr.refdiag_width/FLOAT(hdr.refdiag_width)), $
    refdiag_range_sp:PTR_NEW((hdr.refdiag_width/FLOAT(TOTAL(hdr.refdiag_width)))*xplspw), $
    diag_range_phis:PTR_NEW((hdr.diag_width/FLOAT(TOTAL(hdr.diag_width)))*phisxplspw), $
    phis_yrange:[-1.,1.] $
	}
;-------------------- PLOT PARAMETERS
	plotparams = { $
		bgplotcol:bgplotcol, plotcol:plotcol $
	}
;-------------------- PLOT POSITION
	plotpos = { $
		lsx0:lsx0, lsy0:lsy0, lsx1:lsx1, lsy1:lsy1, $
		reflsx0:reflsx0, reflsy0:reflsy0, reflsx1:reflsx1, reflsy1:reflsy1, $
		spx0:spx0, spy0:spy0, spx1:spx1, spy1:spy1, $							
		refspx0:spx0, refspy0:refspy0, refspx1:spx1, refspy1:refspy1, $
		phisx0:phisx0, phisx1:phisx1, phisy0:phisy0, phisy1:phisy1, $
		loopx0:spx0, loopx1:spx1, loopy0:spy0, loopy1:loopy1, $
		refloopx0:spx0, refloopx1:spx1, refloopy0:spy0, refloopy1:loopy1, $
		restloopx0:spx0, restloopx1:spx1, restloopy0:spy0, restloopy1:loopy1, $
		retrdetx0:spx0, retrdetx1:spx1, retrdety0:spy0, retrdety1:loopy1, $
		intx0:intx0, intx1:intx1, inty0:inty0, inty1:inty1, $
		xplspw:xplspw, yplspw:yplspw, refxplspw:xplspw, refyplspw:refyplspw, $		
		phisxplspw:phisxplspw, phisyplspw:phisyplspw, loopxplspw:xplspw, loopyplspw:loopyplspw, $
		refloopxplspw:xplspw, refloopyplspw:loopyplspw, restloopxplspw:xplspw, restloopyplspw:loopyplspw, $
		retrdetxplspw:xplspw, retrdetyplspw:loopyplspw, $
		lsxmargin_init:lsxmargin_init, lsxwall_init:lsxwall_init, $
		reflsxmargin_init:lsxmargin_init, reflsxwall_init:lsxwall_init, $
		spxmargin_init:spxmargin_init, spxwall_init:spxwall_init, $
		refspxmargin_init:spxmargin_init, refspxwall_init:spxwall_init, $
		phisxmargin_init:spxmargin_init, phisxwall_init:spxwall_init, $
		loopxmargin_init:spxmargin_init, loopxwall_init:spxwall_init, $
		refloopxmargin_init:spxmargin_init, refloopxwall_init:spxwall_init, $
		restloopxmargin_init:spxmargin_init, restloopxwall_init:spxwall_init, $
		retrdetxmargin_init:spxmargin_init, retrdetxwall_init:spxwall_init, $
		intxmargin_init:intxmargin_init, intxwall_init:intxwall_init $
	}
;-------------------- PLOT SWITCHES
	plotswitch = { $
		heightset:heightset, refheightset:refheightset, multichannel:hdr.multichannel, scalestokes:scalestokes, $
		v_dop_set:hdr.v_dop_set[0], v_dop_set_ref:hdr.v_dop_set[1], subtract:0, ref_subtract:0, $				
    xtick_reset:1, xdoptick_reset:1, xreftick_reset:1, xrefdoptick_reset:1 $
	}
;-------------------- PLOT TITLES
	plottitles = { $
		spxtitle:hdr.spxtitle, spytitle:spytitle, spwintitle:spwintitle, $
		refspxtitle:hdr.refspxtitle, refspwintitle:refspwintitle, $
		lsytitle:lsytitle, reflsytitle:reflsytitle, $
		lswintitle:lswintitle, reflswintitle:reflswintitle, phiswintitle:phiswintitle $
	}
;-------------------- PREFERENCE SETTINGS
	prefs = { $
		autoplay:autoplay, startupwin:startupwin, defsaveid:defsaveid,  $
		defipath:defipath, prefipath:prefipath, defopath:defopath, prefopath:prefopath, $
		bgplotcol_old:bgplotcol, plotcol_old:plotcol, interpspslice_old:interpspslice, $
		slices_imscale_old:slices_imscale, histo_opt_val:histo_opt_val, gamma_val:gamma_val, $
    warnings:warnings, current_offsets:window_offsets.set, $
		tmp_autoplay:autoplay, tmp_startupwin:startupwin, tmp_defsaveid:defsaveid, $
		tmp_bgplotcol:bgplotcol, tmp_plotcol:plotcol, tmp_defipath:defipath, tmp_prefipath:prefipath, $
		tmp_defopath:defopath, tmp_prefopath:prefopath, tmp_interpspslice:interpspslice, $
		tmp_phislice_update:phislice_update, tmp_slices_imscale:slices_imscale, $								
    tmp_histo_opt_val:histo_opt_val, tmp_gamma_val:gamma_val, tmp_warnings:warnings, $
		default_autoplay:default_autoplay, default_startupwin:default_startupwin, $
		default_bgplotcol:default_bgplotcol, default_plotcol:default_plotcol, $
		default_defipath:default_defipath, default_prefipath:default_prefipath, $
		default_defopath:default_defopath, default_prefopath:default_prefopath, $
		default_defsaveid:default_defsaveid, default_interpspslice:default_interpspslice, $
		default_phislice_update:default_phislice_update, default_slices_imscale:default_slices_imscale, $
    default_histo_opt_val:default_histo_opt_val, default_gamma_val:default_gamma_val, $
		default_warnings:default_warnings, preview:0 $					
	}
;-------------------- RESTORED LOOPS PARAMS
	restoreparams = { $
		cfilecount:0, cfiles:PTR_NEW(STRARR(nphi)), sel_loops:PTR_NEW(INTARR(nphi)), $		
		xr:PTR_NEW(0), yr:PTR_NEW(0), $
    xp:PTR_NEW(0), yp:PTR_NEW(0), $
    imref:PTR_NEW(0), lp:PTR_NEW(0), $
		disp_loopfile:'0', disp_loopnr:PTR_NEW(-1), disp_imref:PTR_NEW(-1), disp_slices:PTR_NEW(0), $
		disp_ref_slices:PTR_NEW(0), $
    ngaps:PTR_NEW(0), databounds:PTR_NEW(0), $
    wdatabounds:PTR_NEW(0), ndatabounds:PTR_NEW(0) $
	}
;-------------------- RETRIEVE LOOP PARAMS
	retrparams = { $
		clfilecount:0, clfiles:PTR_NEW(STRARR(nphi)), sel_loops:PTR_NEW(INTARR(nphi)), $	
		retrieve_files:PTR_NEW(STRARR(nphi)), retrieve_filecount:0, $			
		lpsizes:PTR_NEW(LONARR(nphi)), lrsizes:PTR_NEW(LONARR(nphi)), $					
		xlr:PTR_NEW(0), ylr:PTR_NEW(0), $
    xlp:PTR_NEW(0), ylp:PTR_NEW(0) $
	}
;-------------------- SAVING PARAMS
	savparams = { $
		savpro:'', snapshot:0, lp_orig:lp_start, lp_ref_orig:lp_ref_start, filename_text:0, overlays_incl:0, overlays_thick:1, $
		overlays_curs:1, overlays_num:1, overlays_pts:1, linescan_ls:0, overlays_symsize:1, $
		overlays_asecbar:0, overlays_asecbar_length:1, overlays_asecbar_pix:1. $
	}
;-------------------- SAVING SWITCHES
	savswitch = { $
		cont:0, delete_clsav:0, imref_only:1, det_imref_only:1, $				
		all_pos_loops:1, pos_dets:1 $							
	}
;-------------------- SESSION PARAMS
	sesparams = { $
		rest_sessions:0, sessions:PTR_NEW(INTARR(nphi)), $
		curr_instance_id:LONG(set_instance_id), instance_label:instance_label $		
	}
;-------------------- SCALING
	scaling = { $
		imagescale:imagescale, imagemin:immin[hdr.lc], imagemax:immax[hdr.lc], $
		refmin:refmin[hdr.reflc], refmax:refmax[hdr.reflc], imrefscaling:0, relative:relative_scaling, $	
		scalestokes_max:hdr.scalestokes_max, dopmin:dopplermin[hdr.lc], dopmax:dopplermax[hdr.lc], $
    sjimin:sjimin, sjimax:sjimax, t_current:t_start, $
    imagemin_curr:immin[hdr.lc], imagemax_curr:immax[hdr.lc], $
		refmin_curr:refmin[hdr.reflc], refmax_curr:refmax[hdr.reflc], $
		dopmin_curr:dopplermin[hdr.lc], dopmax_curr:dopplermax[hdr.lc], $
    sjimin_curr:sjimin, sjimax_curr:sjimax, $
    spslice_min:REPLICATE(immin[hdr.lc],2*hdr.ndiagnostics+hdr.nrefdiagnostics+1),  $
    spslice_max:REPLICATE(immax[hdr.lc],2*hdr.ndiagnostics+hdr.nrefdiagnostics+1),  $
    phislice_min:REPLICATE(immin[hdr.lc],2*hdr.ndiagnostics+hdr.nrefdiagnostics+1),  $
    phislice_max:REPLICATE(immax[hdr.lc],2*hdr.ndiagnostics+hdr.nrefdiagnostics+1),  $
    gamma:REPLICATE(gamma_val,2*hdr.ndiagnostics+hdr.nrefdiagnostics+1), $
    minimum:REPLICATE(0,2*hdr.ndiagnostics+hdr.nrefdiagnostics+1),  $
    maximum:REPLICATE(100,2*hdr.ndiagnostics+hdr.nrefdiagnostics+1),  $
    idx:0, diagscale_label_vals:diagscale_label_vals, $
    histo_opt_val:REPLICATE(histo_opt_val,2*hdr.ndiagnostics+hdr.nrefdiagnostics+1),  $
    mult_val:[main_mult_val,ref_mult_val], $
    sel_xyslice:sel_xyslice, sel_refslice:sel_refslice, sel_dopslice:sel_dopslice, $
    sel_sjislice:sel_sjislice $
	}
;-------------------- STOKES PARAMS
	stokesparams = { $
		labels:hdr.stokes_labels, button_labels:stokes_button_labels, select_sp:hdr.stokes_select_sp, $	
		prev_select_sp:hdr.stokes_select_sp $
	}
;-------------------- VERSION INFO
	versioninfo = { $
		version_number:version_number, revision_number:revision_number $				
	}
;-------------------- WINDOW IDs
	winids = { $
		root:cpanel, imwid:imwid, xydrawid:xydrawid, $		
		reftlb:0, refwid:0, refdrawid:0, refdrawbase:0, $				
		doptlb:0, dopwid:0, dopdrawid:0, dopdrawbase:0, $
		imrefdisp:0, imreftlb:0, imrefwid:0, imrefdrawid:0, imrefdrawbase:0, $					
		lstlb:0, lswid:0, lsdrawid:0, reflstlb:0, reflswid:0, reflsdrawid:0, $
		sptlb:0, spwid:0, spdrawid:0, refsptlb:0, refspwid:0, refspdrawid:0, $
		phistlb:0, phiswid:0, phisdrawid:0, $				
		looptlb:0, loopwid:0, loopdrawid:0, $						
		reflooptlb:0, refloopwid:0, refloopdrawid:0, $						
		restlooptlb:PTR_NEW(0), restloopwid:PTR_NEW(0), restloopdrawid:PTR_NEW(0), $					
		retrdettlb:0, retrdetwid:0, retrdetdrawid:0, $					
		intwid:0, inttlb:0, intdrawid:0, intmenutlb:0, $
    sjiwid:0, sjitlb:0, sjidrawid:0, sjidrawbase:0, $
		savetlb:0, detsavetlb:0, restoretlb:0, preftlb:0, $							
		estimatetlb:0, savewintlb:0, saveoptwintlb:0, $
    paramtlb:0, $					
		feedbacktlb:0, abouttlb:0, errtlb:0, warntlb:0, restsesfeedbtlb:0, $
    shorttlb:0, headertlb:0, current_wid:0, $
		imwintitle:imwintitle, spwintitle:'',lswintitle:'',refwintitle:'',refspwintitle:'',reflswintitle:'', $
		imrefwintitle:'',dopwintitle:'',phiswintitle:'',restloopwintitle:PTR_NEW(''),retrdetwintitle:'',$
		loopwintitle:'',refloopwintitle:'',intwintitle:'', sjiwintitle:'' $
	}
;-------------------- WINDOW (RE)SIZES 
	winsizes = { $
		aboutwinx:startup_nx, aboutwiny:startup_ny, xywinx:imwinx, xywiny:imwiny, $
    imrefwinx:imrefwinx, imrefwiny:imrefwiny, $
		lswinx:lswinx, lswiny:lswiny, lsxres:lswinx, lsyres:lswiny, $
		spwinx:spwinx, spwiny:spwiny, spxres:spwinx, spyres:spwiny, $
    refwinx:refwinx, refwiny:refwiny, reflsxres:reflswinx, $
    reflsyres:reflswiny, refspxres:spwinx, refspyres:refspwiny, $
		phisxres:phiswinx, phisyres:phiswiny, refloopxres:spwinx, $
    refloopyres:spwiny, loopxres:spwinx, loopyres:spwiny, restloopxres:spwinx,$
    restloopyres:spwiny, retrdetxres:spwinx, retrdetyres:spwiny, $
    intxres:lswinx, intyres:intwiny, sjiwinx:sjiwinx, sjiwiny:sjiwiny, $
    ; window offsets
		xdelta:xdelta, ydelta:ydelta,  $
    spxoffset:spxoffset, spyoffset:spyoffset, $
    lsxoffset:lsxoffset, lsyoffset:lsyoffset, $
    phisxoffset:phisxoffset, phisyoffset:phisyoffset, $
    refxoffset:refxoffset, refyoffset:refyoffset, $
    refspxoffset:refspxoffset, refspyoffset:refspyoffset, $
    reflsxoffset:reflsxoffset, reflsyoffset:reflsyoffset, $
    sjixoffset:sjixoffset, sjiyoffset:sjiyoffset, $
    dopxoffset:dopxoffset, dopyoffset:dopyoffset, $
    imrefxoffset:imrefxoffset, imrefyoffset:imrefyoffset, $
    intxoffset:intxoffset, intyoffset:intyoffset, $
    loopxoffset:loopxoffset, loopyoffset:loopyoffset, $
    aboutxoffset:startup_xpos, aboutyoffset:startup_ypos $
		}
;-------------------- WINDOW SWITCHES
	winswitch = { $
		showls:0, showsp:0, showrefsp:hdr.refspfile, showrefls:showrefls, showimref:0, $
		estimate_win:0, showphis:0, showref:hdr.showref, showparam:0, showint:0, $
		showloop:0, showrefloop:0, showrestloop:0, showretrdet:0, showdop:0, dispwids:0, $
    showsji:hdr.sjifile $
	}
;-------------------- ZOOMING 
	zooming = { $
		factor:zoomfactors[0], factorswitch:factorswitch, factors:zoomfactors, $
    xpos:0L, ypos:0L, xsjipos:0L, ysjipos:0L, xrefpos:0L, yrefpos:0L $
	}
;-------------------- DEFINE INFO POINTER
	info = { $
		ctrlscp:PTR_NEW(ctrlscp, /NO_COPY), $
		ctrlsdet:PTR_NEW(ctrlsdet, /NO_COPY), $
		ctrlsfeedb:PTR_NEW(ctrlsfeedb, /NO_COPY), $
		ctrlshdr:PTR_NEW(ctrlshdr, /NO_COPY), $
		ctrlsint:PTR_NEW(ctrlsint, /NO_COPY), $
		ctrlsloop:PTR_NEW(ctrlsloop, /NO_COPY), $
		ctrlspbbut:PTR_NEW(ctrlspbbut, /NO_COPY), $
		ctrlsparam:PTR_NEW(ctrlsparam, /NO_COPY), $
		ctrlspref:PTR_NEW(ctrlspref, /NO_COPY), $
		ctrlsref:PTR_NEW(ctrlsref, /NO_COPY), $
		ctrlsrestore:PTR_NEW(ctrlsrestore, /NO_COPY), $
		ctrlssav:PTR_NEW(ctrlssav, /NO_COPY), $
		ctrlssji:PTR_NEW(ctrlssji, /NO_COPY), $
		ctrlsswitch:PTR_NEW(ctrlsswitch, /NO_COPY), $
		curs:PTR_NEW(curs, /NO_COPY), $
		data:PTR_NEW(data, /NO_COPY), $
		dataparams:PTR_NEW(dataparams, /NO_COPY), $
		dataswitch:PTR_NEW(dataswitch, /NO_COPY), $
		detparams:PTR_NEW(detparams, /NO_COPY), $
		dispparams:PTR_NEW(dispparams, /NO_COPY), $
		dispswitch:PTR_NEW(dispswitch, /NO_COPY), $
		feedbparams:PTR_NEW(feedbparams, /NO_COPY), $
		intparams:PTR_NEW(intparams, /NO_COPY), $
		ioparams:PTR_NEW(ioparams, /NO_COPY), $
		loopsdata:PTR_NEW(loopsdata, /NO_COPY), $
		loopparams:PTR_NEW(loopparams, /NO_COPY), $
		loopswitch:PTR_NEW(loopswitch, /NO_COPY), $
		meas:PTR_NEW(meas, /NO_COPY), $
		overlayparams:PTR_NEW(overlayparams, /NO_COPY), $
		overlayswitch:PTR_NEW(overlayswitch, /NO_COPY), $
		paramparams:PTR_NEW(paramparams, /NO_COPY), $
		paramswitch:PTR_NEW(paramswitch, /NO_COPY), $
		paths:PTR_NEW(paths, /NO_COPY), $
		pbparams:PTR_NEW(pbparams, /NO_COPY), $
		phiparams:PTR_NEW(phiparams, /NO_COPY), $
		plotaxes:PTR_NEW(plotaxes, /NO_COPY), $
		plotparams:PTR_NEW(plotparams, /NO_COPY), $
		plotpos:PTR_NEW(plotpos, /NO_COPY), $
		plotswitch:PTR_NEW(plotswitch, /NO_COPY), $
		plottitles:PTR_NEW(plottitles, /NO_COPY), $
		prefs:PTR_NEW(prefs, /NO_COPY), $
		restoreparams:PTR_NEW(restoreparams, /NO_COPY), $
		retrparams:PTR_NEW(retrparams, /NO_COPY), $
		savparams:PTR_NEW(savparams, /NO_COPY), $
		savswitch:PTR_NEW(savswitch, /NO_COPY), $
		sesparams:PTR_NEW(sesparams, /NO_COPY), $
		scaling:PTR_NEW(scaling, /NO_COPY), $
		stokesparams:PTR_NEW(stokesparams, /NO_COPY), $
		versioninfo:PTR_NEW(versioninfo, /NO_COPY), $
		winids:PTR_NEW(winids, /NO_COPY), $
		winsizes:PTR_NEW(winsizes, /NO_COPY), $
		winswitch:PTR_NEW(winswitch, /NO_COPY), $
		zooming:PTR_NEW(zooming, /NO_COPY) $
	}
	info = PTR_NEW(info, /NO_COPY)
	WIDGET_CONTROL, cpanel, SET_UVALUE = info

	pseudoevent = { WIDGET_BUTTON, id:cpanel, top:cpanel, handler:0L, select:1 }
	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(defining main pointer)', /WIDGET, /OVER, /DONE
	feedback_text = [feedback_text[0:N_ELEMENTS(feedback_text)-2],'> Defining main pointer... done!']
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text

;--------------------------------------------------------------------------------- DETERMINE DISPLAY OF PLOTS
	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(determining display of plots)', /WIDGET, /OVER
	feedback_text = [feedback_text,'> Determining display of plots... ']
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text
	IF (((*(*info).dataswitch).spfile EQ 1) AND ((*(*info).dataparams).mainnt GT 1)) THEN BEGIN
		WIDGET_CONTROL, sp_toggle_but, SET_BUTTON = 1
		(*(*info).winswitch).showsp = 1
	ENDIF ELSE BEGIN
    ; If no spectral file is provided
		IF (hdr.single_cube[0] EQ 1) THEN BEGIN
			(*(*info).dispparams).lp_upp = (*(*info).dispparams).lp_low
			(*(*info).winswitch).showphis = 0
			(*(*info).winswitch).showls = 0
			WIDGET_CONTROL, approxmenu, SENSITIVE = 0
			WIDGET_CONTROL, save_ex_slab_but, SENSITIVE = 0
			WIDGET_CONTROL, ls_toggle_but, SENSITIVE = 0
			WIDGET_CONTROL, subtract_but, SENSITIVE = 0
			WIDGET_CONTROl, lower_y_text, SENSITIVE = 0
			WIDGET_CONTROL, upper_y_text, SENSITIVE = 0
			WIDGET_CONTROL, phis_toggle_but, SENSITIVE = 0
		ENDIF ELSE BEGIN
			IF (hdr.single_cube[0] GE 1) THEN WIDGET_CONTROL, approxmenu, SENSITIVE = 0
			WIDGET_CONTROL, (*(*info).ctrlscp).slice_button, SENSITIVE = 0
			(*(*info).winswitch).showphis = 0
		ENDELSE
		WIDGET_CONTROL, sp_toggle_but, SENSITIVE=0
		IF (hdr.mainnt EQ 1) THEN BEGIN
			WIDGET_CONTROL, fbwd_button, SENSITIVE = 0, SET_VALUE = bmpbut_fbwd_idle
			WIDGET_CONTROL, backward_button, SENSITIVE = 0, SET_VALUE = bmpbut_bwd_idle
			WIDGET_CONTROL, pause_button, SENSITIVE = 0, SET_VALUE = bmpbut_pause_idle
			WIDGET_CONTROL, forward_button, SENSITIVE = 0, SET_VALUE = bmpbut_fwd_idle
			WIDGET_CONTROL, ffwd_button, SENSITIVE = 0, SET_VALUE = bmpbut_ffwd_idle
			WIDGET_CONTROL, loop_button, SENSITIVE = 0, SET_VALUE = bmpbut_loop_idle
			WIDGET_CONTROL, cycle_button, SENSITIVE = 0, SET_VALUE = bmpbut_cycle_idle
			WIDGET_CONTROL, blink_button, SENSITIVE = 0, SET_VALUE = bmpbut_blink_idle
			WIDGET_CONTROL, t_slid, SENSITIVE = 0
			WIDGET_CONTROL, t_step_slid, SENSITIVE = 0
			WIDGET_CONTROL, upper_t_text, SET_VALUE = '0', SENSITIVE = 0
			WIDGET_CONTROL, lower_t_text, SET_VALUE = '0', SENSITIVE = 0
			WIDGET_CONTROL, save_as_jpg_all, SENSITIVE = 0
			WIDGET_CONTROL, save_as_png_all, SENSITIVE = 0
			WIDGET_CONTROL, save_as_mpeg, SENSITIVE = 0
			WIDGET_CONTROL, sh_fbwd_button, SENSITIVE = 0
			WIDGET_CONTROL, sh_backward_button, SENSITIVE = 0
			WIDGET_CONTROL, sh_pause_button, SENSITIVE = 0
			WIDGET_CONTROL, sh_forward_button, SENSITIVE = 0
			WIDGET_CONTROL, sh_ffwd_button, SENSITIVE = 0
			WIDGET_CONTROL, timeslicemenu, SENSITIVE = 0
      WIDGET_CONTROL, det_file_loop, SENSITIVE=0
			*(*(*info).data).scan = (*(*(*info).data).scan)[0]
			*(*(*info).data).phiscan = *(*(*info).data).scan
		ENDIF 
		WIDGET_CONTROL, loop_slit_but, SENSITIVE = exts_set
		WIDGET_CONTROL, loop_feedb_but, SENSITIVE = exts_set
		WIDGET_CONTROL, timeslicemenu, SENSITIVE = 0 
	ENDELSE
	IF (N_ELEMENTS(hdr.single_cube[0]) EQ 1) THEN BEGIN
		WIDGET_CONTROL, ls_toggle_but, SET_BUTTON = (hdr.single_cube[0] NE 1) 
		(*(*info).winswitch).showls = (hdr.single_cube[0] NE 1) 
	ENDIF ELSE BEGIN
		WIDGET_CONTROL, ls_toggle_but, SET_BUTTON = 1
		(*(*info).winswitch).showls = 1
	ENDELSE
  WIDGET_CONTROL, (*(*info).ctrlscp).lower_lp_text, SENSITIVE=((*(*info).intparams).ndiagnostics LE 1) 
  WIDGET_CONTROL, (*(*info).ctrlscp).upper_lp_text, SENSITIVE=((*(*info).intparams).ndiagnostics LE 1) 

	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(determining display of plots)', /WIDGET, /OVER, /DONE
	feedback_text = [feedback_text[0:N_ELEMENTS(feedback_text)-2],'> Determining display of plots... done!']
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text
;--------------------------------------------------------------------------------- OPENING WINDOWS
	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(realising widget and updating windows)', $
                                        /WIDGET, /OVER
	feedback_text = [feedback_text,'> Realising widget and updating windows... ']
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text
	CRISPEX_MASK_BUTTONS_SET, pseudoevent
  set_zoomfac = CRISPEX_BGROUP_ZOOMFAC_SET(pseudoevent, /NO_DRAW, SET_FACTOR=0)
  IF (hdr.mainnt GT 1) THEN CRISPEX_DISPRANGE_T_RANGE, pseudoevent, /NO_DRAW
  IF ((*(*info).winswitch).showsp OR (*(*info).winswitch).showls OR $
    (*(*info).winswitch).showphis) THEN $
    CRISPEX_DRAW_GET_SPECTRAL_AXES, pseudoevent, /MAIN
	IF (*(*info).winswitch).showsp THEN BEGIN
		(*(*info).winswitch).showsp = 0
		CRISPEX_DISPLAYS_SP_TOGGLE, pseudoevent
		IF startupwin THEN WSHOW, startupwid
	ENDIF
	IF (*(*info).winswitch).showls THEN BEGIN
		(*(*info).winswitch).showls = 0
		(*(*info).ctrlsswitch).imrefdetspect = 0
		CRISPEX_DISPLAYS_IMREF_LS_TOGGLE, pseudoevent, NO_DRAW=(*(*info).winswitch).showrefls
		IF startupwin THEN WSHOW, startupwid
	ENDIF
	IF (*(*info).winswitch).showref THEN BEGIN
		(*(*info).winswitch).showref = 0
		CRISPEX_DISPLAYS_REF_TOGGLE, pseudoevent
		IF startupwin THEN WSHOW, startupwid
	ENDIF
  IF ((*(*info).winswitch).showrefsp OR (*(*info).winswitch).showrefls) THEN $
    CRISPEX_DRAW_GET_SPECTRAL_AXES, pseudoevent, /REFERENCE
	IF (*(*info).winswitch).showrefsp THEN BEGIN
		WIDGET_CONTROL, (*(*info).ctrlscp).refsp_toggle_but, SET_BUTTON = 1
		(*(*info).winswitch).showrefsp = 0
		CRISPEX_DISPLAYS_REFSP_TOGGLE, pseudoevent
		IF startupwin THEN WSHOW, startupwid
	ENDIF ELSE WIDGET_CONTROL, (*(*info).ctrlscp).refsp_toggle_but, SENSITIVE = 0
	IF (*(*info).winswitch).showrefls THEN BEGIN
		IF ((*(*info).dataswitch).refspfile EQ 0) THEN *(*(*info).data).refsspscan = (*(*(*info).data).refscan)[0]
		(*(*info).winswitch).showrefls = 0
		(*(*info).ctrlsswitch).imrefdetspect = 1
		CRISPEX_DISPLAYS_IMREF_LS_TOGGLE, pseudoevent
		IF startupwin THEN WSHOW, startupwid
	ENDIF
	IF (*(*info).winswitch).showphis THEN BEGIN
		(*(*info).winswitch).showphis = 0
		CRISPEX_DISPLAYS_PHIS_TOGGLE, pseudoevent, /NO_DRAW
		IF startupwin THEN WSHOW, startupwid
	ENDIF
  IF (*(*info).winswitch).showsji THEN BEGIN
    (*(*info).winswitch).showsji = 0
		CRISPEX_DISPLAYS_SJI_TOGGLE, pseudoevent, /NO_DRAW
		IF startupwin THEN WSHOW, startupwid
  ENDIF

	CRISPEX_FIND_CLSAV, pseudoevent
	IF ((*(*info).retrparams).clfilecount NE 0) THEN BEGIN
		WIDGET_CONTROL, (*(*info).ctrlscp).sel_saved_loop, SENSITIVE = 1
		WIDGET_CONTROL, (*(*info).ctrlscp).all_saved_loop, SENSITIVE = 1
	ENDIF
  
	CRISPEX_UPDATE_T, pseudoevent
	IF ((((*(*info).dataswitch).spfile EQ 1) OR (*(*info).dataswitch).onecube) $
    AND ((*(*info).winswitch).showphis NE 1)) THEN $
    CRISPEX_UPDATE_SLICES, pseudoevent, /NO_DRAW, /NO_FEEDBACK
	IF showrefls THEN BEGIN
		IF (ref_detspect_scale EQ 0) THEN BEGIN
			CRISPEX_DISPRANGE_LS_SCALE_REF, pseudoevent
			CRISPEX_DISPRANGE_LS_RANGE, pseudoevent, /NO_DRAW
		ENDIF
		CRISPEX_DISPLAYS_DETSPECT_IM_SELECT, pseudoevent
	ENDIF
	IF (detspect_scale EQ 0) THEN BEGIN
		CRISPEX_DISPRANGE_LS_SCALE_MAIN, pseudoevent
		CRISPEX_DISPRANGE_LS_RANGE, pseudoevent, /NO_DRAW
	ENDIF
  CRISPEX_SCALING_APPLY_SELECTED, pseudoevent
	CRISPEX_DRAW, pseudoevent
	
	spwset = ((*(*info).winswitch).showsp OR (*(*info).winswitch).showphis OR $
            (*(*info).winswitch).showrefsp) 
	IF (*(*info).winswitch).showls THEN $
    lsoffset = (*(*info).winswitch).showls * ((*(*info).winsizes).lswiny + $
    (*(*info).winsizes).ydelta) + (*(*info).dataswitch).refspfile * (*(*info).winsizes).ydelta $
   ELSE $
		lsoffset = (*(*info).winswitch).showrefls * (reflswiny + (*(*info).winsizes).ydelta)
	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(realising widget and updating windows)', $
                                        /WIDGET, /OVER, /DONE
	IF startupwin THEN BEGIN
		WSET, startupwid
		feedback_text = [feedback_text[0:N_ELEMENTS(feedback_text)-2],$
      '> Realising widget and updating windows... done!']
		CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text
	ENDIF

;--------------------------------------------------------------------------------- START MANAGING
	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(start managing)', /WIDGET, /OVER
	feedback_text = [feedback_text,'> Start managing... ']
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text
	XMANAGER, 'CRISPEX', cpanel, /NO_BLOCK
	WSHOW, (*(*info).winids).imwid
	IF (TOTAL(verbosity[0:1]) GE 1) THEN CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, $
                                        '(start managing)', /WIDGET, /OVER, /DONE
	feedback_text = [feedback_text[0]+'done!',feedback_text[1:N_ELEMENTS(feedback_text)-2],$
    '> Start managing... done!']
	IF startupwin THEN CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, feedback_text
	WAIT,0.1
	IF (*(*info).prefs).autoplay THEN CRISPEX_PB_FORWARD, pseudoevent
	IF resave_preferences THEN CRISPEX_PREFERENCES_SAVE_SETTINGS, pseudoevent, /RESAVE
	IF (TOTAL(verbosity[0:1]) GE 1) THEN BEGIN
    msg = 'Set-up done!'
    IF verbosity[1] THEN $
      msg += ' Finished in '+$
        STRTRIM(SYSTIME(/SECONDS)-setup_starttime,2)+' s.' 
    CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, msg
  ENDIF
	IF startupwin THEN BEGIN
		WSET, startupwid
		CRISPEX_UPDATE_STARTUP_FEEDBACK, startup_im, xout, yout, 'Set-up done!'
		WAIT,0.25
		WIDGET_CONTROL, startuptlb, /DESTROY
	ENDIF
	CRISPEX_VERBOSE_SET_BUTTONS, pseudoevent

  ; Issue last warning/error messages before finishing setup
  ; Issue only if WARNINGS >= 1
  IF ((*(*info).prefs).warnings GE 1) THEN BEGIN
    msg = ''
    IF (extreme_aspect AND (hdr.nx EQ 1)) THEN $
      msg = 'Extreme aspect ratio detected with NX = 1. Stretching '+$
        'x-dimension for easier visualisation: note that the '+$
        'image pixel aspect ratio is now inaccurate.'
    IF (STRCOMPRESS(msg) NE '') THEN BEGIN
      IF ((*(*info).prefs).warnings EQ 1) THEN $
        CRISPEX_UPDATE_STARTUP_SETUP_FEEDBACK, msg, /WARNING, /NO_ROUTINE, /NEWLINE $
      ELSE $
        CRISPEX_WINDOW_OK, pseudoevent, 'WARNING!', msg, $
    			OK_EVENT='CRISPEX_CLOSE_EVENT_WINDOW',$;, /BLOCK
          NO_SHOW_EVENT='CRISPEX_PREFERENCES_SET_WARNINGS_SETUP', $
          NO_SHOW_CHOICES=['Do not show set-up warnings',$
            'Write set-up warnings to terminal only',$
            'Always pop-up set-up warnings'], $
          SET_CHOICE_IDX=(*(*info).prefs).warnings
    ENDIF
  ENDIF
END
